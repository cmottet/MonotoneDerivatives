> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 1
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 3  3  2  1  0  1  2  3 0.14194 0.14194 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  0  1  2  3 0.017226 0.017226 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  3  2  1  0  1  2  3 0.0025533 0.0025535 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  3  2  1  0  1  2  3 0.00074476 0.00074484 1e-04
[1] " "
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 1
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 3  3  2  1  0  1  2  3 0.14194 0.14194 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  0  1  2  3 0.017226 0.017226 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  3  2  1  0  1  2  3 0.0025533 0.0025535 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  3  2  1  0  1  2  3 0.00074476 0.00074484 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 4  3  2  1  0  1  2  3 0.13837 0.13838 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 4  3  2  1  0  1  2  3 0.016192 0.016193 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  3  2  1  0  1  2  3 0.0023968 0.0023969 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB         uB     P
[1,]   1 4  3  2  1  0  1  2  3 0.0006963 0.00069634 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3      lB     uB   P
[1,]   1 5  3  2  1  0  1  2  3 0.13609 0.1361 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  3  2  1  0  1  2  3 0.015523 0.015525 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  3  2  1  0  1  2  3 0.0022957 0.0022959 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2 m3        lB         uB     P
[1,]   1 5  3  2  1  0  1  2  3 0.0006648 0.00066484 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 2
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m1 m2 m3      lB     uB   P
[1,]   1 2  2  1  0  1  2  3 0.14818 0.1482 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 2  2  1  0  1  2  3 0.018825 0.018826 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 2  2  1  0  1  2  3 0.0027949 0.0027951 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 2  2  1  0  1  2  3 0.00081913 0.00081916 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 3  2  1  0  1  2  3 0.14177 0.14177 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  2  1  0  1  2  3 0.017023 0.017023 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  2  1  0  1  2  3 0.0025211 0.0025212 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2 m3         lB        uB     P
[1,]   1 3  2  1  0  1  2  3 0.00073505 0.0007351 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2 m3     lB      uB   P
[1,]   1 4  2  1  0  1  2  3 0.1382 0.13821 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 4  2  1  0  1  2  3 0.016001 0.016002 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  2  1  0  1  2  3 0.0023662 0.0023662 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  2  1  0  1  2  3 0.00068704 0.00068706 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 5  2  1  0  1  2  3 0.13593 0.13594 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  2  1  0  1  2  3 0.015329 0.015331 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  2  1  0  1  2  3 0.0021651 0.0022163 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  2  1  0  1  2  3 0.00062674 0.00064201 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 3
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 3  3  1  0  1  2  3 0.14177 0.14177 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  3  1  0  1  2  3 0.017022 0.017024 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  3  1  0  1  2  3 0.0025211 0.0025212 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  3  1  0  1  2  3 0.00073505 0.00073512 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m2 m3     lB      uB   P
[1,]   1 4  3  1  0  1  2  3 0.1382 0.13821 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 4  3  1  0  1  2  3 0.016002 0.016003 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  3  1  0  1  2  3 0.0023663 0.0023663 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  3  1  0  1  2  3 0.00068705 0.00068709 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 5  3  1  0  1  2  3 0.13593 0.13594 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  3  1  0  1  2  3 0.015341 0.015342 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  3  1  0  1  2  3 0.0022662 0.0022663 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  3  1  0  1  2  3 0.00065583 0.00065589 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 4
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 1  1  0  1  2  3 0.16266 0.16266 0.1
[1] " "
     Dir D d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 1  1  0  1  2  3 0.022906 0.022907 0.01
[1] " "
     Dir D d1 m0 m1 m2 m3        lB       uB     P
[1,]   1 1  1  0  1  2  3 0.0034128 0.003413 0.001
[1] " "
     Dir D d1 m0 m1 m2 m3        lB       uB     P
[1,]   1 1  1  0  1  2  3 0.0010029 0.001003 1e-04
[1] " "
     Dir D d1 m0 m1 m2 m3     lB      uB   P
[1,]   1 2  1  0  1  2  3 0.1476 0.14761 0.1
[1] " "
     Dir D d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 2  1  0  1  2  3 0.018765 0.018766 0.01
[1] " "
     Dir D d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 2  1  0  1  2  3 0.0027842 0.0027844 0.001
[1] " "
     Dir D d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 2  1  0  1  2  3 0.00081582 0.00081583 1e-04
[1] " "
     Dir D d1 m0 m1 m2 m3     lB      uB   P
[1,]   1 3  1  0  1  2  3 0.1412 0.14121 0.1
[1] " "
     Dir D d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  1  0  1  2  3 0.016967 0.016968 0.01
[1] " "
     Dir D d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  1  0  1  2  3 0.0024498 0.0024679 0.001
[1] " "
     Dir D d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  1  0  1  2  3 0.00071903 0.00072471 1e-04
[1] " "
     Dir D d1 m0 m1 m2 m3      lB      uB   P
[1,]   1 4  1  0  1  2  3 0.13718 0.13733 0.1
[1] " "
     Dir D d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 4  1  0  1  2  3 0.015867 0.015916 0.01
[1] " "
     Dir D d1 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  1  0  1  2  3 0.0019158 0.0022323 0.001
[1] " "
     Dir D d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  1  0  1  2  3 0.00055053 0.00065733 1e-04
[1] " "
     Dir D d1 m0 m1 m2 m3      lB     uB   P
[1,]   1 5  1  0  1  2  3 0.12423 0.1331 0.1
[1] " "
     Dir D d1 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  1  0  1  2  3 0.015091 0.015159 0.01
[1] " "
     Dir D d1 m0 m1 m2 m3         lB       uB     P
[1,]   1 5  1  0  1  2  3 0.00085197 0.001933 0.001
[1] " "
     Dir D d1 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  1  0  1  2  3 0.00020095 0.00055481 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 5
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m1 m2 m3      lB      uB   P
[1,]   1 3  3  2  0  1  2  3 0.14177 0.14178 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  3  2  0  1  2  3 0.017023 0.017024 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  3  2  0  1  2  3 0.0025325 0.0025326 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  3  2  0  1  2  3 0.00073972 0.00073978 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m2 m3     lB      uB   P
[1,]   1 4  3  2  0  1  2  3 0.1382 0.13821 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 4  3  2  0  1  2  3 0.016002 0.016003 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  3  2  0  1  2  3 0.0023757 0.0023759 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  3  2  0  1  2  3 0.00069364 0.00069367 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m2 m3      lB      uB   P
[1,]   1 5  3  2  0  1  2  3 0.13593 0.13595 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  3  2  0  1  2  3 0.015342 0.015342 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  3  2  0  1  2  3 0.0022738 0.0022742 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  3  2  0  1  2  3 0.00066375 0.00066381 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 6
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m1 m2 m3     lB      uB   P
[1,]   1 2  2  0  1  2  3 0.1476 0.14761 0.1
[1] " "
     Dir D d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 2  2  0  1  2  3 0.018764 0.018765 0.01
[1] " "
     Dir D d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 2  2  0  1  2  3 0.0027941 0.0027943 0.001
[1] " "
     Dir D d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 2  2  0  1  2  3 0.00081713 0.00081718 1e-04
[1] " "
     Dir D d2 m0 m1 m2 m3     lB      uB   P
[1,]   1 3  2  0  1  2  3 0.1412 0.14121 0.1
[1] " "
     Dir D d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  2  0  1  2  3 0.016967 0.016969 0.01
[1] " "
     Dir D d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  2  0  1  2  3 0.0025228 0.0025229 0.001
[1] " "
     Dir D d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  2  0  1  2  3 0.00073614 0.00073618 1e-04
[1] " "
     Dir D d2 m0 m1 m2 m3      lB      uB   P
[1,]   1 4  2  0  1  2  3 0.13766 0.13766 0.1
[1] " "
     Dir D d2 m0 m1 m2 m3      lB       uB    P
[1,]   1 4  2  0  1  2  3 0.01595 0.015951 0.01
[1] " "
     Dir D d2 m0 m1 m2 m3        lB       uB     P
[1,]   1 4  2  0  1  2  3 0.0023628 0.002364 0.001
[1] " "
     Dir D d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  2  0  1  2  3 0.00068744 0.00068926 1e-04
[1] " "
     Dir D d2 m0 m1 m2 m3     lB      uB   P
[1,]   1 5  2  0  1  2  3 0.1354 0.13541 0.1
[1] " "
     Dir D d2 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  2  0  1  2  3 0.015293 0.015293 0.01
[1] " "
     Dir D d2 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  2  0  1  2  3 0.0021065 0.0021997 0.001
[1] " "
     Dir D d2 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  2  0  1  2  3 0.00060445 0.00064164 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 7
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m1 m2 m3     lB      uB   P
[1,]   1 3  3  0  1  2  3 0.1412 0.14121 0.1
[1] " "
     Dir D d3 m0 m1 m2 m3       lB       uB    P
[1,]   1 3  3  0  1  2  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 m0 m1 m2 m3        lB        uB     P
[1,]   1 3  3  0  1  2  3 0.0025252 0.0025254 0.001
[1] " "
     Dir D d3 m0 m1 m2 m3         lB         uB     P
[1,]   1 3  3  0  1  2  3 0.00073615 0.00073621 1e-04
[1] " "
     Dir D d3 m0 m1 m2 m3      lB      uB   P
[1,]   1 4  3  0  1  2  3 0.13766 0.13766 0.1
[1] " "
     Dir D d3 m0 m1 m2 m3      lB       uB    P
[1,]   1 4  3  0  1  2  3 0.01595 0.015952 0.01
[1] " "
     Dir D d3 m0 m1 m2 m3        lB        uB     P
[1,]   1 4  3  0  1  2  3 0.0023731 0.0023732 0.001
[1] " "
     Dir D d3 m0 m1 m2 m3         lB         uB     P
[1,]   1 4  3  0  1  2  3 0.00069018 0.00069021 1e-04
[1] " "
     Dir D d3 m0 m1 m2 m3     lB      uB   P
[1,]   1 5  3  0  1  2  3 0.1354 0.13541 0.1
[1] " "
     Dir D d3 m0 m1 m2 m3       lB       uB    P
[1,]   1 5  3  0  1  2  3 0.015293 0.015293 0.01
[1] " "
     Dir D d3 m0 m1 m2 m3        lB        uB     P
[1,]   1 5  3  0  1  2  3 0.0022648 0.0022727 0.001
[1] " "
     Dir D d3 m0 m1 m2 m3         lB         uB     P
[1,]   1 5  3  0  1  2  3 0.00066038 0.00066044 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 8
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m1 m2 m3      lB      uB   P
[1,]   1 0  0  1  2  3 0.24291 0.24291 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 0  0  1  2  3 0.053693 0.053693 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 0  0  1  2  3 0.0080187 0.0080189 0.001
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 0  0  1  2  3 0.0023689 0.0023691 1e-04
[1] " "
     Dir D m0 m1 m2 m3      lB      uB   P
[1,]   1 1  0  1  2  3 0.16171 0.16171 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 1  0  1  2  3 0.022652 0.022652 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 1  0  1  2  3 0.0033736 0.0033738 0.001
[1] " "
     Dir D m0 m1 m2 m3         lB        uB     P
[1,]   1 1  0  1  2  3 0.00099023 0.0009903 1e-04
[1] " "
     Dir D m0 m1 m2 m3      lB      uB   P
[1,]   1 2  0  1  2  3 0.13262 0.14469 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 2  0  1  2  3 0.018556 0.018556 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 2  0  1  2  3 0.0027035 0.0027472 0.001
[1] " "
     Dir D m0 m1 m2 m3        lB         uB     P
[1,]   1 2  0  1  2  3 0.0007556 0.00077832 1e-04
[1] " "
     Dir D m0 m1 m2 m3      lB      uB   P
[1,]   1 3  0  1  2  3 0.13225 0.13455 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 3  0  1  2  3 0.016024 0.016638 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 3  0  1  2  3 0.0020119 0.0020131 0.001
[1] " "
     Dir D m0 m1 m2 m3         lB         uB     P
[1,]   1 3  0  1  2  3 0.00053164 0.00066018 1e-04
[1] " "
     Dir D m0 m1 m2 m3       lB      uB   P
[1,]   1 4  0  1  2  3 0.054285 0.13615 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 4  0  1  2  3 0.013791 0.015542 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 4  0  1  2  3 0.0015703 0.0021209 0.001
[1] " "
     Dir D m0 m1 m2 m3         lB         uB     P
[1,]   1 4  0  1  2  3 0.00010906 0.00052072 1e-04
[1] " "
     Dir D m0 m1 m2 m3       lB      uB   P
[1,]   1 5  0  1  2  3 0.074604 0.13076 0.1
[1] " "
     Dir D m0 m1 m2 m3       lB       uB    P
[1,]   1 5  0  1  2  3 0.014605 0.015105 0.01
[1] " "
     Dir D m0 m1 m2 m3        lB        uB     P
[1,]   1 5  0  1  2  3 0.0010797 0.0011008 0.001
[1] " "
     Dir D m0 m1 m2 m3         lB         uB     P
[1,]   1 5  0  1  2  3 0.00023483 0.00024138 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 9
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 3  3  2  1  1  2  3 0.15482 0.15483 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  1  2  3 0.017023 0.017024 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 3  3  2  1  1  2  3 0.0025211 0.0025212 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 3  3  2  1  1  2  3 0.00073505 0.00073512 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 4  3  2  1  1  2  3 0.15014 0.15015 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 4  3  2  1  1  2  3 0.016002 0.016003 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 4  3  2  1  1  2  3 0.0023662 0.0023663 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 4  3  2  1  1  2  3 0.00068705 0.00068709 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 5  3  2  1  1  2  3 0.14712 0.14712 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 5  3  2  1  1  2  3 0.015341 0.015342 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 5  3  2  1  1  2  3 0.0022661 0.0022664 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 5  3  2  1  1  2  3 0.00065583 0.00065585 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 10
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m1 m2 m3     lB     uB   P
[1,]   1 2  2  1  1  2  3 0.1627 0.1627 0.1
[1] " "
     Dir D d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 2  2  1  1  2  3 0.018765 0.018766 0.01
[1] " "
     Dir D d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 2  2  1  1  2  3 0.0027843 0.0027846 0.001
[1] " "
     Dir D d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 2  2  1  1  2  3 0.00081581 0.00081587 1e-04
[1] " "
     Dir D d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 3  2  1  1  2  3 0.15441 0.15442 0.1
[1] " "
     Dir D d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 3  2  1  1  2  3 0.016968 0.016969 0.01
[1] " "
     Dir D d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 3  2  1  1  2  3 0.0025112 0.0025113 0.001
[1] " "
     Dir D d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 3  2  1  1  2  3 0.00073187 0.00073194 1e-04
[1] " "
     Dir D d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 4  2  1  1  2  3 0.14975 0.14976 0.1
[1] " "
     Dir D d2 d1 m1 m2 m3       lB      uB    P
[1,]   1 4  2  1  1  2  3 0.015949 0.01595 0.01
[1] " "
     Dir D d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 4  2  1  1  2  3 0.0023563 0.0023563 0.001
[1] " "
     Dir D d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 4  2  1  1  2  3 0.00068391 0.00068396 1e-04
[1] " "
     Dir D d2 d1 m1 m2 m3      lB      uB   P
[1,]   1 5  2  1  1  2  3 0.14131 0.14363 0.1
[1] " "
     Dir D d2 d1 m1 m2 m3       lB       uB    P
[1,]   1 5  2  1  1  2  3 0.015275 0.015281 0.01
[1] " "
     Dir D d2 d1 m1 m2 m3        lB        uB     P
[1,]   1 5  2  1  1  2  3 0.0022141 0.0022381 0.001
[1] " "
     Dir D d2 d1 m1 m2 m3         lB         uB     P
[1,]   1 5  2  1  1  2  3 0.00063381 0.00064664 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 11
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m1 m2 m3      lB      uB   P
[1,]   1 3  3  1  1  2  3 0.15442 0.15443 0.1
[1] " "
     Dir D d3 d1 m1 m2 m3       lB       uB    P
[1,]   1 3  3  1  1  2  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 d1 m1 m2 m3        lB        uB     P
[1,]   1 3  3  1  1  2  3 0.0025112 0.0025113 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d1 m1 m2 m3         lB         uB     P
[1,]   1 3  3  1  1  2  3 0.00073188 0.00073264 1e-04
[1] " "
     Dir D d3 d1 m1 m2 m3      lB      uB   P
[1,]   1 4  3  1  1  2  3 0.14975 0.14976 0.1
[1] " "
     Dir D d3 d1 m1 m2 m3      lB       uB    P
[1,]   1 4  3  1  1  2  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d1 m1 m2 m3        lB        uB     P
[1,]   1 4  3  1  1  2  3 0.0023567 0.0023567 0.001
[1] " "
     Dir D d3 d1 m1 m2 m3         lB         uB     P
[1,]   1 4  3  1  1  2  3 0.00068395 0.00068398 1e-04
[1] " "
     Dir D d3 d1 m1 m2 m3      lB      uB   P
[1,]   1 5  3  1  1  2  3 0.14674 0.14675 0.1
[1] " "
     Dir D d3 d1 m1 m2 m3       lB       uB    P
[1,]   1 5  3  1  1  2  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d1 m1 m2 m3        lB        uB     P
[1,]   1 5  3  1  1  2  3 0.0022569 0.0022571 0.001
[1] " "
     Dir D d3 d1 m1 m2 m3         lB         uB     P
[1,]   1 5  3  1  1  2  3 0.00065276 0.00065278 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 12
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m1 m2 m3      lB      uB   P
[1,]   1 1  1  1  2  3 0.18167 0.18167 0.1
[1] " "
     Dir D d1 m1 m2 m3       lB       uB    P
[1,]   1 1  1  1  2  3 0.022652 0.022652 0.01
[1] " "
     Dir D d1 m1 m2 m3        lB       uB     P
[1,]   1 1  1  1  2  3 0.0033728 0.003373 0.001
[1] " "
     Dir D d1 m1 m2 m3        lB         uB     P
[1,]   1 1  1  1  2  3 0.0009947 0.00099474 1e-04
[1] " "
     Dir D d1 m1 m2 m3      lB      uB   P
[1,]   1 2  1  1  2  3 0.16148 0.16149 0.1
[1] " "
     Dir D d1 m1 m2 m3       lB       uB    P
[1,]   1 2  1  1  2  3 0.018556 0.018556 0.01
[1] " "
     Dir D d1 m1 m2 m3        lB        uB     P
[1,]   1 2  1  1  2  3 0.0027505 0.0027505 0.001
[1] " "
     Dir D d1 m1 m2 m3         lB         uB     P
[1,]   1 2  1  1  2  3 0.00080553 0.00080557 1e-04
[1] " "
     Dir D d1 m1 m2 m3      lB      uB   P
[1,]   1 3  1  1  2  3 0.14717 0.15157 0.1
[1] " "
     Dir D d1 m1 m2 m3       lB       uB    P
[1,]   1 3  1  1  2  3 0.016779 0.016779 0.01
[1] " "
     Dir D d1 m1 m2 m3        lB        uB     P
[1,]   1 3  1  1  2  3 0.0024478 0.0024712 0.001
[1] " "
     Dir D d1 m1 m2 m3        lB         uB     P
[1,]   1 3  1  1  2  3 0.0006983 0.00070705 1e-04
[1] " "
     Dir D d1 m1 m2 m3       lB      uB   P
[1,]   1 4  1  1  2  3 0.098112 0.12925 0.1
[1] " "
     Dir D d1 m1 m2 m3       lB       uB    P
[1,]   1 4  1  1  2  3 0.015631 0.015673 0.01
[1] " "
     Dir D d1 m1 m2 m3       lB        uB     P
[1,]   1 4  1  1  2  3 0.002133 0.0021867 0.001
[1] " "
     Dir D d1 m1 m2 m3         lB         uB     P
[1,]   1 4  1  1  2  3 0.00052719 0.00058879 1e-04
[1] " "
     Dir D d1 m1 m2 m3       lB      uB   P
[1,]   1 5  1  1  2  3 0.098091 0.13623 0.1
[1] " "
     Dir D d1 m1 m2 m3       lB       uB    P
[1,]   1 5  1  1  2  3 0.015071 0.015121 0.01
[1] " "
     Dir D d1 m1 m2 m3        lB        uB     P
[1,]   1 5  1  1  2  3 0.0017232 0.0019688 0.001
[1] " "
     Dir D d1 m1 m2 m3         lB         uB     P
[1,]   1 5  1  1  2  3 0.00036018 0.00051011 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 13
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m1 m2 m3      lB      uB   P
[1,]   1 3  3  2  1  2  3 0.15443 0.15443 0.1
[1] " "
     Dir D d3 d2 m1 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  2  3 0.016969 0.016969 0.01
[1] " "
     Dir D d3 d2 m1 m2 m3        lB       uB     P
[1,]   1 3  3  2  1  2  3 0.0025228 0.002523 0.001
[1] " "
     Dir D d3 d2 m1 m2 m3         lB         uB     P
[1,]   1 3  3  2  1  2  3 0.00074251 0.00074253 1e-04
[1] " "
     Dir D d3 d2 m1 m2 m3      lB      uB   P
[1,]   1 4  3  2  1  2  3 0.14994 0.14994 0.1
[1] " "
     Dir D d3 d2 m1 m2 m3       lB       uB    P
[1,]   1 4  3  2  1  2  3 0.015951 0.015952 0.01
[1] " "
     Dir D d3 d2 m1 m2 m3        lB        uB     P
[1,]   1 4  3  2  1  2  3 0.0023662 0.0023663 0.001
[1] " "
     Dir D d3 d2 m1 m2 m3         lB         uB     P
[1,]   1 4  3  2  1  2  3 0.00069401 0.00069405 1e-04
[1] " "
     Dir D d3 d2 m1 m2 m3      lB      uB   P
[1,]   1 5  3  2  1  2  3 0.14711 0.14711 0.1
[1] " "
     Dir D d3 d2 m1 m2 m3       lB       uB    P
[1,]   1 5  3  2  1  2  3 0.015293 0.015293 0.01
[1] " "
     Dir D d3 d2 m1 m2 m3        lB        uB     P
[1,]   1 5  3  2  1  2  3 0.0022649 0.0022649 0.001
[1] " "
     Dir D d3 d2 m1 m2 m3         lB         uB     P
[1,]   1 5  3  2  1  2  3 0.00066238 0.00066244 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 14
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m1 m2 m3      lB      uB   P
[1,]   1 2  2  1  2  3 0.16149 0.16149 0.1
[1] " "
     Dir D d2 m1 m2 m3       lB       uB    P
[1,]   1 2  2  1  2  3 0.018556 0.018557 0.01
[1] " "
     Dir D d2 m1 m2 m3        lB        uB     P
[1,]   1 2  2  1  2  3 0.0027663 0.0027663 0.001
[1] " "
     Dir D d2 m1 m2 m3         lB         uB     P
[1,]   1 2  2  1  2  3 0.00081738 0.00081742 1e-04
[1] " "
     Dir D d2 m1 m2 m3      lB      uB   P
[1,]   1 3  2  1  2  3 0.15329 0.15329 0.1
[1] " "
     Dir D d2 m1 m2 m3       lB       uB    P
[1,]   1 3  2  1  2  3 0.016779 0.016779 0.01
[1] " "
     Dir D d2 m1 m2 m3        lB        uB     P
[1,]   1 3  2  1  2  3 0.0024923 0.0024926 0.001
[1] " "
     Dir D d2 m1 m2 m3        lB        uB     P
[1,]   1 3  2  1  2  3 0.0007333 0.0007333 1e-04
[1] " "
     Dir D d2 m1 m2 m3      lB      uB   P
[1,]   1 4  2  1  2  3 0.14883 0.14883 0.1
[1] " "
     Dir D d2 m1 m2 m3       lB       uB    P
[1,]   1 4  2  1  2  3 0.015773 0.015773 0.01
[1] " "
     Dir D d2 m1 m2 m3        lB        uB     P
[1,]   1 4  2  1  2  3 0.0023221 0.0023339 0.001
[1] " "
     Dir D d2 m1 m2 m3         lB         uB     P
[1,]   1 4  2  1  2  3 0.00067449 0.00068507 1e-04
[1] " "
     Dir D d2 m1 m2 m3      lB      uB   P
[1,]   1 5  2  1  2  3 0.14087 0.14369 0.1
[1] " "
     Dir D d2 m1 m2 m3       lB       uB    P
[1,]   1 5  2  1  2  3 0.015122 0.015122 0.01
[1] " "
     Dir D d2 m1 m2 m3        lB        uB     P
[1,]   1 5  2  1  2  3 0.0021718 0.0021906 0.001
[1] " "
     Dir D d2 m1 m2 m3         lB         uB     P
[1,]   1 5  2  1  2  3 0.00060626 0.00061397 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 15
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m1 m2 m3      lB      uB   P
[1,]   1 3  3  1  2  3 0.15329 0.15329 0.1
[1] " "
     Dir D d3 m1 m2 m3       lB       uB    P
[1,]   1 3  3  1  2  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 m1 m2 m3        lB       uB     P
[1,]   1 3  3  1  2  3 0.0025039 0.002504 0.001
[1] " "
     Dir D d3 m1 m2 m3         lB         uB     P
[1,]   1 3  3  1  2  3 0.00074082 0.00074084 1e-04
[1] " "
     Dir D d3 m1 m2 m3      lB      uB   P
[1,]   1 4  3  1  2  3 0.14883 0.14883 0.1
[1] " "
     Dir D d3 m1 m2 m3       lB       uB    P
[1,]   1 4  3  1  2  3 0.015773 0.015773 0.01
[1] " "
     Dir D d3 m1 m2 m3        lB        uB     P
[1,]   1 4  3  1  2  3 0.0023473 0.0023475 0.001
[1] " "
     Dir D d3 m1 m2 m3         lB         uB     P
[1,]   1 4  3  1  2  3 0.00069244 0.00069246 1e-04
[1] " "
     Dir D d3 m1 m2 m3      lB      uB   P
[1,]   1 5  3  1  2  3 0.14602 0.14602 0.1
[1] " "
     Dir D d3 m1 m2 m3       lB       uB    P
[1,]   1 5  3  1  2  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 m1 m2 m3        lB        uB     P
[1,]   1 5  3  1  2  3 0.0022376 0.0022447 0.001
[1] " "
     Dir D d3 m1 m2 m3        lB        uB     P
[1,]   1 5  3  1  2  3 0.0006564 0.0006591 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 16
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m1 m2 m3      lB      uB   P
[1,]   1 0  1  2  3 0.35589 0.35589 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 0  1  2  3 0.049958 0.049958 0.01
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 0  1  2  3 0.0074904 0.0074906 0.001
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 0  1  2  3 0.0022226 0.0022227 1e-04
[1] " "
     Dir D m1 m2 m3      lB      uB   P
[1,]   1 1  1  2  3 0.17823 0.17823 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 1  1  2  3 0.021076 0.021077 0.01
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 1  1  2  3 0.0031593 0.0031594 0.001
[1] " "
     Dir D m1 m2 m3         lB         uB     P
[1,]   1 1  1  2  3 0.00093705 0.00093714 1e-04
[1] " "
     Dir D m1 m2 m3      lB      uB   P
[1,]   1 2  1  2  3 0.15842 0.15842 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 2  1  2  3 0.017265 0.017265 0.01
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 2  1  2  3 0.0025835 0.0025852 0.001
[1] " "
     Dir D m1 m2 m3         lB         uB     P
[1,]   1 2  1  2  3 0.00076407 0.00076411 1e-04
[1] " "
     Dir D m1 m2 m3      lB      uB   P
[1,]   1 3  1  2  3 0.15004 0.15038 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 3  1  2  3 0.015611 0.015612 0.01
[1] " "
     Dir D m1 m2 m3        lB       uB     P
[1,]   1 3  1  2  3 0.0022847 0.002316 0.001
[1] " "
     Dir D m1 m2 m3        lB         uB     P
[1,]   1 3  1  2  3 0.0006499 0.00066483 1e-04
[1] " "
     Dir D m1 m2 m3      lB      uB   P
[1,]   1 4  1  2  3 0.13365 0.14546 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 4  1  2  3 0.013471 0.014541 0.01
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 4  1  2  3 0.0018553 0.0020559 0.001
[1] " "
     Dir D m1 m2 m3       lB         uB     P
[1,]   1 4  1  2  3 0.000495 0.00059227 1e-04
[1] " "
     Dir D m1 m2 m3       lB      uB   P
[1,]   1 5  1  2  3 0.071821 0.13868 0.1
[1] " "
     Dir D m1 m2 m3       lB       uB    P
[1,]   1 5  1  2  3 0.013611 0.014054 0.01
[1] " "
     Dir D m1 m2 m3        lB        uB     P
[1,]   1 5  1  2  3 0.0012486 0.0012505 0.001
[1] " "
     Dir D m1 m2 m3         lB         uB     P
[1,]   1 5  1  2  3 0.00018908 0.00049109 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 17
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 3  3  2  1  0  2  3 0.15334 0.15335 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  0  2  3 0.017022 0.017024 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2 m3        lB        uB     P
[1,]   1 3  3  2  1  0  2  3 0.0025408 0.0025409 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2 m3         lB        uB     P
[1,]   1 3  3  2  1  0  2  3 0.00075352 0.0007536 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 4  3  2  1  0  2  3 0.14844 0.14845 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 4  3  2  1  0  2  3 0.016002 0.016003 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2 m3        lB        uB     P
[1,]   1 4  3  2  1  0  2  3 0.0023849 0.0023852 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2 m3        lB         uB     P
[1,]   1 4  3  2  1  0  2  3 0.0007066 0.00070666 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 5  3  2  1  0  2  3 0.14507 0.14508 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 5  3  2  1  0  2  3 0.015341 0.015342 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2 m3       lB        uB     P
[1,]   1 5  3  2  1  0  2  3 0.002284 0.0022841 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2 m3         lB         uB     P
[1,]   1 5  3  2  1  0  2  3 0.00067609 0.00067613 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 18
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 2  2  1  0  2  3 0.15983 0.15983 0.1
[1] " "
     Dir D d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 2  2  1  0  2  3 0.018765 0.018765 0.01
[1] " "
     Dir D d2 d1 m0 m2 m3        lB        uB     P
[1,]   1 2  2  1  0  2  3 0.0028057 0.0028059 0.001
[1] " "
     Dir D d2 d1 m0 m2 m3         lB       uB     P
[1,]   1 2  2  1  0  2  3 0.00083296 0.000833 1e-04
[1] " "
     Dir D d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 3  2  1  0  2  3 0.15138 0.15139 0.1
[1] " "
     Dir D d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 3  2  1  0  2  3 0.016968 0.016968 0.01
[1] " "
     Dir D d2 d1 m0 m2 m3        lB        uB     P
[1,]   1 3  2  1  0  2  3 0.0025324 0.0025326 0.001
[1] " "
     Dir D d2 d1 m0 m2 m3         lB         uB     P
[1,]   1 3  2  1  0  2  3 0.00075102 0.00075106 1e-04
[1] " "
     Dir D d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 4  2  1  0  2  3 0.14635 0.14635 0.1
[1] " "
     Dir D d2 d1 m0 m2 m3      lB      uB    P
[1,]   1 4  2  1  0  2  3 0.01595 0.01595 0.01
[1] " "
     Dir D d2 d1 m0 m2 m3        lB        uB     P
[1,]   1 4  2  1  0  2  3 0.0023644 0.0023701 0.001
[1] " "
     Dir D d2 d1 m0 m2 m3         lB         uB     P
[1,]   1 4  2  1  0  2  3 0.00070085 0.00070373 1e-04
[1] " "
     Dir D d2 d1 m0 m2 m3      lB      uB   P
[1,]   1 5  2  1  0  2  3 0.14298 0.14299 0.1
[1] " "
     Dir D d2 d1 m0 m2 m3       lB       uB    P
[1,]   1 5  2  1  0  2  3 0.015274 0.015281 0.01
[1] " "
     Dir D d2 d1 m0 m2 m3       lB        uB     P
[1,]   1 5  2  1  0  2  3 0.002179 0.0022112 0.001
[1] " "
     Dir D d2 d1 m0 m2 m3         lB        uB     P
[1,]   1 5  2  1  0  2  3 0.00063381 0.0006541 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 19
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m2 m3     lB     uB   P
[1,]   1 3  3  1  0  2  3 0.1512 0.1512 0.1
[1] " "
     Dir D d3 d1 m0 m2 m3       lB       uB    P
[1,]   1 3  3  1  0  2  3 0.016967 0.016969 0.01
[1] " "
     Dir D d3 d1 m0 m2 m3        lB        uB     P
[1,]   1 3  3  1  0  2  3 0.0025324 0.0025325 0.001
[1] " "
     Dir D d3 d1 m0 m2 m3         lB         uB     P
[1,]   1 3  3  1  0  2  3 0.00075104 0.00075111 1e-04
[1] " "
     Dir D d3 d1 m0 m2 m3      lB      uB   P
[1,]   1 4  3  1  0  2  3 0.14632 0.14633 0.1
[1] " "
     Dir D d3 d1 m0 m2 m3      lB       uB    P
[1,]   1 4  3  1  0  2  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d1 m0 m2 m3        lB        uB     P
[1,]   1 4  3  1  0  2  3 0.0023771 0.0023773 0.001
[1] " "
     Dir D d3 d1 m0 m2 m3         lB         uB     P
[1,]   1 4  3  1  0  2  3 0.00070425 0.00070431 1e-04
[1] " "
     Dir D d3 d1 m0 m2 m3      lB      uB   P
[1,]   1 5  3  1  0  2  3 0.14298 0.14299 0.1
[1] " "
     Dir D d3 d1 m0 m2 m3       lB       uB    P
[1,]   1 5  3  1  0  2  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d1 m0 m2 m3        lB        uB     P
[1,]   1 5  3  1  0  2  3 0.0022764 0.0022765 0.001
[1] " "
     Dir D d3 d1 m0 m2 m3         lB         uB     P
[1,]   1 5  3  1  0  2  3 0.00067383 0.00067387 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 20
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m2 m3      lB      uB   P
[1,]   1 1  1  0  2  3 0.17767 0.17769 0.1
[1] " "
     Dir D d1 m0 m2 m3      lB       uB    P
[1,]   1 1  1  0  2  3 0.02265 0.022651 0.01
[1] " "
     Dir D d1 m0 m2 m3        lB        uB     P
[1,]   1 1  1  0  2  3 0.0033935 0.0033936 0.001
[1] " "
     Dir D d1 m0 m2 m3        lB        uB     P
[1,]   1 1  1  0  2  3 0.0010084 0.0010084 1e-04
[1] " "
     Dir D d1 m0 m2 m3      lB      uB   P
[1,]   1 2  1  0  2  3 0.15941 0.15942 0.1
[1] " "
     Dir D d1 m0 m2 m3       lB       uB    P
[1,]   1 2  1  0  2  3 0.018555 0.018556 0.01
[1] " "
     Dir D d1 m0 m2 m3        lB        uB     P
[1,]   1 2  1  0  2  3 0.0027738 0.0027739 0.001
[1] " "
     Dir D d1 m0 m2 m3         lB         uB     P
[1,]   1 2  1  0  2  3 0.00082343 0.00082349 1e-04
[1] " "
     Dir D d1 m0 m2 m3     lB      uB   P
[1,]   1 3  1  0  2  3 0.1507 0.15072 0.1
[1] " "
     Dir D d1 m0 m2 m3       lB       uB    P
[1,]   1 3  1  0  2  3 0.016777 0.016779 0.01
[1] " "
     Dir D d1 m0 m2 m3        lB       uB     P
[1,]   1 3  1  0  2  3 0.0024156 0.002436 0.001
[1] " "
     Dir D d1 m0 m2 m3         lB         uB     P
[1,]   1 3  1  0  2  3 0.00070953 0.00072318 1e-04
[1] " "
     Dir D d1 m0 m2 m3      lB      uB   P
[1,]   1 4  1  0  2  3 0.14283 0.14476 0.1
[1] " "
     Dir D d1 m0 m2 m3       lB       uB    P
[1,]   1 4  1  0  2  3 0.015306 0.015682 0.01
[1] " "
     Dir D d1 m0 m2 m3        lB        uB     P
[1,]   1 4  1  0  2  3 0.0018811 0.0022038 0.001
[1] " "
     Dir D d1 m0 m2 m3         lB         uB     P
[1,]   1 4  1  0  2  3 0.00054055 0.00064986 1e-04
[1] " "
     Dir D d1 m0 m2 m3      lB      uB   P
[1,]   1 5  1  0  2  3 0.12328 0.13887 0.1
[1] " "
     Dir D d1 m0 m2 m3       lB       uB    P
[1,]   1 5  1  0  2  3 0.014939 0.015056 0.01
[1] " "
     Dir D d1 m0 m2 m3         lB        uB     P
[1,]   1 5  1  0  2  3 0.00080798 0.0018978 0.001
[1] " "
     Dir D d1 m0 m2 m3         lB         uB     P
[1,]   1 5  1  0  2  3 0.00018864 0.00054609 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 21
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m2 m3      lB     uB   P
[1,]   1 3  3  2  0  2  3 0.15149 0.1515 0.1
[1] " "
     Dir D d3 d2 m0 m2 m3       lB       uB    P
[1,]   1 3  3  2  0  2  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 d2 m0 m2 m3       lB        uB     P
[1,]   1 3  3  2  0  2  3 0.002538 0.0025381 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d2 m0 m2 m3         lB         uB     P
[1,]   1 3  3  2  0  2  3 0.00075373 0.00075398 1e-04
[1] " "
     Dir D d3 d2 m0 m2 m3      lB      uB   P
[1,]   1 4  3  2  0  2  3 0.14636 0.14637 0.1
[1] " "
     Dir D d3 d2 m0 m2 m3      lB       uB    P
[1,]   1 4  3  2  0  2  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d2 m0 m2 m3       lB        uB     P
[1,]   1 4  3  2  0  2  3 0.002382 0.0023822 0.001
[1] " "
     Dir D d3 d2 m0 m2 m3         lB         uB     P
[1,]   1 4  3  2  0  2  3 0.00070702 0.00070704 1e-04
[1] " "
     Dir D d3 d2 m0 m2 m3      lB      uB   P
[1,]   1 5  3  2  0  2  3 0.14298 0.14299 0.1
[1] " "
     Dir D d3 d2 m0 m2 m3       lB       uB    P
[1,]   1 5  3  2  0  2  3 0.015293 0.015293 0.01
[1] " "
     Dir D d3 d2 m0 m2 m3        lB        uB     P
[1,]   1 5  3  2  0  2  3 0.0022794 0.0022795 0.001
[1] " "
     Dir D d3 d2 m0 m2 m3         lB         uB     P
[1,]   1 5  3  2  0  2  3 0.00067639 0.00067643 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 22
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m2 m3      lB      uB   P
[1,]   1 2  2  0  2  3 0.15941 0.15943 0.1
[1] " "
     Dir D d2 m0 m2 m3       lB       uB    P
[1,]   1 2  2  0  2  3 0.018554 0.018555 0.01
[1] " "
     Dir D d2 m0 m2 m3        lB        uB     P
[1,]   1 2  2  0  2  3 0.0027797 0.0027799 0.001
[1] " "
     Dir D d2 m0 m2 m3         lB         uB     P
[1,]   1 2  2  0  2  3 0.00082595 0.00082603 1e-04
[1] " "
     Dir D d2 m0 m2 m3      lB      uB   P
[1,]   1 3  2  0  2  3 0.15071 0.15072 0.1
[1] " "
     Dir D d2 m0 m2 m3       lB       uB    P
[1,]   1 3  2  0  2  3 0.016777 0.016779 0.01
[1] " "
     Dir D d2 m0 m2 m3        lB        uB     P
[1,]   1 3  2  0  2  3 0.0025089 0.0025091 0.001
[1] " "
     Dir D d2 m0 m2 m3        lB         uB     P
[1,]   1 3  2  0  2  3 0.0007451 0.00074515 1e-04
[1] " "
     Dir D d2 m0 m2 m3     lB      uB   P
[1,]   1 4  2  0  2  3 0.1456 0.14561 0.1
[1] " "
     Dir D d2 m0 m2 m3       lB       uB    P
[1,]   1 4  2  0  2  3 0.015772 0.015773 0.01
[1] " "
     Dir D d2 m0 m2 m3        lB       uB     P
[1,]   1 4  2  0  2  3 0.0023344 0.002338 0.001
[1] " "
     Dir D d2 m0 m2 m3         lB         uB     P
[1,]   1 4  2  0  2  3 0.00069153 0.00069403 1e-04
[1] " "
     Dir D d2 m0 m2 m3      lB      uB   P
[1,]   1 5  2  0  2  3 0.14224 0.14225 0.1
[1] " "
     Dir D d2 m0 m2 m3       lB       uB    P
[1,]   1 5  2  0  2  3 0.015122 0.015122 0.01
[1] " "
     Dir D d2 m0 m2 m3        lB       uB     P
[1,]   1 5  2  0  2  3 0.0020621 0.002173 0.001
[1] " "
     Dir D d2 m0 m2 m3         lB         uB     P
[1,]   1 5  2  0  2  3 0.00059106 0.00063999 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 23
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m2 m3      lB      uB   P
[1,]   1 3  3  0  2  3 0.15071 0.15072 0.1
[1] " "
     Dir D d3 m0 m2 m3       lB       uB    P
[1,]   1 3  3  0  2  3 0.016778 0.016779 0.01
[1] " "
     Dir D d3 m0 m2 m3        lB       uB     P
[1,]   1 3  3  0  2  3 0.0025139 0.002514 0.001
[1] " "
     Dir D d3 m0 m2 m3         lB         uB     P
[1,]   1 3  3  0  2  3 0.00074704 0.00074707 1e-04
[1] " "
     Dir D d3 m0 m2 m3     lB      uB   P
[1,]   1 4  3  0  2  3 0.1456 0.14561 0.1
[1] " "
     Dir D d3 m0 m2 m3       lB       uB    P
[1,]   1 4  3  0  2  3 0.015772 0.015773 0.01
[1] " "
     Dir D d3 m0 m2 m3        lB        uB     P
[1,]   1 4  3  0  2  3 0.0023601 0.0023602 0.001
[1] " "
     Dir D d3 m0 m2 m3         lB         uB     P
[1,]   1 4  3  0  2  3 0.00070111 0.00070111 1e-04
[1] " "
     Dir D d3 m0 m2 m3      lB      uB   P
[1,]   1 5  3  0  2  3 0.14224 0.14225 0.1
[1] " "
     Dir D d3 m0 m2 m3       lB       uB    P
[1,]   1 5  3  0  2  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 m0 m2 m3        lB        uB     P
[1,]   1 5  3  0  2  3 0.0022534 0.0022569 0.001
[1] " "
     Dir D d3 m0 m2 m3         lB         uB     P
[1,]   1 5  3  0  2  3 0.00066853 0.00067018 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 24
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m2 m3      lB      uB   P
[1,]   1 0  0  2  3 0.23957 0.23957 0.1
[1] " "
     Dir D m0 m2 m3       lB       uB    P
[1,]   1 0  0  2  3 0.049958 0.049958 0.01
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 0  0  2  3 0.0074931 0.0074931 0.001
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 0  0  2  3 0.0022175 0.0022177 1e-04
[1] " "
     Dir D m0 m2 m3      lB      uB   P
[1,]   1 1  0  2  3 0.17533 0.17534 0.1
[1] " "
     Dir D m0 m2 m3       lB       uB    P
[1,]   1 1  0  2  3 0.021076 0.021076 0.01
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 1  0  2  3 0.0031612 0.0031612 0.001
[1] " "
     Dir D m0 m2 m3         lB         uB     P
[1,]   1 1  0  2  3 0.00093444 0.00093446 1e-04
[1] " "
     Dir D m0 m2 m3       lB     uB   P
[1,]   1 2  0  2  3 0.089516 0.1139 0.1
[1] " "
     Dir D m0 m2 m3       lB       uB    P
[1,]   1 2  0  2  3 0.017265 0.017265 0.01
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 2  0  2  3 0.0025896 0.0025896 0.001
[1] " "
     Dir D m0 m2 m3         lB       uB     P
[1,]   1 2  0  2  3 0.00076331 0.000764 1e-04
[1] " "
     Dir D m0 m2 m3       lB       uB   P
[1,]   1 3  0  2  3 0.033846 0.073002 0.1
[1] " "
     Dir D m0 m2 m3       lB       uB    P
[1,]   1 3  0  2  3 0.011505 0.014337 0.01
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 3  0  2  3 0.0023416 0.0023416 0.001
[1] " "
     Dir D m0 m2 m3         lB         uB     P
[1,]   1 3  0  2  3 0.00068548 0.00068879 1e-04
[1] " "
     Dir D m0 m2 m3       lB       uB   P
[1,]   1 4  0  2  3 0.019833 0.097713 0.1
[1] " "
     Dir D m0 m2 m3        lB       uB    P
[1,]   1 4  0  2  3 0.0075816 0.011416 0.01
[1] " "
     Dir D m0 m2 m3        lB       uB     P
[1,]   1 4  0  2  3 0.0021913 0.002201 0.001
[1] " "
     Dir D m0 m2 m3         lB         uB     P
[1,]   1 4  0  2  3 0.00063565 0.00063823 1e-04
[1] " "
     Dir D m0 m2 m3       lB      uB   P
[1,]   1 5  0  2  3 0.022625 0.12525 0.1
[1] " "
     Dir D m0 m2 m3        lB      uB    P
[1,]   1 5  0  2  3 0.0083809 0.01224 0.01
[1] " "
     Dir D m0 m2 m3        lB        uB     P
[1,]   1 5  0  2  3 0.0020837 0.0021099 0.001
[1] " "
     Dir D m0 m2 m3         lB         uB     P
[1,]   1 5  0  2  3 0.00045331 0.00049151 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 25
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m2 m3      lB     uB   P
[1,]   1 3  3  2  1  2  3 0.23028 0.2303 0.1
[1] " "
     Dir D d3 d2 d1 m2 m3       lB       uB    P
[1,]   1 3  3  2  1  2  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 d2 d1 m2 m3        lB        uB     P
[1,]   1 3  3  2  1  2  3 0.0025449 0.0025451 0.001
[1] " "
     Dir D d3 d2 d1 m2 m3         lB         uB     P
[1,]   1 3  3  2  1  2  3 0.00075644 0.00075648 1e-04
[1] " "
     Dir D d3 d2 d1 m2 m3      lB      uB   P
[1,]   1 4  3  2  1  2  3 0.21287 0.21289 0.1
[1] " "
     Dir D d3 d2 d1 m2 m3      lB       uB    P
[1,]   1 4  3  2  1  2  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d2 d1 m2 m3        lB        uB     P
[1,]   1 4  3  2  1  2  3 0.0023922 0.0023923 0.001
[1] " "
     Dir D d3 d2 d1 m2 m3         lB         uB     P
[1,]   1 4  3  2  1  2  3 0.00071105 0.00071107 1e-04
[1] " "
     Dir D d3 d2 d1 m2 m3      lB      uB   P
[1,]   1 5  3  2  1  2  3 0.20221 0.20222 0.1
[1] " "
     Dir D d3 d2 d1 m2 m3       lB       uB    P
[1,]   1 5  3  2  1  2  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d2 d1 m2 m3        lB        uB     P
[1,]   1 5  3  2  1  2  3 0.0022926 0.0022928 0.001
[1] " "
     Dir D d3 d2 d1 m2 m3         lB        uB     P
[1,]   1 5  3  2  1  2  3 0.00068141 0.0006815 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 26
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m2 m3      lB      uB   P
[1,]   1 2  2  1  2  3 0.26227 0.26229 0.1
[1] " "
     Dir D d2 d1 m2 m3       lB       uB    P
[1,]   1 2  2  1  2  3 0.018555 0.018557 0.01
[1] " "
     Dir D d2 d1 m2 m3        lB        uB     P
[1,]   1 2  2  1  2  3 0.0027832 0.0027832 0.001
[1] " "
     Dir D d2 d1 m2 m3         lB         uB     P
[1,]   1 2  2  1  2  3 0.00082671 0.00082674 1e-04
[1] " "
     Dir D d2 d1 m2 m3      lB      uB   P
[1,]   1 3  2  1  2  3 0.22891 0.22892 0.1
[1] " "
     Dir D d2 d1 m2 m3       lB       uB    P
[1,]   1 3  2  1  2  3 0.016778 0.016779 0.01
[1] " "
     Dir D d2 d1 m2 m3        lB        uB     P
[1,]   1 3  2  1  2  3 0.0025166 0.0025166 0.001
[1] " "
     Dir D d2 d1 m2 m3         lB         uB     P
[1,]   1 3  2  1  2  3 0.00074746 0.00074752 1e-04
[1] " "
     Dir D d2 d1 m2 m3      lB      uB   P
[1,]   1 4  2  1  2  3 0.21159 0.21161 0.1
[1] " "
     Dir D d2 d1 m2 m3       lB       uB    P
[1,]   1 4  2  1  2  3 0.015772 0.015772 0.01
[1] " "
     Dir D d2 d1 m2 m3        lB        uB     P
[1,]   1 4  2  1  2  3 0.0023642 0.0023647 0.001
[1] " "
     Dir D d2 d1 m2 m3         lB         uB     P
[1,]   1 4  2  1  2  3 0.00070259 0.00070261 1e-04
[1] " "
     Dir D d2 d1 m2 m3      lB      uB   P
[1,]   1 5  2  1  2  3 0.18168 0.19714 0.1
[1] " "
     Dir D d2 d1 m2 m3     lB      uB    P
[1,]   1 5  2  1  2  3 0.0151 0.01511 0.01
[1] " "
     Dir D d2 d1 m2 m3        lB        uB     P
[1,]   1 5  2  1  2  3 0.0020955 0.0022072 0.001
[1] " "
     Dir D d2 d1 m2 m3         lB         uB     P
[1,]   1 5  2  1  2  3 0.00060949 0.00065537 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 27
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m2 m3      lB      uB   P
[1,]   1 3  3  1  2  3 0.22891 0.22893 0.1
[1] " "
     Dir D d3 d1 m2 m3       lB       uB    P
[1,]   1 3  3  1  2  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 d1 m2 m3        lB        uB     P
[1,]   1 3  3  1  2  3 0.0025165 0.0025166 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d1 m2 m3         lB         uB     P
[1,]   1 3  3  1  2  3 0.00074737 0.00074824 1e-04
[1] " "
     Dir D d3 d1 m2 m3     lB      uB   P
[1,]   1 4  3  1  2  3 0.2116 0.21162 0.1
[1] " "
     Dir D d3 d1 m2 m3       lB       uB    P
[1,]   1 4  3  1  2  3 0.015772 0.015773 0.01
[1] " "
     Dir D d3 d1 m2 m3        lB        uB     P
[1,]   1 4  3  1  2  3 0.0023655 0.0023656 0.001
[1] " "
     Dir D d3 d1 m2 m3         lB         uB     P
[1,]   1 4  3  1  2  3 0.00070262 0.00070266 1e-04
[1] " "
     Dir D d3 d1 m2 m3    lB      uB   P
[1,]   1 5  3  1  2  3 0.201 0.20101 0.1
[1] " "
     Dir D d3 d1 m2 m3      lB       uB    P
[1,]   1 5  3  1  2  3 0.01512 0.015121 0.01
[1] " "
     Dir D d3 d1 m2 m3        lB        uB     P
[1,]   1 5  3  1  2  3 0.0022669 0.0022672 0.001
[1] " "
     Dir D d3 d1 m2 m3        lB         uB     P
[1,]   1 5  3  1  2  3 0.0006736 0.00067363 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 28
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m2 m3      lB      uB   P
[1,]   1 1  1  2  3 0.35108 0.35112 0.1
[1] " "
     Dir D d1 m2 m3       lB       uB    P
[1,]   1 1  1  2  3 0.021076 0.021076 0.01
[1] " "
     Dir D d1 m2 m3        lB        uB     P
[1,]   1 1  1  2  3 0.0031612 0.0031612 0.001
[1] " "
     Dir D d1 m2 m3         lB         uB     P
[1,]   1 1  1  2  3 0.00093403 0.00093412 1e-04
[1] " "
     Dir D d1 m2 m3      lB      uB   P
[1,]   1 2  1  2  3 0.25989 0.25991 0.1
[1] " "
     Dir D d1 m2 m3       lB       uB    P
[1,]   1 2  1  2  3 0.017265 0.017266 0.01
[1] " "
     Dir D d1 m2 m3        lB        uB     P
[1,]   1 2  1  2  3 0.0025896 0.0025896 0.001
[1] " "
     Dir D d1 m2 m3         lB         uB     P
[1,]   1 2  1  2  3 0.00076404 0.00076411 1e-04
[1] " "
     Dir D d1 m2 m3      lB      uB   P
[1,]   1 3  1  2  3 0.18213 0.21904 0.1
[1] " "
     Dir D d1 m2 m3       lB       uB    P
[1,]   1 3  1  2  3 0.015611 0.015613 0.01
[1] " "
     Dir D d1 m2 m3        lB        uB     P
[1,]   1 3  1  2  3 0.0023416 0.0023418 0.001
[1] " "
     Dir D d1 m2 m3         lB        uB     P
[1,]   1 3  1  2  3 0.00068904 0.0006902 1e-04
[1] " "
     Dir D d1 m2 m3      lB      uB   P
[1,]   1 4  1  2  3 0.08306 0.10143 0.1
[1] " "
     Dir D d1 m2 m3      lB       uB    P
[1,]   1 4  1  2  3 0.01463 0.014664 0.01
[1] " "
     Dir D d1 m2 m3        lB        uB     P
[1,]   1 4  1  2  3 0.0022011 0.0022013 0.001
[1] " "
     Dir D d1 m2 m3         lB         uB     P
[1,]   1 4  1  2  3 0.00064424 0.00064429 1e-04
[1] " "
     Dir D d1 m2 m3      lB      uB   P
[1,]   1 5  1  2  3 0.03081 0.07228 0.1
[1] " "
     Dir D d1 m2 m3       lB       uB    P
[1,]   1 5  1  2  3 0.010122 0.010867 0.01
[1] " "
     Dir D d1 m2 m3        lB        uB     P
[1,]   1 5  1  2  3 0.0021103 0.0021103 0.001
[1] " "
     Dir D d1 m2 m3         lB         uB     P
[1,]   1 5  1  2  3 0.00061298 0.00061361 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 29
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m2 m3      lB      uB   P
[1,]   1 3  3  2  2  3 0.34009 0.34011 0.1
[1] " "
     Dir D d3 d2 m2 m3       lB       uB    P
[1,]   1 3  3  2  2  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 d2 m2 m3        lB        uB     P
[1,]   1 3  3  2  2  3 0.0025167 0.0025169 0.001
[1] " "
     Dir D d3 d2 m2 m3         lB         uB     P
[1,]   1 3  3  2  2  3 0.00074747 0.00074754 1e-04
[1] " "
     Dir D d3 d2 m2 m3      lB     uB   P
[1,]   1 4  3  2  2  3 0.30429 0.3043 0.1
[1] " "
     Dir D d3 d2 m2 m3       lB       uB    P
[1,]   1 4  3  2  2  3 0.015773 0.015773 0.01
[1] " "
     Dir D d3 d2 m2 m3        lB        uB     P
[1,]   1 4  3  2  2  3 0.0023657 0.0023658 0.001
[1] " "
     Dir D d3 d2 m2 m3         lB         uB     P
[1,]   1 4  3  2  2  3 0.00070261 0.00070264 1e-04
[1] " "
     Dir D d3 d2 m2 m3      lB      uB   P
[1,]   1 5  3  2  2  3 0.28287 0.28288 0.1
[1] " "
     Dir D d3 d2 m2 m3       lB       uB    P
[1,]   1 5  3  2  2  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 d2 m2 m3        lB        uB     P
[1,]   1 5  3  2  2  3 0.0022681 0.0022681 0.001
[1] " "
     Dir D d3 d2 m2 m3         lB         uB     P
[1,]   1 5  3  2  2  3 0.00067353 0.00067357 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 30
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m2 m3      lB      uB   P
[1,]   1 2  2  2  3 0.37541 0.37544 0.1
[1] " "
     Dir D d2 m2 m3       lB       uB    P
[1,]   1 2  2  2  3 0.017265 0.017265 0.01
[1] " "
     Dir D d2 m2 m3        lB        uB     P
[1,]   1 2  2  2  3 0.0025896 0.0025896 0.001
[1] " "
     Dir D d2 m2 m3         lB         uB     P
[1,]   1 2  2  2  3 0.00076513 0.00076515 1e-04
[1] " "
     Dir D d2 m2 m3      lB      uB   P
[1,]   1 3  2  2  3 0.33631 0.33631 0.1
[1] " "
     Dir D d2 m2 m3       lB       uB    P
[1,]   1 3  2  2  3 0.015612 0.015612 0.01
[1] " "
     Dir D d2 m2 m3        lB        uB     P
[1,]   1 3  2  2  3 0.0023416 0.0023416 0.001
[1] " "
     Dir D d2 m2 m3         lB         uB     P
[1,]   1 3  2  2  3 0.00069089 0.00069091 1e-04
[1] " "
     Dir D d2 m2 m3      lB      uB   P
[1,]   1 4  2  2  3 0.25819 0.29646 0.1
[1] " "
     Dir D d2 m2 m3       lB       uB    P
[1,]   1 4  2  2  3 0.014675 0.014675 0.01
[1] " "
     Dir D d2 m2 m3        lB        uB     P
[1,]   1 4  2  2  3 0.0022011 0.0022012 0.001
[1] " "
     Dir D d2 m2 m3         lB         uB     P
[1,]   1 4  2  2  3 0.00064797 0.00064827 1e-04
[1] " "
     Dir D d2 m2 m3      lB      uB   P
[1,]   1 5  2  2  3 0.17835 0.21145 0.1
[1] " "
     Dir D d2 m2 m3       lB      uB    P
[1,]   1 5  2  2  3 0.014069 0.01407 0.01
[1] " "
     Dir D d2 m2 m3        lB        uB     P
[1,]   1 5  2  2  3 0.0021103 0.0021103 0.001
[1] " "
     Dir D d2 m2 m3         lB         uB     P
[1,]   1 5  2  2  3 0.00061905 0.00061972 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 31
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m2 m3      lB      uB   P
[1,]   1 3  3  2  3 0.34302 0.34304 0.1
[1] " "
     Dir D d3 m2 m3       lB       uB    P
[1,]   1 3  3  2  3 0.015612 0.015612 0.01
[1] " "
     Dir D d3 m2 m3        lB        uB     P
[1,]   1 3  3  2  3 0.0023416 0.0023416 0.001
[1] " "
     Dir D d3 m2 m3         lB         uB     P
[1,]   1 3  3  2  3 0.00069192 0.00069196 1e-04
[1] " "
     Dir D d3 m2 m3      lB      uB   P
[1,]   1 4  3  2  3 0.32503 0.32506 0.1
[1] " "
     Dir D d3 m2 m3       lB       uB    P
[1,]   1 4  3  2  3 0.014675 0.014675 0.01
[1] " "
     Dir D d3 m2 m3        lB        uB     P
[1,]   1 4  3  2  3 0.0022011 0.0022011 0.001
[1] " "
     Dir D d3 m2 m3         lB         uB     P
[1,]   1 4  3  2  3 0.00064961 0.00064962 1e-04
[1] " "
     Dir D d3 m2 m3      lB      uB   P
[1,]   1 5  3  2  3 0.31346 0.31346 0.1
[1] " "
     Dir D d3 m2 m3      lB      uB    P
[1,]   1 5  3  2  3 0.01407 0.01407 0.01
[1] " "
     Dir D d3 m2 m3        lB        uB     P
[1,]   1 5  3  2  3 0.0021103 0.0021103 0.001
[1] " "
     Dir D d3 m2 m3         lB         uB     P
[1,]   1 5  3  2  3 0.00062172 0.00062213 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 32
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m2 m3 lB uB   P
[1,]   1 0  2  3  1  1 0.1
[1] " "
     Dir D m2 m3       lB       uB    P
[1,]   1 0  2  3 0.049106 0.049106 0.01
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 0  2  3 0.0073654 0.0073654 0.001
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 0  2  3 0.0021807 0.0021809 1e-04
[1] " "
     Dir D m2 m3      lB      uB   P
[1,]   1 1  2  3 0.43681 0.43684 0.1
[1] " "
     Dir D m2 m3       lB       uB    P
[1,]   1 1  2  3 0.020717 0.020717 0.01
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 1  2  3 0.0031073 0.0031073 0.001
[1] " "
     Dir D m2 m3         lB         uB     P
[1,]   1 1  2  3 0.00091894 0.00091902 1e-04
[1] " "
     Dir D m2 m3      lB     uB   P
[1,]   1 2  2  3 0.25822 0.2657 0.1
[1] " "
     Dir D m2 m3       lB       uB    P
[1,]   1 2  2  3 0.016971 0.016971 0.01
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 2  2  3 0.0025455 0.0025455 0.001
[1] " "
     Dir D m2 m3         lB         uB     P
[1,]   1 2  2  3 0.00075073 0.00075136 1e-04
[1] " "
     Dir D m2 m3     lB      uB   P
[1,]   1 3  2  3 0.1141 0.19849 0.1
[1] " "
     Dir D m2 m3       lB       uB    P
[1,]   1 3  2  3 0.015345 0.015346 0.01
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 3  2  3 0.0023017 0.0023017 0.001
[1] " "
     Dir D m2 m3         lB         uB     P
[1,]   1 3  2  3 0.00067408 0.00067693 1e-04
[1] " "
     Dir D m2 m3       lB       uB   P
[1,]   1 4  2  3 0.037501 0.096047 0.1
[1] " "
     Dir D m2 m3       lB       uB    P
[1,]   1 4  2  3 0.010665 0.011221 0.01
[1] " "
     Dir D m2 m3        lB        uB     P
[1,]   1 4  2  3 0.0021636 0.0021636 0.001
[1] " "
     Dir D m2 m3        lB         uB     P
[1,]   1 4  2  3 0.0006233 0.00062378 1e-04
[1] " "
     Dir D m2 m3       lB      uB   P
[1,]   1 5  2  3 0.025464 0.11846 0.1
[1] " "
     Dir D m2 m3        lB       uB    P
[1,]   1 5  2  3 0.0086161 0.012031 0.01
[1] " "
     Dir D m2 m3        lB       uB     P
[1,]   1 5  2  3 0.0020567 0.002074 0.001
[1] " "
     Dir D m2 m3         lB         uB     P
[1,]   1 5  2  3 0.00056177 0.00056626 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 33
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m1 m3      lB      uB   P
[1,]   1 3  3  2  1  0  1  3 0.14177 0.14177 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 3  3  2  1  0  1  3 0.017022 0.017024 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 3  3  2  1  0  1  3 0.0025211 0.0025212 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 3  3  2  1  0  1  3 0.00073505 0.00073512 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m3     lB      uB   P
[1,]   1 4  3  2  1  0  1  3 0.1382 0.13821 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 4  3  2  1  0  1  3 0.016002 0.016003 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 4  3  2  1  0  1  3 0.0023663 0.0023663 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 4  3  2  1  0  1  3 0.00068705 0.00068709 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m3      lB      uB   P
[1,]   1 5  3  2  1  0  1  3 0.13593 0.13594 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 5  3  2  1  0  1  3 0.015341 0.015342 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 5  3  2  1  0  1  3 0.0022662 0.0022663 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 5  3  2  1  0  1  3 0.00065583 0.00065589 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 34
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m1 m3      lB      uB   P
[1,]   1 2  2  1  0  1  3 0.14757 0.14757 0.1
[1] " "
     Dir D d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 2  2  1  0  1  3 0.018765 0.018765 0.01
[1] " "
     Dir D d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 2  2  1  0  1  3 0.0027843 0.0027846 0.001
[1] " "
     Dir D d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 2  2  1  0  1  3 0.00081583 0.00081591 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m3     lB      uB   P
[1,]   1 3  2  1  0  1  3 0.1412 0.14121 0.1
[1] " "
     Dir D d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 3  2  1  0  1  3 0.016968 0.016968 0.01
[1] " "
     Dir D d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 3  2  1  0  1  3 0.0025112 0.0025113 0.001
[1] " "
     Dir D d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 3  2  1  0  1  3 0.00073187 0.00073192 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m3      lB      uB   P
[1,]   1 4  2  1  0  1  3 0.13766 0.13766 0.1
[1] " "
     Dir D d2 d1 m0 m1 m3       lB      uB    P
[1,]   1 4  2  1  0  1  3 0.015949 0.01595 0.01
[1] " "
     Dir D d2 d1 m0 m1 m3        lB       uB     P
[1,]   1 4  2  1  0  1  3 0.0023558 0.002356 0.001
[1] " "
     Dir D d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 4  2  1  0  1  3 0.00068391 0.00068396 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m3     lB     uB   P
[1,]   1 5  2  1  0  1  3 0.1354 0.1354 0.1
[1] " "
     Dir D d2 d1 m0 m1 m3       lB       uB    P
[1,]   1 5  2  1  0  1  3 0.015275 0.015281 0.01
[1] " "
     Dir D d2 d1 m0 m1 m3        lB        uB     P
[1,]   1 5  2  1  0  1  3 0.0021677 0.0022206 0.001
[1] " "
     Dir D d2 d1 m0 m1 m3         lB         uB     P
[1,]   1 5  2  1  0  1  3 0.00063381 0.00064664 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 35
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m1 m3     lB      uB   P
[1,]   1 3  3  1  0  1  3 0.1412 0.14121 0.1
[1] " "
     Dir D d3 d1 m0 m1 m3       lB       uB    P
[1,]   1 3  3  1  0  1  3 0.016967 0.016969 0.01
[1] " "
     Dir D d3 d1 m0 m1 m3        lB        uB     P
[1,]   1 3  3  1  0  1  3 0.0025112 0.0025113 0.001
[1] " "
     Dir D d3 d1 m0 m1 m3         lB         uB     P
[1,]   1 3  3  1  0  1  3 0.00073189 0.00073193 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m3      lB      uB   P
[1,]   1 4  3  1  0  1  3 0.13766 0.13767 0.1
[1] " "
     Dir D d3 d1 m0 m1 m3      lB       uB    P
[1,]   1 4  3  1  0  1  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d1 m0 m1 m3        lB        uB     P
[1,]   1 4  3  1  0  1  3 0.0023567 0.0023568 0.001
[1] " "
     Dir D d3 d1 m0 m1 m3         lB         uB     P
[1,]   1 4  3  1  0  1  3 0.00068395 0.00068398 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m3     lB      uB   P
[1,]   1 5  3  1  0  1  3 0.1354 0.13541 0.1
[1] " "
     Dir D d3 d1 m0 m1 m3       lB       uB    P
[1,]   1 5  3  1  0  1  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d1 m0 m1 m3        lB       uB     P
[1,]   1 5  3  1  0  1  3 0.0022568 0.002257 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d1 m0 m1 m3         lB         uB     P
[1,]   1 5  3  1  0  1  3 0.00065277 0.00065285 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 36
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m1 m3      lB      uB   P
[1,]   1 1  1  0  1  3 0.16171 0.16172 0.1
[1] " "
     Dir D d1 m0 m1 m3       lB       uB    P
[1,]   1 1  1  0  1  3 0.022649 0.022651 0.01
[1] " "
     Dir D d1 m0 m1 m3        lB       uB     P
[1,]   1 1  1  0  1  3 0.0033728 0.003373 0.001
[1] " "
     Dir D d1 m0 m1 m3        lB         uB     P
[1,]   1 1  1  0  1  3 0.0009903 0.00099039 1e-04
[1] " "
     Dir D d1 m0 m1 m3      lB      uB   P
[1,]   1 2  1  0  1  3 0.14671 0.14671 0.1
[1] " "
     Dir D d1 m0 m1 m3       lB       uB    P
[1,]   1 2  1  0  1  3 0.018555 0.018556 0.01
[1] " "
     Dir D d1 m0 m1 m3        lB        uB     P
[1,]   1 2  1  0  1  3 0.0027505 0.0027505 0.001
[1] " "
     Dir D d1 m0 m1 m3         lB        uB     P
[1,]   1 2  1  0  1  3 0.00080555 0.0008056 1e-04
[1] " "
     Dir D d1 m0 m1 m3      lB      uB   P
[1,]   1 3  1  0  1  3 0.14034 0.14034 0.1
[1] " "
     Dir D d1 m0 m1 m3       lB       uB    P
[1,]   1 3  1  0  1  3 0.016777 0.016779 0.01
[1] " "
     Dir D d1 m0 m1 m3        lB        uB     P
[1,]   1 3  1  0  1  3 0.0024174 0.0024387 0.001
[1] " "
     Dir D d1 m0 m1 m3         lB         uB     P
[1,]   1 3  1  0  1  3 0.00070951 0.00071561 1e-04
[1] " "
     Dir D d1 m0 m1 m3      lB      uB   P
[1,]   1 4  1  0  1  3 0.13636 0.13648 0.1
[1] " "
     Dir D d1 m0 m1 m3       lB       uB    P
[1,]   1 4  1  0  1  3 0.015636 0.015719 0.01
[1] " "
     Dir D d1 m0 m1 m3        lB        uB     P
[1,]   1 4  1  0  1  3 0.0018811 0.0022038 0.001
[1] " "
     Dir D d1 m0 m1 m3         lB         uB     P
[1,]   1 4  1  0  1  3 0.00054055 0.00064828 1e-04
[1] " "
     Dir D d1 m0 m1 m3      lB      uB   P
[1,]   1 5  1  0  1  3 0.12381 0.13266 0.1
[1] " "
     Dir D d1 m0 m1 m3       lB       uB    P
[1,]   1 5  1  0  1  3 0.014978 0.015121 0.01
[1] " "
     Dir D d1 m0 m1 m3         lB        uB     P
[1,]   1 5  1  0  1  3 0.00080763 0.0019033 0.001
[1] " "
     Dir D d1 m0 m1 m3         lB         uB     P
[1,]   1 5  1  0  1  3 0.00018864 0.00054609 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 37
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m1 m3     lB      uB   P
[1,]   1 3  3  2  0  1  3 0.1412 0.14121 0.1
[1] " "
     Dir D d3 d2 m0 m1 m3       lB       uB    P
[1,]   1 3  3  2  0  1  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 d2 m0 m1 m3        lB        uB     P
[1,]   1 3  3  2  0  1  3 0.0025228 0.0025229 0.001
[1] " "
     Dir D d3 d2 m0 m1 m3         lB         uB     P
[1,]   1 3  3  2  0  1  3 0.00073615 0.00073621 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m3      lB      uB   P
[1,]   1 4  3  2  0  1  3 0.13766 0.13766 0.1
[1] " "
     Dir D d3 d2 m0 m1 m3      lB       uB    P
[1,]   1 4  3  2  0  1  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d2 m0 m1 m3        lB        uB     P
[1,]   1 4  3  2  0  1  3 0.0023662 0.0023663 0.001
[1] " "
     Dir D d3 d2 m0 m1 m3         lB         uB     P
[1,]   1 4  3  2  0  1  3 0.00069018 0.00069021 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m3     lB      uB   P
[1,]   1 5  3  2  0  1  3 0.1354 0.13541 0.1
[1] " "
     Dir D d3 d2 m0 m1 m3       lB       uB    P
[1,]   1 5  3  2  0  1  3 0.015293 0.015293 0.01
[1] " "
     Dir D d3 d2 m0 m1 m3        lB        uB     P
[1,]   1 5  3  2  0  1  3 0.0022647 0.0022648 0.001
[1] " "
     Dir D d3 d2 m0 m1 m3         lB         uB     P
[1,]   1 5  3  2  0  1  3 0.00066038 0.00066044 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 38
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m1 m3      lB      uB   P
[1,]   1 2  2  0  1  3 0.14671 0.14672 0.1
[1] " "
     Dir D d2 m0 m1 m3       lB       uB    P
[1,]   1 2  2  0  1  3 0.018554 0.018555 0.01
[1] " "
     Dir D d2 m0 m1 m3        lB        uB     P
[1,]   1 2  2  0  1  3 0.0027602 0.0027603 0.001
[1] " "
     Dir D d2 m0 m1 m3         lB         uB     P
[1,]   1 2  2  0  1  3 0.00080643 0.00080647 1e-04
[1] " "
     Dir D d2 m0 m1 m3      lB      uB   P
[1,]   1 3  2  0  1  3 0.14034 0.14034 0.1
[1] " "
     Dir D d2 m0 m1 m3       lB       uB    P
[1,]   1 3  2  0  1  3 0.016778 0.016779 0.01
[1] " "
     Dir D d2 m0 m1 m3        lB        uB     P
[1,]   1 3  2  0  1  3 0.0024924 0.0024926 0.001
[1] " "
     Dir D d2 m0 m1 m3         lB         uB     P
[1,]   1 3  2  0  1  3 0.00072624 0.00072627 1e-04
[1] " "
     Dir D d2 m0 m1 m3     lB      uB   P
[1,]   1 4  2  0  1  3 0.1368 0.13681 0.1
[1] " "
     Dir D d2 m0 m1 m3       lB       uB    P
[1,]   1 4  2  0  1  3 0.015772 0.015772 0.01
[1] " "
     Dir D d2 m0 m1 m3        lB        uB     P
[1,]   1 4  2  0  1  3 0.0023345 0.0023349 0.001
[1] " "
     Dir D d2 m0 m1 m3         lB         uB     P
[1,]   1 4  2  0  1  3 0.00067573 0.00067996 1e-04
[1] " "
     Dir D d2 m0 m1 m3      lB      uB   P
[1,]   1 5  2  0  1  3 0.13456 0.13456 0.1
[1] " "
     Dir D d2 m0 m1 m3       lB       uB    P
[1,]   1 5  2  0  1  3 0.015122 0.015122 0.01
[1] " "
     Dir D d2 m0 m1 m3        lB       uB     P
[1,]   1 5  2  0  1  3 0.0020621 0.002173 0.001
[1] " "
     Dir D d2 m0 m1 m3         lB         uB     P
[1,]   1 5  2  0  1  3 0.00059112 0.00063319 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 39
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m1 m3      lB      uB   P
[1,]   1 3  3  0  1  3 0.14034 0.14035 0.1
[1] " "
     Dir D d3 m0 m1 m3       lB       uB    P
[1,]   1 3  3  0  1  3 0.016778 0.016779 0.01
[1] " "
     Dir D d3 m0 m1 m3        lB        uB     P
[1,]   1 3  3  0  1  3 0.0024942 0.0024945 0.001
[1] " "
     Dir D d3 m0 m1 m3         lB        uB     P
[1,]   1 3  3  0  1  3 0.00072625 0.0007263 1e-04
[1] " "
     Dir D d3 m0 m1 m3      lB      uB   P
[1,]   1 4  3  0  1  3 0.13681 0.13681 0.1
[1] " "
     Dir D d3 m0 m1 m3       lB       uB    P
[1,]   1 4  3  0  1  3 0.015772 0.015773 0.01
[1] " "
     Dir D d3 m0 m1 m3        lB        uB     P
[1,]   1 4  3  0  1  3 0.0023437 0.0023439 0.001
[1] " "
     Dir D d3 m0 m1 m3         lB         uB     P
[1,]   1 4  3  0  1  3 0.00068072 0.00068075 1e-04
[1] " "
     Dir D d3 m0 m1 m3      lB      uB   P
[1,]   1 5  3  0  1  3 0.13456 0.13457 0.1
[1] " "
     Dir D d3 m0 m1 m3       lB       uB    P
[1,]   1 5  3  0  1  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 m0 m1 m3       lB        uB     P
[1,]   1 5  3  0  1  3 0.002237 0.0022459 0.001
[1] " "
     Dir D d3 m0 m1 m3         lB         uB     P
[1,]   1 5  3  0  1  3 0.00065118 0.00065123 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 40
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m1 m3      lB      uB   P
[1,]   1 0  0  1  3 0.23957 0.23957 0.1
[1] " "
     Dir D m0 m1 m3       lB       uB    P
[1,]   1 0  0  1  3 0.049958 0.049958 0.01
[1] " "
     Dir D m0 m1 m3        lB        uB     P
[1,]   1 0  0  1  3 0.0074455 0.0074458 0.001
[1] " "
     Dir D m0 m1 m3        lB        uB     P
[1,]   1 0  0  1  3 0.0021972 0.0021973 1e-04
[1] " "
     Dir D m0 m1 m3      lB      uB   P
[1,]   1 1  0  1  3 0.15906 0.15906 0.1
[1] " "
     Dir D m0 m1 m3       lB       uB    P
[1,]   1 1  0  1  3 0.021076 0.021076 0.01
[1] " "
     Dir D m0 m1 m3       lB        uB     P
[1,]   1 1  0  1  3 0.003127 0.0031272 0.001
[1] " "
     Dir D m0 m1 m3         lB         uB     P
[1,]   1 1  0  1  3 0.00091554 0.00091562 1e-04
[1] " "
     Dir D m0 m1 m3      lB      uB   P
[1,]   1 2  0  1  3 0.12653 0.14241 0.1
[1] " "
     Dir D m0 m1 m3       lB       uB    P
[1,]   1 2  0  1  3 0.017265 0.017265 0.01
[1] " "
     Dir D m0 m1 m3        lB        uB     P
[1,]   1 2  0  1  3 0.0024619 0.0024653 0.001
[1] " "
     Dir D m0 m1 m3         lB         uB     P
[1,]   1 2  0  1  3 0.00068406 0.00071826 1e-04
[1] " "
     Dir D m0 m1 m3     lB      uB   P
[1,]   1 3  0  1  3 0.1246 0.13365 0.1
[1] " "
     Dir D m0 m1 m3       lB       uB    P
[1,]   1 3  0  1  3 0.015213 0.015595 0.01
[1] " "
     Dir D m0 m1 m3       lB        uB     P
[1,]   1 3  0  1  3 0.001792 0.0021147 0.001
[1] " "
     Dir D m0 m1 m3        lB         uB     P
[1,]   1 3  0  1  3 0.0004586 0.00059524 1e-04
[1] " "
     Dir D m0 m1 m3      lB      uB   P
[1,]   1 4  0  1  3 0.13235 0.13345 0.1
[1] " "
     Dir D m0 m1 m3      lB       uB    P
[1,]   1 4  0  1  3 0.01284 0.014541 0.01
[1] " "
     Dir D m0 m1 m3        lB        uB     P
[1,]   1 4  0  1  3 0.0015664 0.0016224 0.001
[1] " "
     Dir D m0 m1 m3        lB         uB     P
[1,]   1 4  0  1  3 0.0004661 0.00059227 1e-04
[1] " "
     Dir D m0 m1 m3       lB     uB   P
[1,]   1 5  0  1  3 0.069456 0.1286 0.1
[1] " "
     Dir D m0 m1 m3       lB       uB    P
[1,]   1 5  0  1  3 0.013589 0.014054 0.01
[1] " "
     Dir D m0 m1 m3        lB        uB     P
[1,]   1 5  0  1  3 0.0012264 0.0018564 0.001
[1] " "
     Dir D m0 m1 m3         lB        uB     P
[1,]   1 5  0  1  3 0.00016612 0.0001665 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 41
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m1 m3      lB      uB   P
[1,]   1 3  3  2  1  1  3 0.15442 0.15443 0.1
[1] " "
     Dir D d3 d2 d1 m1 m3       lB       uB    P
[1,]   1 3  3  2  1  1  3 0.016968 0.016969 0.01
[1] " "
     Dir D d3 d2 d1 m1 m3        lB        uB     P
[1,]   1 3  3  2  1  1  3 0.0025112 0.0025113 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d2 d1 m1 m3         lB         uB     P
[1,]   1 3  3  2  1  1  3 0.00073188 0.00073264 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m3      lB      uB   P
[1,]   1 4  3  2  1  1  3 0.14975 0.14976 0.1
[1] " "
     Dir D d3 d2 d1 m1 m3      lB       uB    P
[1,]   1 4  3  2  1  1  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d2 d1 m1 m3        lB        uB     P
[1,]   1 4  3  2  1  1  3 0.0023567 0.0023567 0.001
[1] " "
     Dir D d3 d2 d1 m1 m3         lB         uB     P
[1,]   1 4  3  2  1  1  3 0.00068395 0.00068398 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m3      lB      uB   P
[1,]   1 5  3  2  1  1  3 0.14674 0.14675 0.1
[1] " "
     Dir D d3 d2 d1 m1 m3       lB       uB    P
[1,]   1 5  3  2  1  1  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d2 d1 m1 m3        lB        uB     P
[1,]   1 5  3  2  1  1  3 0.0022569 0.0022571 0.001
[1] " "
     Dir D d3 d2 d1 m1 m3         lB         uB     P
[1,]   1 5  3  2  1  1  3 0.00065276 0.00065278 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 42
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m1 m3      lB      uB   P
[1,]   1 2  2  1  1  3 0.16149 0.16149 0.1
[1] " "
     Dir D d2 d1 m1 m3       lB       uB    P
[1,]   1 2  2  1  1  3 0.018556 0.018557 0.01
[1] " "
     Dir D d2 d1 m1 m3        lB        uB     P
[1,]   1 2  2  1  1  3 0.0027505 0.0027507 0.001
[1] " "
     Dir D d2 d1 m1 m3         lB         uB     P
[1,]   1 2  2  1  1  3 0.00080556 0.00080561 1e-04
[1] " "
     Dir D d2 d1 m1 m3      lB      uB   P
[1,]   1 3  2  1  1  3 0.15327 0.15328 0.1
[1] " "
     Dir D d2 d1 m1 m3       lB       uB    P
[1,]   1 3  2  1  1  3 0.016778 0.016779 0.01
[1] " "
     Dir D d2 d1 m1 m3        lB        uB     P
[1,]   1 3  2  1  1  3 0.0024799 0.0024801 0.001
[1] " "
     Dir D d2 d1 m1 m3         lB         uB     P
[1,]   1 3  2  1  1  3 0.00072232 0.00072238 1e-04
[1] " "
     Dir D d2 d1 m1 m3      lB      uB   P
[1,]   1 4  2  1  1  3 0.14865 0.14866 0.1
[1] " "
     Dir D d2 d1 m1 m3       lB       uB    P
[1,]   1 4  2  1  1  3 0.015771 0.015772 0.01
[1] " "
     Dir D d2 d1 m1 m3        lB        uB     P
[1,]   1 4  2  1  1  3 0.0023264 0.0023269 0.001
[1] " "
     Dir D d2 d1 m1 m3         lB         uB     P
[1,]   1 4  2  1  1  3 0.00067444 0.00067455 1e-04
[1] " "
     Dir D d2 d1 m1 m3      lB      uB   P
[1,]   1 5  2  1  1  3 0.14009 0.14256 0.1
[1] " "
     Dir D d2 d1 m1 m3     lB      uB    P
[1,]   1 5  2  1  1  3 0.0151 0.01511 0.01
[1] " "
     Dir D d2 d1 m1 m3        lB       uB     P
[1,]   1 5  2  1  1  3 0.0021855 0.002211 0.001
[1] " "
     Dir D d2 d1 m1 m3         lB        uB     P
[1,]   1 5  2  1  1  3 0.00062169 0.0006368 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 43
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m1 m3      lB      uB   P
[1,]   1 3  3  1  1  3 0.15327 0.15329 0.1
[1] " "
     Dir D d3 d1 m1 m3       lB       uB    P
[1,]   1 3  3  1  1  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 d1 m1 m3      lB        uB     P
[1,]   1 3  3  1  1  3 0.00248 0.0024801 0.001
[1] " "
     Dir D d3 d1 m1 m3         lB         uB     P
[1,]   1 3  3  1  1  3 0.00072233 0.00072237 1e-04
[1] " "
     Dir D d3 d1 m1 m3      lB      uB   P
[1,]   1 4  3  1  1  3 0.14866 0.14867 0.1
[1] " "
     Dir D d3 d1 m1 m3       lB       uB    P
[1,]   1 4  3  1  1  3 0.015772 0.015772 0.01
[1] " "
     Dir D d3 d1 m1 m3        lB        uB     P
[1,]   1 4  3  1  1  3 0.0023269 0.0023269 0.001
[1] " "
     Dir D d3 d1 m1 m3         lB         uB     P
[1,]   1 4  3  1  1  3 0.00067476 0.00067479 1e-04
[1] " "
     Dir D d3 d1 m1 m3      lB      uB   P
[1,]   1 5  3  1  1  3 0.14568 0.14568 0.1
[1] " "
     Dir D d3 d1 m1 m3      lB       uB    P
[1,]   1 5  3  1  1  3 0.01512 0.015121 0.01
[1] " "
     Dir D d3 d1 m1 m3        lB        uB     P
[1,]   1 5  3  1  1  3 0.0022279 0.0022281 0.001
[1] " "
     Dir D d3 d1 m1 m3         lB         uB     P
[1,]   1 5  3  1  1  3 0.00064381 0.00064386 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 44
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m1 m3      lB      uB   P
[1,]   1 1  1  1  3 0.17822 0.17823 0.1
[1] " "
     Dir D d1 m1 m3       lB       uB    P
[1,]   1 1  1  1  3 0.021076 0.021076 0.01
[1] " "
     Dir D d1 m1 m3        lB        uB     P
[1,]   1 1  1  1  3 0.0031299 0.0031302 0.001
[1] " "
     Dir D d1 m1 m3         lB         uB     P
[1,]   1 1  1  1  3 0.00092238 0.00092246 1e-04
[1] " "
     Dir D d1 m1 m3      lB      uB   P
[1,]   1 2  1  1  3 0.15842 0.15842 0.1
[1] " "
     Dir D d1 m1 m3       lB       uB    P
[1,]   1 2  1  1  3 0.017265 0.017265 0.01
[1] " "
     Dir D d1 m1 m3        lB        uB     P
[1,]   1 2  1  1  3 0.0025475 0.0025476 0.001
[1] " "
     Dir D d1 m1 m3         lB       uB     P
[1,]   1 2  1  1  3 0.00074498 0.000745 1e-04
[1] " "
     Dir D d1 m1 m3      lB      uB   P
[1,]   1 3  1  1  3 0.14447 0.14869 0.1
[1] " "
     Dir D d1 m1 m3       lB       uB    P
[1,]   1 3  1  1  3 0.015612 0.015612 0.01
[1] " "
     Dir D d1 m1 m3        lB        uB     P
[1,]   1 3  1  1  3 0.0022459 0.0022898 0.001
[1] " "
     Dir D d1 m1 m3         lB        uB     P
[1,]   1 3  1  1  3 0.00064064 0.0006524 1e-04
[1] " "
     Dir D d1 m1 m3       lB     uB   P
[1,]   1 4  1  1  3 0.093503 0.1268 0.1
[1] " "
     Dir D d1 m1 m3       lB       uB    P
[1,]   1 4  1  1  3 0.014601 0.014674 0.01
[1] " "
     Dir D d1 m1 m3       lB        uB     P
[1,]   1 4  1  1  3 0.001918 0.0019823 0.001
[1] " "
     Dir D d1 m1 m3         lB        uB     P
[1,]   1 4  1  1  3 0.00043633 0.0005346 1e-04
[1] " "
     Dir D d1 m1 m3       lB      uB   P
[1,]   1 5  1  1  3 0.091649 0.13365 0.1
[1] " "
     Dir D d1 m1 m3       lB       uB    P
[1,]   1 5  1  1  3 0.014023 0.014069 0.01
[1] " "
     Dir D d1 m1 m3        lB        uB     P
[1,]   1 5  1  1  3 0.0014223 0.0017672 0.001
[1] " "
     Dir D d1 m1 m3         lB         uB     P
[1,]   1 5  1  1  3 0.00028889 0.00045195 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 45
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m1 m3      lB      uB   P
[1,]   1 3  3  2  1  3 0.15329 0.15329 0.1
[1] " "
     Dir D d3 d2 m1 m3       lB       uB    P
[1,]   1 3  3  2  1  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 d2 m1 m3        lB        uB     P
[1,]   1 3  3  2  1  3 0.0024925 0.0024927 0.001
[1] " "
     Dir D d3 d2 m1 m3         lB         uB     P
[1,]   1 3  3  2  1  3 0.00073329 0.00073334 1e-04
[1] " "
     Dir D d3 d2 m1 m3      lB      uB   P
[1,]   1 4  3  2  1  3 0.14883 0.14883 0.1
[1] " "
     Dir D d3 d2 m1 m3       lB       uB    P
[1,]   1 4  3  2  1  3 0.015773 0.015773 0.01
[1] " "
     Dir D d3 d2 m1 m3        lB        uB     P
[1,]   1 4  3  2  1  3 0.0023371 0.0023373 0.001
[1] " "
     Dir D d3 d2 m1 m3         lB         uB     P
[1,]   1 4  3  2  1  3 0.00068513 0.00068518 1e-04
[1] " "
     Dir D d3 d2 m1 m3      lB      uB   P
[1,]   1 5  3  2  1  3 0.14602 0.14602 0.1
[1] " "
     Dir D d3 d2 m1 m3       lB       uB    P
[1,]   1 5  3  2  1  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 d2 m1 m3        lB        uB     P
[1,]   1 5  3  2  1  3 0.0022366 0.0022368 0.001
[1] " "
     Dir D d3 d2 m1 m3         lB         uB     P
[1,]   1 5  3  2  1  3 0.00065373 0.00065377 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 46
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m1 m3      lB      uB   P
[1,]   1 2  2  1  3 0.15842 0.15842 0.1
[1] " "
     Dir D d2 m1 m3       lB       uB    P
[1,]   1 2  2  1  3 0.017265 0.017266 0.01
[1] " "
     Dir D d2 m1 m3        lB        uB     P
[1,]   1 2  2  1  3 0.0025687 0.0025687 0.001
[1] " "
     Dir D d2 m1 m3         lB         uB     P
[1,]   1 2  2  1  3 0.00075868 0.00075872 1e-04
[1] " "
     Dir D d2 m1 m3      lB      uB   P
[1,]   1 3  2  1  3 0.15038 0.15038 0.1
[1] " "
     Dir D d2 m1 m3       lB       uB    P
[1,]   1 3  2  1  3 0.015612 0.015612 0.01
[1] " "
     Dir D d2 m1 m3        lB        uB     P
[1,]   1 3  2  1  3 0.0023112 0.0023113 0.001
[1] " "
     Dir D d2 m1 m3         lB         uB     P
[1,]   1 3  2  1  3 0.00067943 0.00067948 1e-04
[1] " "
     Dir D d2 m1 m3    lB    uB   P
[1,]   1 4  2  1  3 0.146 0.146 0.1
[1] " "
     Dir D d2 m1 m3       lB       uB    P
[1,]   1 4  2  1  3 0.014675 0.014675 0.01
[1] " "
     Dir D d2 m1 m3        lB        uB     P
[1,]   1 4  2  1  3 0.0021438 0.0021648 0.001
[1] " "
     Dir D d2 m1 m3        lB         uB     P
[1,]   1 4  2  1  3 0.0006219 0.00062195 1e-04
[1] " "
     Dir D d2 m1 m3      lB      uB   P
[1,]   1 5  2  1  3 0.13823 0.14096 0.1
[1] " "
     Dir D d2 m1 m3      lB      uB    P
[1,]   1 5  2  1  3 0.01407 0.01407 0.01
[1] " "
     Dir D d2 m1 m3       lB        uB     P
[1,]   1 5  2  1  3 0.001978 0.0020213 0.001
[1] " "
     Dir D d2 m1 m3         lB         uB     P
[1,]   1 5  2  1  3 0.00055203 0.00056307 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 47
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m1 m3      lB      uB   P
[1,]   1 3  3  1  3 0.15038 0.15038 0.1
[1] " "
     Dir D d3 m1 m3       lB       uB    P
[1,]   1 3  3  1  3 0.015612 0.015612 0.01
[1] " "
     Dir D d3 m1 m3        lB        uB     P
[1,]   1 3  3  1  3 0.0023255 0.0023257 0.001
[1] " "
     Dir D d3 m1 m3         lB         uB     P
[1,]   1 3  3  1  3 0.00068772 0.00068777 1e-04
[1] " "
     Dir D d3 m1 m3    lB    uB   P
[1,]   1 4  3  1  3 0.146 0.146 0.1
[1] " "
     Dir D d3 m1 m3       lB       uB    P
[1,]   1 4  3  1  3 0.014675 0.014675 0.01
[1] " "
     Dir D d3 m1 m3        lB        uB     P
[1,]   1 4  3  1  3 0.0021778 0.0021779 0.001
[1] " "
     Dir D d3 m1 m3         lB         uB     P
[1,]   1 4  3  1  3 0.00064195 0.00064201 1e-04
[1] " "
     Dir D d3 m1 m3      lB      uB   P
[1,]   1 5  3  1  3 0.14325 0.14325 0.1
[1] " "
     Dir D d3 m1 m3      lB      uB    P
[1,]   1 5  3  1  3 0.01407 0.01407 0.01
[1] " "
     Dir D d3 m1 m3        lB        uB     P
[1,]   1 5  3  1  3 0.0020702 0.0020811 0.001
[1] " "
     Dir D d3 m1 m3         lB        uB     P
[1,]   1 5  3  1  3 0.00060622 0.0006112 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 48
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m1 m3      lB      uB   P
[1,]   1 0  1  3 0.34711 0.34711 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 0  1  3 0.049106 0.049106 0.01
[1] " "
     Dir D m1 m3       lB        uB     P
[1,]   1 0  1  3 0.007362 0.0073622 0.001
[1] " "
     Dir D m1 m3        lB        uB     P
[1,]   1 0  1  3 0.0021871 0.0021873 1e-04
[1] " "
     Dir D m1 m3      lB      uB   P
[1,]   1 1  1  3 0.17355 0.17355 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 1  1  3 0.020717 0.020717 0.01
[1] " "
     Dir D m1 m3        lB       uB     P
[1,]   1 1  1  3 0.0031049 0.003105 0.001
[1] " "
     Dir D m1 m3         lB         uB     P
[1,]   1 1  1  3 0.00092197 0.00092201 1e-04
[1] " "
     Dir D m1 m3      lB      uB   P
[1,]   1 2  1  3 0.15427 0.15427 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 2  1  3 0.016971 0.016971 0.01
[1] " "
     Dir D m1 m3        lB        uB     P
[1,]   1 2  1  3 0.0025381 0.0025405 0.001
[1] " "
     Dir D m1 m3         lB         uB     P
[1,]   1 2  1  3 0.00074997 0.00075063 1e-04
[1] " "
     Dir D m1 m3      lB      uB   P
[1,]   1 3  1  3 0.13269 0.14429 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 3  1  3 0.015346 0.015346 0.01
[1] " "
     Dir D m1 m3       lB        uB     P
[1,]   1 3  1  3 0.002219 0.0022229 0.001
[1] " "
     Dir D m1 m3         lB         uB     P
[1,]   1 3  1  3 0.00062857 0.00065177 1e-04
[1] " "
     Dir D m1 m3      lB      uB   P
[1,]   1 4  1  3 0.13019 0.14165 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 4  1  3 0.013199 0.014293 0.01
[1] " "
     Dir D m1 m3        lB        uB     P
[1,]   1 4  1  3 0.0017675 0.0020038 0.001
[1] " "
     Dir D m1 m3         lB         uB     P
[1,]   1 4  1  3 0.00047157 0.00057724 1e-04
[1] " "
     Dir D m1 m3       lB      uB   P
[1,]   1 5  1  3 0.070649 0.13504 0.1
[1] " "
     Dir D m1 m3       lB       uB    P
[1,]   1 5  1  3 0.013379 0.013815 0.01
[1] " "
     Dir D m1 m3        lB        uB     P
[1,]   1 5  1  3 0.0011479 0.0017977 0.001
[1] " "
     Dir D m1 m3         lB         uB     P
[1,]   1 5  1  3 0.00014483 0.00046997 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 49
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m3      lB      uB   P
[1,]   1 3  3  2  1  0  3 0.15658 0.15658 0.1
[1] " "
     Dir D d3 d2 d1 m0 m3       lB       uB    P
[1,]   1 3  3  2  1  0  3 0.016967 0.016969 0.01
[1] " "
     Dir D d3 d2 d1 m0 m3        lB        uB     P
[1,]   1 3  3  2  1  0  3 0.0025324 0.0025325 0.001
[1] " "
     Dir D d3 d2 d1 m0 m3         lB         uB     P
[1,]   1 3  3  2  1  0  3 0.00075104 0.00075111 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m3      lB      uB   P
[1,]   1 4  3  2  1  0  3 0.15077 0.15078 0.1
[1] " "
     Dir D d3 d2 d1 m0 m3      lB       uB    P
[1,]   1 4  3  2  1  0  3 0.01595 0.015951 0.01
[1] " "
     Dir D d3 d2 d1 m0 m3        lB        uB     P
[1,]   1 4  3  2  1  0  3 0.0023771 0.0023773 0.001
[1] " "
     Dir D d3 d2 d1 m0 m3         lB         uB     P
[1,]   1 4  3  2  1  0  3 0.00070425 0.00070431 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m3     lB      uB   P
[1,]   1 5  3  2  1  0  3 0.1468 0.14681 0.1
[1] " "
     Dir D d3 d2 d1 m0 m3       lB       uB    P
[1,]   1 5  3  2  1  0  3 0.015291 0.015292 0.01
[1] " "
     Dir D d3 d2 d1 m0 m3        lB        uB     P
[1,]   1 5  3  2  1  0  3 0.0022765 0.0022765 0.001
[1] " "
     Dir D d3 d2 d1 m0 m3         lB         uB     P
[1,]   1 5  3  2  1  0  3 0.00067382 0.00067388 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 50
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m3      lB      uB   P
[1,]   1 2  2  1  0  3 0.16572 0.16572 0.1
[1] " "
     Dir D d2 d1 m0 m3       lB       uB    P
[1,]   1 2  2  1  0  3 0.018555 0.018555 0.01
[1] " "
     Dir D d2 d1 m0 m3        lB       uB     P
[1,]   1 2  2  1  0  3 0.0027738 0.002774 0.001
[1] " "
     Dir D d2 d1 m0 m3         lB         uB     P
[1,]   1 2  2  1  0  3 0.00082346 0.00082349 1e-04
[1] " "
     Dir D d2 d1 m0 m3     lB     uB   P
[1,]   1 3  2  1  0  3 0.1561 0.1561 0.1
[1] " "
     Dir D d2 d1 m0 m3       lB       uB    P
[1,]   1 3  2  1  0  3 0.016778 0.016779 0.01
[1] " "
     Dir D d2 d1 m0 m3        lB        uB     P
[1,]   1 3  2  1  0  3 0.0025032 0.0025034 0.001
[1] " "
     Dir D d2 d1 m0 m3         lB         uB     P
[1,]   1 3  2  1  0  3 0.00074233 0.00074237 1e-04
[1] " "
     Dir D d2 d1 m0 m3      lB      uB   P
[1,]   1 4  2  1  0  3 0.15006 0.15011 0.1
[1] " "
     Dir D d2 d1 m0 m3       lB       uB    P
[1,]   1 4  2  1  0  3 0.015772 0.015772 0.01
[1] " "
     Dir D d2 d1 m0 m3        lB        uB     P
[1,]   1 4  2  1  0  3 0.0023363 0.0023431 0.001
[1] " "
     Dir D d2 d1 m0 m3         lB         uB     P
[1,]   1 4  2  1  0  3 0.00069252 0.00069572 1e-04
[1] " "
     Dir D d2 d1 m0 m3      lB      uB   P
[1,]   1 5  2  1  0  3 0.14596 0.14596 0.1
[1] " "
     Dir D d2 d1 m0 m3       lB       uB    P
[1,]   1 5  2  1  0  3 0.015085 0.015086 0.01
[1] " "
     Dir D d2 d1 m0 m3        lB        uB     P
[1,]   1 5  2  1  0  3 0.0020955 0.0021846 0.001
[1] " "
     Dir D d2 d1 m0 m3         lB         uB     P
[1,]   1 5  2  1  0  3 0.00060949 0.00064624 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 51
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m3      lB      uB   P
[1,]   1 3  3  1  0  3 0.15566 0.15566 0.1
[1] " "
     Dir D d3 d1 m0 m3       lB       uB    P
[1,]   1 3  3  1  0  3 0.016778 0.016779 0.01
[1] " "
     Dir D d3 d1 m0 m3        lB        uB     P
[1,]   1 3  3  1  0  3 0.0025033 0.0025035 0.001
[1] " "
     Dir D d3 d1 m0 m3         lB         uB     P
[1,]   1 3  3  1  0  3 0.00074233 0.00074235 1e-04
[1] " "
     Dir D d3 d1 m0 m3      lB     uB   P
[1,]   1 4  3  1  0  3 0.14989 0.1499 0.1
[1] " "
     Dir D d3 d1 m0 m3       lB       uB    P
[1,]   1 4  3  1  0  3 0.015772 0.015773 0.01
[1] " "
     Dir D d3 d1 m0 m3        lB        uB     P
[1,]   1 4  3  1  0  3 0.0023495 0.0023497 0.001
[1] " "
     Dir D d3 d1 m0 m3         lB         uB     P
[1,]   1 4  3  1  0  3 0.00069601 0.00069607 1e-04
[1] " "
     Dir D d3 d1 m0 m3      lB      uB   P
[1,]   1 5  3  1  0  3 0.14596 0.14597 0.1
[1] " "
     Dir D d3 d1 m0 m3      lB       uB    P
[1,]   1 5  3  1  0  3 0.01512 0.015121 0.01
[1] " "
     Dir D d3 d1 m0 m3        lB        uB     P
[1,]   1 5  3  1  0  3 0.0022498 0.0022499 0.001
[1] " "
     Dir D d3 d1 m0 m3         lB         uB     P
[1,]   1 5  3  1  0  3 0.00066585 0.00066587 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 52
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m3     lB      uB   P
[1,]   1 1  1  0  3 0.1826 0.18261 0.1
[1] " "
     Dir D d1 m0 m3       lB       uB    P
[1,]   1 1  1  0  3 0.021073 0.021074 0.01
[1] " "
     Dir D d1 m0 m3        lB        uB     P
[1,]   1 1  1  0  3 0.0031565 0.0031567 0.001
[1] " "
     Dir D d1 m0 m3        lB         uB     P
[1,]   1 1  1  0  3 0.0009379 0.00093795 1e-04
[1] " "
     Dir D d1 m0 m3      lB      uB   P
[1,]   1 2  1  0  3 0.16298 0.16298 0.1
[1] " "
     Dir D d1 m0 m3       lB       uB    P
[1,]   1 2  1  0  3 0.017264 0.017264 0.01
[1] " "
     Dir D d1 m0 m3        lB       uB     P
[1,]   1 2  1  0  3 0.0025788 0.002579 0.001
[1] " "
     Dir D d1 m0 m3         lB         uB     P
[1,]   1 2  1  0  3 0.00076545 0.00076549 1e-04
[1] " "
     Dir D d1 m0 m3      lB      uB   P
[1,]   1 3  1  0  3 0.15288 0.15288 0.1
[1] " "
     Dir D d1 m0 m3       lB       uB    P
[1,]   1 3  1  0  3 0.015609 0.015609 0.01
[1] " "
     Dir D d1 m0 m3        lB        uB     P
[1,]   1 3  1  0  3 0.0022316 0.0022629 0.001
[1] " "
     Dir D d1 m0 m3         lB         uB     P
[1,]   1 3  1  0  3 0.00065481 0.00067058 1e-04
[1] " "
     Dir D d1 m0 m3      lB      uB   P
[1,]   1 4  1  0  3 0.14271 0.14471 0.1
[1] " "
     Dir D d1 m0 m3       lB       uB    P
[1,]   1 4  1  0  3 0.014314 0.014476 0.01
[1] " "
     Dir D d1 m0 m3        lB        uB     P
[1,]   1 4  1  0  3 0.0016925 0.0020338 0.001
[1] " "
     Dir D d1 m0 m3         lB         uB     P
[1,]   1 4  1  0  3 0.00048636 0.00059973 1e-04
[1] " "
     Dir D d1 m0 m3      lB      uB   P
[1,]   1 5  1  0  3 0.11956 0.13903 0.1
[1] " "
     Dir D d1 m0 m3       lB       uB    P
[1,]   1 5  1  0  3 0.013912 0.013991 0.01
[1] " "
     Dir D d1 m0 m3         lB        uB     P
[1,]   1 5  1  0  3 0.00058452 0.0017263 0.001
[1] " "
     Dir D d1 m0 m3         lB         uB     P
[1,]   1 5  1  0  3 0.00012948 0.00049608 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 53
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m3      lB      uB   P
[1,]   1 3  3  2  0  3 0.15646 0.15647 0.1
[1] " "
     Dir D d3 d2 m0 m3       lB       uB    P
[1,]   1 3  3  2  0  3 0.016778 0.016779 0.01
[1] " "
     Dir D d3 d2 m0 m3       lB        uB     P
[1,]   1 3  3  2  0  3 0.002509 0.0025091 0.001
[1] " "
[1] "Cycle"
     Dir D d3 d2 m0 m3         lB         uB     P
[1,]   1 3  3  2  0  3 0.00074511 0.00074536 1e-04
[1] " "
     Dir D d3 d2 m0 m3      lB      uB   P
[1,]   1 4  3  2  0  3 0.15025 0.15025 0.1
[1] " "
     Dir D d3 d2 m0 m3       lB       uB    P
[1,]   1 4  3  2  0  3 0.015772 0.015774 0.01
[1] " "
     Dir D d3 d2 m0 m3        lB        uB     P
[1,]   1 4  3  2  0  3 0.0023545 0.0023547 0.001
[1] " "
     Dir D d3 d2 m0 m3        lB         uB     P
[1,]   1 4  3  2  0  3 0.0006988 0.00069885 1e-04
[1] " "
     Dir D d3 d2 m0 m3      lB      uB   P
[1,]   1 5  3  2  0  3 0.14604 0.14605 0.1
[1] " "
     Dir D d3 d2 m0 m3       lB       uB    P
[1,]   1 5  3  2  0  3 0.015122 0.015122 0.01
[1] " "
     Dir D d3 d2 m0 m3        lB        uB     P
[1,]   1 5  3  2  0  3 0.0022534 0.0022536 0.001
[1] " "
     Dir D d3 d2 m0 m3         lB         uB     P
[1,]   1 5  3  2  0  3 0.00066847 0.00066853 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 54
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m3      lB      uB   P
[1,]   1 2  2  0  3 0.16298 0.16299 0.1
[1] " "
     Dir D d2 m0 m3       lB       uB    P
[1,]   1 2  2  0  3 0.017263 0.017264 0.01
[1] " "
     Dir D d2 m0 m3        lB        uB     P
[1,]   1 2  2  0  3 0.0025858 0.0025859 0.001
[1] " "
     Dir D d2 m0 m3         lB         uB     P
[1,]   1 2  2  0  3 0.00076837 0.00076837 1e-04
[1] " "
     Dir D d2 m0 m3      lB      uB   P
[1,]   1 3  2  0  3 0.15288 0.15289 0.1
[1] " "
     Dir D d2 m0 m3      lB      uB    P
[1,]   1 3  2  0  3 0.01561 0.01561 0.01
[1] " "
     Dir D d2 m0 m3       lB        uB     P
[1,]   1 3  2  0  3 0.002333 0.0023332 0.001
[1] " "
     Dir D d2 m0 m3         lB         uB     P
[1,]   1 3  2  0  3 0.00069281 0.00069287 1e-04
[1] " "
     Dir D d2 m0 m3     lB     uB   P
[1,]   1 4  2  0  3 0.1467 0.1467 0.1
[1] " "
     Dir D d2 m0 m3       lB       uB    P
[1,]   1 4  2  0  3 0.014672 0.014673 0.01
[1] " "
     Dir D d2 m0 m3       lB        uB     P
[1,]   1 4  2  0  3 0.002167 0.0021725 0.001
[1] " "
     Dir D d2 m0 m3         lB         uB     P
[1,]   1 4  2  0  3 0.00064193 0.00064491 1e-04
[1] " "
     Dir D d2 m0 m3      lB      uB   P
[1,]   1 5  2  0  3 0.14251 0.14253 0.1
[1] " "
     Dir D d2 m0 m3       lB       uB    P
[1,]   1 5  2  0  3 0.014067 0.014068 0.01
[1] " "
     Dir D d2 m0 m3        lB       uB     P
[1,]   1 5  2  0  3 0.0018723 0.002012 0.001
[1] " "
     Dir D d2 m0 m3         lB         uB     P
[1,]   1 5  2  0  3 0.00053716 0.00053927 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 55
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m3      lB      uB   P
[1,]   1 3  3  0  3 0.15288 0.15289 0.1
[1] " "
     Dir D d3 m0 m3      lB       uB    P
[1,]   1 3  3  0  3 0.01561 0.015611 0.01
[1] " "
     Dir D d3 m0 m3        lB        uB     P
[1,]   1 3  3  0  3 0.0023384 0.0023386 0.001
[1] " "
     Dir D d3 m0 m3         lB         uB     P
[1,]   1 3  3  0  3 0.00069488 0.00069492 1e-04
[1] " "
     Dir D d3 m0 m3     lB      uB   P
[1,]   1 4  3  0  3 0.1467 0.14671 0.1
[1] " "
     Dir D d3 m0 m3       lB       uB    P
[1,]   1 4  3  0  3 0.014674 0.014674 0.01
[1] " "
     Dir D d3 m0 m3        lB        uB     P
[1,]   1 4  3  0  3 0.0021947 0.0021947 0.001
[1] " "
     Dir D d3 m0 m3        lB         uB     P
[1,]   1 4  3  0  3 0.0006519 0.00065194 1e-04
[1] " "
     Dir D d3 m0 m3      lB      uB   P
[1,]   1 5  3  0  3 0.14252 0.14253 0.1
[1] " "
     Dir D d3 m0 m3       lB       uB    P
[1,]   1 5  3  0  3 0.014069 0.014069 0.01
[1] " "
     Dir D d3 m0 m3        lB        uB     P
[1,]   1 5  3  0  3 0.0020923 0.0020988 0.001
[1] " "
     Dir D d3 m0 m3        lB        uB     P
[1,]   1 5  3  0  3 0.0006205 0.0006232 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 56
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m3      lB      uB   P
[1,]   1 0  0  3 0.23695 0.23695 0.1
[1] " "
     Dir D m0 m3       lB       uB    P
[1,]   1 0  0  3 0.049106 0.049106 0.01
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 0  0  3 0.0073654 0.0073654 0.001
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 0  0  3 0.0021892 0.0021892 1e-04
[1] " "
     Dir D m0 m3      lB      uB   P
[1,]   1 1  0  3 0.18048 0.18049 0.1
[1] " "
     Dir D m0 m3       lB       uB    P
[1,]   1 1  0  3 0.020717 0.020717 0.01
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 1  0  3 0.0031073 0.0031073 0.001
[1] " "
     Dir D m0 m3         lB        uB     P
[1,]   1 1  0  3 0.00092358 0.0009236 1e-04
[1] " "
     Dir D m0 m3       lB      uB   P
[1,]   1 2  0  3 0.089887 0.15218 0.1
[1] " "
     Dir D m0 m3       lB       uB    P
[1,]   1 2  0  3 0.016971 0.016971 0.01
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 2  0  3 0.0025455 0.0025455 0.001
[1] " "
     Dir D m0 m3        lB         uB     P
[1,]   1 2  0  3 0.0007566 0.00075661 1e-04
[1] " "
     Dir D m0 m3       lB       uB   P
[1,]   1 3  0  3 0.031913 0.053776 0.1
[1] " "
     Dir D m0 m3       lB      uB    P
[1,]   1 3  0  3 0.011296 0.01422 0.01
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 3  0  3 0.0023016 0.0023018 0.001
[1] " "
     Dir D m0 m3         lB         uB     P
[1,]   1 3  0  3 0.00068414 0.00068414 1e-04
[1] " "
     Dir D m0 m3        lB       uB   P
[1,]   1 4  0  3 0.0083847 0.063386 0.1
[1] " "
     Dir D m0 m3        lB        uB    P
[1,]   1 4  0  3 0.0045631 0.0055631 0.01
[1] " "
     Dir D m0 m3        lB        uB     P
[1,]   1 4  0  3 0.0019337 0.0020315 0.001
[1] " "
     Dir D m0 m3         lB         uB     P
[1,]   1 4  0  3 0.00064307 0.00064312 1e-04
[1] " "
     Dir D m0 m3        lB       uB   P
[1,]   1 5  0  3 0.0021887 0.010279 0.1
[1] " "
     Dir D m0 m3        lB        uB    P
[1,]   1 5  0  3 0.0013408 0.0023239 0.01
[1] " "
     Dir D m0 m3         lB         uB     P
[1,]   1 5  0  3 0.00080151 0.00096811 0.001
[1] " "
     Dir D m0 m3         lB         uB     P
[1,]   1 5  0  3 0.00046073 0.00046396 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 57
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m3      lB      uB   P
[1,]   1 3  3  2  1  3 0.28638 0.28639 0.1
[1] " "
     Dir D d3 d2 d1 m3       lB       uB    P
[1,]   1 3  3  2  1  3 0.016779 0.016779 0.01
[1] " "
     Dir D d3 d2 d1 m3        lB        uB     P
[1,]   1 3  3  2  1  3 0.0025165 0.0025166 0.001
[1] " "
     Dir D d3 d2 d1 m3         lB         uB     P
[1,]   1 3  3  2  1  3 0.00074798 0.00074803 1e-04
[1] " "
     Dir D d3 d2 d1 m3     lB      uB   P
[1,]   1 4  3  2  1  3 0.2567 0.25671 0.1
[1] " "
     Dir D d3 d2 d1 m3       lB       uB    P
[1,]   1 4  3  2  1  3 0.015772 0.015773 0.01
[1] " "
     Dir D d3 d2 d1 m3        lB        uB     P
[1,]   1 4  3  2  1  3 0.0023655 0.0023656 0.001
[1] " "
     Dir D d3 d2 d1 m3        lB         uB     P
[1,]   1 4  3  2  1  3 0.0007031 0.00070312 1e-04
[1] " "
     Dir D d3 d2 d1 m3      lB      uB   P
[1,]   1 5  3  2  1  3 0.23864 0.23865 0.1
[1] " "
     Dir D d3 d2 d1 m3      lB       uB    P
[1,]   1 5  3  2  1  3 0.01512 0.015121 0.01
[1] " "
     Dir D d3 d2 d1 m3        lB        uB     P
[1,]   1 5  3  2  1  3 0.0022669 0.0022671 0.001
[1] " "
     Dir D d3 d2 d1 m3         lB         uB     P
[1,]   1 5  3  2  1  3 0.00067376 0.00067385 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 58
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m3      lB      uB   P
[1,]   1 2  2  1  3 0.33305 0.33306 0.1
[1] " "
     Dir D d2 d1 m3       lB       uB    P
[1,]   1 2  2  1  3 0.017265 0.017265 0.01
[1] " "
     Dir D d2 d1 m3        lB        uB     P
[1,]   1 2  2  1  3 0.0025896 0.0025896 0.001
[1] " "
     Dir D d2 d1 m3        lB         uB     P
[1,]   1 2  2  1  3 0.0007697 0.00076975 1e-04
[1] " "
     Dir D d2 d1 m3      lB      uB   P
[1,]   1 3  2  1  3 0.27683 0.27684 0.1
[1] " "
     Dir D d2 d1 m3       lB       uB    P
[1,]   1 3  2  1  3 0.015611 0.015612 0.01
[1] " "
     Dir D d2 d1 m3        lB        uB     P
[1,]   1 3  2  1  3 0.0023415 0.0023416 0.001
[1] " "
     Dir D d2 d1 m3         lB         uB     P
[1,]   1 3  2  1  3 0.00069597 0.00069599 1e-04
[1] " "
     Dir D d2 d1 m3      lB      uB   P
[1,]   1 4  2  1  3 0.24804 0.24806 0.1
[1] " "
     Dir D d2 d1 m3       lB       uB    P
[1,]   1 4  2  1  3 0.014675 0.014675 0.01
[1] " "
     Dir D d2 d1 m3        lB        uB     P
[1,]   1 4  2  1  3 0.0021996 0.0022001 0.001
[1] " "
     Dir D d2 d1 m3         lB         uB     P
[1,]   1 4  2  1  3 0.00065374 0.00065394 1e-04
[1] " "
     Dir D d2 d1 m3      lB      uB   P
[1,]   1 5  2  1  3 0.21686 0.22219 0.1
[1] " "
     Dir D d2 d1 m3       lB       uB    P
[1,]   1 5  2  1  3 0.013987 0.014008 0.01
[1] " "
     Dir D d2 d1 m3        lB        uB     P
[1,]   1 5  2  1  3 0.0018985 0.0020487 0.001
[1] " "
     Dir D d2 d1 m3         lB        uB     P
[1,]   1 5  2  1  3 0.00055216 0.0006083 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 59
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m3      lB      uB   P
[1,]   1 3  3  1  3 0.27683 0.27684 0.1
[1] " "
     Dir D d3 d1 m3       lB       uB    P
[1,]   1 3  3  1  3 0.015611 0.015612 0.01
[1] " "
     Dir D d3 d1 m3        lB        uB     P
[1,]   1 3  3  1  3 0.0023414 0.0023415 0.001
[1] " "
     Dir D d3 d1 m3         lB         uB     P
[1,]   1 3  3  1  3 0.00069594 0.00069599 1e-04
[1] " "
     Dir D d3 d1 m3      lB      uB   P
[1,]   1 4  3  1  3 0.24805 0.24806 0.1
[1] " "
     Dir D d3 d1 m3       lB       uB    P
[1,]   1 4  3  1  3 0.014674 0.014675 0.01
[1] " "
     Dir D d3 d1 m3        lB        uB     P
[1,]   1 4  3  1  3 0.0022009 0.0022009 0.001
[1] " "
     Dir D d3 d1 m3         lB         uB     P
[1,]   1 4  3  1  3 0.00065418 0.00065419 1e-04
[1] " "
     Dir D d3 d1 m3      lB      uB   P
[1,]   1 5  3  1  3 0.23053 0.23054 0.1
[1] " "
     Dir D d3 d1 m3       lB       uB    P
[1,]   1 5  3  1  3 0.014068 0.014068 0.01
[1] " "
     Dir D d3 d1 m3        lB        uB     P
[1,]   1 5  3  1  3 0.0021089 0.0021093 0.001
[1] " "
     Dir D d3 d1 m3         lB         uB     P
[1,]   1 5  3  1  3 0.00062681 0.00062694 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 60
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m3      lB     uB   P
[1,]   1 1  1  3 0.48707 0.4871 0.1
[1] " "
     Dir D d1 m3       lB       uB    P
[1,]   1 1  1  3 0.020717 0.020717 0.01
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 1  1  3 0.0031073 0.0031073 0.001
[1] " "
     Dir D d1 m3         lB         uB     P
[1,]   1 1  1  3 0.00092358 0.00092359 1e-04
[1] " "
     Dir D d1 m3      lB      uB   P
[1,]   1 2  1  3 0.32871 0.32873 0.1
[1] " "
     Dir D d1 m3       lB       uB    P
[1,]   1 2  1  3 0.016971 0.016971 0.01
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 2  1  3 0.0025455 0.0025455 0.001
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 2  1  3 0.0007566 0.0007566 1e-04
[1] " "
     Dir D d1 m3      lB      uB   P
[1,]   1 3  1  3 0.18754 0.24944 0.1
[1] " "
     Dir D d1 m3       lB       uB    P
[1,]   1 3  1  3 0.015346 0.015346 0.01
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 3  1  3 0.0023017 0.0023017 0.001
[1] " "
     Dir D d1 m3         lB         uB     P
[1,]   1 3  1  3 0.00068414 0.00068415 1e-04
[1] " "
     Dir D d1 m3       lB      uB   P
[1,]   1 4  1  3 0.084883 0.13884 0.1
[1] " "
     Dir D d1 m3       lB       uB    P
[1,]   1 4  1  3 0.014365 0.014395 0.01
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 4  1  3 0.0021636 0.0021636 0.001
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 4  1  3 0.0006431 0.0006431 1e-04
[1] " "
     Dir D d1 m3       lB       uB   P
[1,]   1 5  1  3 0.030404 0.071911 0.1
[1] " "
     Dir D d1 m3        lB       uB    P
[1,]   1 5  1  3 0.0099159 0.012164 0.01
[1] " "
     Dir D d1 m3        lB        uB     P
[1,]   1 5  1  3 0.0020743 0.0020743 0.001
[1] " "
     Dir D d1 m3         lB         uB     P
[1,]   1 5  1  3 0.00061656 0.00061656 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 61
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m3      lB     uB   P
[1,]   1 3  3  2  3 0.46748 0.4675 0.1
[1] " "
     Dir D d3 d2 m3       lB       uB    P
[1,]   1 3  3  2  3 0.015612 0.015613 0.01
[1] " "
     Dir D d3 d2 m3        lB        uB     P
[1,]   1 3  3  2  3 0.0023416 0.0023418 0.001
[1] " "
     Dir D d3 d2 m3       lB         uB     P
[1,]   1 3  3  2  3 0.000696 0.00069607 1e-04
[1] " "
     Dir D d3 d2 m3      lB     uB   P
[1,]   1 4  3  2  3 0.43948 0.4395 0.1
[1] " "
     Dir D d3 d2 m3       lB       uB    P
[1,]   1 4  3  2  3 0.014675 0.014676 0.01
[1] " "
     Dir D d3 d2 m3        lB        uB     P
[1,]   1 4  3  2  3 0.0022011 0.0022012 0.001
[1] " "
     Dir D d3 d2 m3         lB         uB     P
[1,]   1 4  3  2  3 0.00065425 0.00065426 1e-04
[1] " "
     Dir D d3 d2 m3      lB     uB   P
[1,]   1 5  3  2  3 0.41429 0.4143 0.1
[1] " "
     Dir D d3 d2 m3      lB      uB    P
[1,]   1 5  3  2  3 0.01407 0.01407 0.01
[1] " "
     Dir D d3 d2 m3        lB        uB     P
[1,]   1 5  3  2  3 0.0021103 0.0021103 0.001
[1] " "
     Dir D d3 d2 m3         lB         uB     P
[1,]   1 5  3  2  3 0.00062725 0.00062729 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 62
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m3      lB      uB   P
[1,]   1 2  2  3 0.51306 0.51309 0.1
[1] " "
     Dir D d2 m3       lB       uB    P
[1,]   1 2  2  3 0.016971 0.016971 0.01
[1] " "
     Dir D d2 m3        lB        uB     P
[1,]   1 2  2  3 0.0025455 0.0025455 0.001
[1] " "
     Dir D d2 m3        lB         uB     P
[1,]   1 2  2  3 0.0007566 0.00075662 1e-04
[1] " "
     Dir D d2 m3      lB      uB   P
[1,]   1 3  2  3 0.46515 0.46517 0.1
[1] " "
     Dir D d2 m3       lB       uB    P
[1,]   1 3  2  3 0.015346 0.015346 0.01
[1] " "
     Dir D d2 m3        lB        uB     P
[1,]   1 3  2  3 0.0023017 0.0023017 0.001
[1] " "
     Dir D d2 m3         lB         uB     P
[1,]   1 3  2  3 0.00068414 0.00068414 1e-04
[1] " "
     Dir D d2 m3      lB      uB   P
[1,]   1 4  2  3 0.34637 0.39463 0.1
[1] " "
     Dir D d2 m3       lB       uB    P
[1,]   1 4  2  3 0.014425 0.014426 0.01
[1] " "
     Dir D d2 m3        lB        uB     P
[1,]   1 4  2  3 0.0021636 0.0021636 0.001
[1] " "
     Dir D d2 m3        lB        uB     P
[1,]   1 4  2  3 0.0006431 0.0006431 1e-04
[1] " "
     Dir D d2 m3     lB      uB   P
[1,]   1 5  2  3 0.1829 0.28982 0.1
[1] " "
     Dir D d2 m3      lB      uB    P
[1,]   1 5  2  3 0.01383 0.01383 0.01
[1] " "
     Dir D d2 m3        lB        uB     P
[1,]   1 5  2  3 0.0020743 0.0020743 0.001
[1] " "
     Dir D d2 m3         lB         uB     P
[1,]   1 5  2  3 0.00061656 0.00061659 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 63
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m3      lB      uB   P
[1,]   1 3  3  3 0.46516 0.46519 0.1
[1] " "
     Dir D d3 m3       lB       uB    P
[1,]   1 3  3  3 0.015346 0.015347 0.01
[1] " "
     Dir D d3 m3        lB        uB     P
[1,]   1 3  3  3 0.0023017 0.0023017 0.001
[1] " "
     Dir D d3 m3         lB         uB     P
[1,]   1 3  3  3 0.00068414 0.00068414 1e-04
[1] " "
     Dir D d3 m3      lB     uB   P
[1,]   1 4  3  3 0.43718 0.4372 0.1
[1] " "
     Dir D d3 m3       lB       uB    P
[1,]   1 4  3  3 0.014425 0.014425 0.01
[1] " "
     Dir D d3 m3        lB        uB     P
[1,]   1 4  3  3 0.0021636 0.0021636 0.001
[1] " "
     Dir D d3 m3        lB         uB     P
[1,]   1 4  3  3 0.0006431 0.00064311 1e-04
[1] " "
     Dir D d3 m3      lB      uB   P
[1,]   1 5  3  3 0.41879 0.41882 0.1
[1] " "
     Dir D d3 m3      lB      uB    P
[1,]   1 5  3  3 0.01383 0.01383 0.01
[1] " "
     Dir D d3 m3        lB        uB     P
[1,]   1 5  3  3 0.0020743 0.0020745 0.001
[1] " "
     Dir D d3 m3         lB         uB     P
[1,]   1 5  3  3 0.00061656 0.00061656 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 64
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m3 lB uB   P
[1,]   1 0  3  1  1 0.1
[1] " "
     Dir D m3       lB       uB    P
[1,]   1 0  3 0.047086 0.047086 0.01
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 0  3 0.0070625 0.0070625 0.001
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 0  3 0.0020992 0.0020992 1e-04
[1] " "
     Dir D m3      lB      uB   P
[1,]   1 1  3 0.60951 0.60952 0.1
[1] " "
     Dir D m3       lB       uB    P
[1,]   1 1  3 0.019865 0.019865 0.01
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 1  3 0.0029795 0.0029795 0.001
[1] " "
     Dir D m3        lB         uB     P
[1,]   1 1  3 0.0008856 0.00088567 1e-04
[1] " "
     Dir D m3      lB      uB   P
[1,]   1 2  3 0.29936 0.47381 0.1
[1] " "
     Dir D m3       lB       uB    P
[1,]   1 2  3 0.016273 0.016274 0.01
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 2  3 0.0024408 0.0024408 0.001
[1] " "
     Dir D m3         lB         uB     P
[1,]   1 2  3 0.00072549 0.00072551 1e-04
[1] " "
     Dir D m3      lB      uB   P
[1,]   1 3  3 0.11653 0.24631 0.1
[1] " "
     Dir D m3       lB       uB    P
[1,]   1 3  3 0.014714 0.014715 0.01
[1] " "
     Dir D m3       lB       uB     P
[1,]   1 3  3 0.002207 0.002207 0.001
[1] " "
     Dir D m3       lB       uB     P
[1,]   1 3  3 0.000656 0.000656 1e-04
[1] " "
     Dir D m3       lB      uB   P
[1,]   1 4  3 0.033197 0.06078 0.1
[1] " "
     Dir D m3       lB       uB    P
[1,]   1 4  3 0.010398 0.013037 0.01
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 4  3 0.0020746 0.0020747 0.001
[1] " "
     Dir D m3         lB         uB     P
[1,]   1 4  3 0.00061665 0.00061665 1e-04
[1] " "
     Dir D m3        lB        uB   P
[1,]   1 5  3 0.0070911 0.0098559 0.1
[1] " "
     Dir D m3        lB        uB    P
[1,]   1 5  3 0.0039985 0.0059347 0.01
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 5  3 0.0016651 0.0019148 0.001
[1] " "
     Dir D m3        lB        uB     P
[1,]   1 5  3 0.0005912 0.0005912 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 65
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m1 m2      lB      uB   P
[1,]   1 3  3  2  1  0  1  2 0.14177 0.14177 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2      lB       uB    P
[1,]   1 3  3  2  1  0  1  2 0.02024 0.020242 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 3  3  2  1  0  1  2 0.0055998 0.0056001 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB       uB     P
[1,]   1 3  3  2  1  0  1  2 0.0024268 0.002427 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m2     lB      uB   P
[1,]   1 4  3  2  1  0  1  2 0.1382 0.13821 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2       lB      uB    P
[1,]   1 4  3  2  1  0  1  2 0.019269 0.01927 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  3  2  1  0  1  2 0.0053137 0.0053139 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  3  2  1  0  1  2 0.0023023 0.0023025 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1 m2      lB      uB   P
[1,]   1 5  3  2  1  0  1  2 0.13593 0.13594 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1 m2       lB       uB    P
[1,]   1 5  3  2  1  0  1  2 0.018607 0.018609 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  0  1  2 0.0051301 0.0051306 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  0  1  2 0.0022226 0.0022227 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 66
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m1 m2      lB      uB   P
[1,]   1 2  2  1  0  1  2 0.14757 0.14757 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2       lB       uB    P
[1,]   1 2  2  1  0  1  2 0.021188 0.021188 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 2  2  1  0  1  2 0.0058866 0.0058871 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2       lB        uB     P
[1,]   1 2  2  1  0  1  2 0.002538 0.0025382 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2     lB      uB   P
[1,]   1 3  2  1  0  1  2 0.1412 0.14121 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2       lB       uB    P
[1,]   1 3  2  1  0  1  2 0.019505 0.019506 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 3  2  1  0  1  2 0.0053922 0.0053925 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 3  2  1  0  1  2 0.0023221 0.0023222 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2      lB      uB   P
[1,]   1 4  2  1  0  1  2 0.13765 0.13767 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2       lB       uB    P
[1,]   1 4  2  1  0  1  2 0.018479 0.018566 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  2  1  0  1  2 0.0050339 0.0050747 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  2  1  0  1  2 0.0022009 0.0022014 1e-04
[1] " "
     Dir D d2 d1 m0 m1 m2     lB      uB   P
[1,]   1 5  2  1  0  1  2 0.1354 0.13541 0.1
[1] " "
     Dir D d2 d1 m0 m1 m2       lB      uB    P
[1,]   1 5  2  1  0  1  2 0.016855 0.01703 0.01
[1] " "
     Dir D d2 d1 m0 m1 m2        lB        uB     P
[1,]   1 5  2  1  0  1  2 0.0044359 0.0045619 0.001
[1] " "
     Dir D d2 d1 m0 m1 m2        lB       uB     P
[1,]   1 5  2  1  0  1  2 0.0019568 0.002006 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 67
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m1 m2     lB      uB   P
[1,]   1 3  3  1  0  1  2 0.1412 0.14121 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2       lB       uB    P
[1,]   1 3  3  1  0  1  2 0.019521 0.019523 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 3  3  1  0  1  2 0.0053923 0.0053926 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 3  3  1  0  1  2 0.0023221 0.0023222 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m2      lB      uB   P
[1,]   1 4  3  1  0  1  2 0.13766 0.13767 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2       lB       uB    P
[1,]   1 4  3  1  0  1  2 0.018581 0.018583 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  3  1  0  1  2 0.0051154 0.0051159 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 4  3  1  0  1  2 0.0022014 0.0022015 1e-04
[1] " "
     Dir D d3 d1 m0 m1 m2     lB      uB   P
[1,]   1 5  3  1  0  1  2 0.1354 0.13541 0.1
[1] " "
     Dir D d3 d1 m0 m1 m2       lB       uB    P
[1,]   1 5  3  1  0  1  2 0.017924 0.017934 0.01
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 5  3  1  0  1  2 0.0049377 0.0049381 0.001
[1] " "
     Dir D d3 d1 m0 m1 m2        lB        uB     P
[1,]   1 5  3  1  0  1  2 0.0021241 0.0021242 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 68
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m1 m2      lB      uB   P
[1,]   1 1  1  0  1  2 0.16171 0.16172 0.1
[1] " "
     Dir D d1 m0 m1 m2       lB       uB    P
[1,]   1 1  1  0  1  2 0.024937 0.024938 0.01
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 1  1  0  1  2 0.0069678 0.0069683 0.001
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 1  1  0  1  2 0.0030146 0.0030147 1e-04
[1] " "
     Dir D d1 m0 m1 m2      lB      uB   P
[1,]   1 2  1  0  1  2 0.14671 0.14672 0.1
[1] " "
     Dir D d1 m0 m1 m2       lB       uB    P
[1,]   1 2  1  0  1  2 0.021017 0.021018 0.01
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 2  1  0  1  2 0.0058358 0.0058359 0.001
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 2  1  0  1  2 0.0025095 0.0025095 1e-04
[1] " "
     Dir D d1 m0 m1 m2      lB      uB   P
[1,]   1 3  1  0  1  2 0.14032 0.14034 0.1
[1] " "
     Dir D d1 m0 m1 m2       lB       uB    P
[1,]   1 3  1  0  1  2 0.019182 0.019334 0.01
[1] " "
     Dir D d1 m0 m1 m2       lB        uB     P
[1,]   1 3  1  0  1  2 0.004935 0.0050387 0.001
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 3  1  0  1  2 0.0021373 0.0022259 1e-04
[1] " "
     Dir D d1 m0 m1 m2      lB      uB   P
[1,]   1 4  1  0  1  2 0.13652 0.13655 0.1
[1] " "
     Dir D d1 m0 m1 m2      lB      uB    P
[1,]   1 4  1  0  1  2 0.01642 0.01748 0.01
[1] " "
     Dir D d1 m0 m1 m2        lB       uB     P
[1,]   1 4  1  0  1  2 0.0032404 0.004368 0.001
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 4  1  0  1  2 0.0013523 0.0019172 1e-04
[1] " "
     Dir D d1 m0 m1 m2      lB      uB   P
[1,]   1 5  1  0  1  2 0.13074 0.13191 0.1
[1] " "
     Dir D d1 m0 m1 m2       lB       uB    P
[1,]   1 5  1  0  1  2 0.013684 0.014302 0.01
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 5  1  0  1  2 0.0033456 0.0044871 0.001
[1] " "
     Dir D d1 m0 m1 m2        lB        uB     P
[1,]   1 5  1  0  1  2 0.0014291 0.0019714 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 69
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m1 m2     lB      uB   P
[1,]   1 3  3  2  0  1  2 0.1412 0.14121 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2       lB       uB    P
[1,]   1 3  3  2  0  1  2 0.019505 0.019506 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2        lB        uB     P
[1,]   1 3  3  2  0  1  2 0.0054328 0.0054333 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2        lB        uB     P
[1,]   1 3  3  2  0  1  2 0.0023492 0.0023494 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m2      lB      uB   P
[1,]   1 4  3  2  0  1  2 0.13766 0.13766 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2       lB       uB    P
[1,]   1 4  3  2  0  1  2 0.018567 0.018568 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2        lB        uB     P
[1,]   1 4  3  2  0  1  2 0.0051461 0.0051464 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2       lB        uB     P
[1,]   1 4  3  2  0  1  2 0.002223 0.0022231 1e-04
[1] " "
     Dir D d3 d2 m0 m1 m2     lB      uB   P
[1,]   1 5  3  2  0  1  2 0.1354 0.13541 0.1
[1] " "
     Dir D d3 d2 m0 m1 m2       lB       uB    P
[1,]   1 5  3  2  0  1  2 0.017922 0.017923 0.01
[1] " "
     Dir D d3 d2 m0 m1 m2        lB        uB     P
[1,]   1 5  3  2  0  1  2 0.0049423 0.0049534 0.001
[1] " "
     Dir D d3 d2 m0 m1 m2        lB       uB     P
[1,]   1 5  3  2  0  1  2 0.0021419 0.002142 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 70
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m1 m2      lB      uB   P
[1,]   1 2  2  0  1  2 0.14671 0.14672 0.1
[1] " "
     Dir D d2 m0 m1 m2       lB       uB    P
[1,]   1 2  2  0  1  2 0.021026 0.021027 0.01
[1] " "
     Dir D d2 m0 m1 m2       lB        uB     P
[1,]   1 2  2  0  1  2 0.005874 0.0058745 0.001
[1] " "
     Dir D d2 m0 m1 m2       lB        uB     P
[1,]   1 2  2  0  1  2 0.002541 0.0025412 1e-04
[1] " "
     Dir D d2 m0 m1 m2      lB      uB   P
[1,]   1 3  2  0  1  2 0.14034 0.14034 0.1
[1] " "
     Dir D d2 m0 m1 m2       lB       uB    P
[1,]   1 3  2  0  1  2 0.019345 0.019347 0.01
[1] " "
     Dir D d2 m0 m1 m2       lB        uB     P
[1,]   1 3  2  0  1  2 0.005385 0.0053854 0.001
[1] " "
     Dir D d2 m0 m1 m2        lB        uB     P
[1,]   1 3  2  0  1  2 0.0023231 0.0023233 1e-04
[1] " "
     Dir D d2 m0 m1 m2     lB      uB   P
[1,]   1 4  2  0  1  2 0.1368 0.13681 0.1
[1] " "
     Dir D d2 m0 m1 m2       lB       uB    P
[1,]   1 4  2  0  1  2 0.018323 0.018353 0.01
[1] " "
     Dir D d2 m0 m1 m2        lB       uB     P
[1,]   1 4  2  0  1  2 0.0049846 0.005032 0.001
[1] " "
     Dir D d2 m0 m1 m2        lB        uB     P
[1,]   1 4  2  0  1  2 0.0021973 0.0021974 1e-04
[1] " "
     Dir D d2 m0 m1 m2      lB      uB   P
[1,]   1 5  2  0  1  2 0.13456 0.13456 0.1
[1] " "
     Dir D d2 m0 m1 m2       lB       uB    P
[1,]   1 5  2  0  1  2 0.017351 0.017384 0.01
[1] " "
     Dir D d2 m0 m1 m2        lB        uB     P
[1,]   1 5  2  0  1  2 0.0041871 0.0045153 0.001
[1] " "
     Dir D d2 m0 m1 m2        lB        uB     P
[1,]   1 5  2  0  1  2 0.0017584 0.0019861 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 71
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m1 m2      lB      uB   P
[1,]   1 3  3  0  1  2 0.14034 0.14035 0.1
[1] " "
     Dir D d3 m0 m1 m2       lB       uB    P
[1,]   1 3  3  0  1  2 0.019381 0.019381 0.01
[1] " "
     Dir D d3 m0 m1 m2        lB        uB     P
[1,]   1 3  3  0  1  2 0.0054147 0.0054149 0.001
[1] " "
     Dir D d3 m0 m1 m2        lB        uB     P
[1,]   1 3  3  0  1  2 0.0023347 0.0023349 1e-04
[1] " "
     Dir D d3 m0 m1 m2      lB      uB   P
[1,]   1 4  3  0  1  2 0.13681 0.13681 0.1
[1] " "
     Dir D d3 m0 m1 m2       lB       uB    P
[1,]   1 4  3  0  1  2 0.018433 0.018434 0.01
[1] " "
     Dir D d3 m0 m1 m2        lB        uB     P
[1,]   1 4  3  0  1  2 0.0051411 0.0051414 0.001
[1] " "
     Dir D d3 m0 m1 m2        lB        uB     P
[1,]   1 4  3  0  1  2 0.0022195 0.0022196 1e-04
[1] " "
     Dir D d3 m0 m1 m2      lB      uB   P
[1,]   1 5  3  0  1  2 0.13456 0.13457 0.1
[1] " "
     Dir D d3 m0 m1 m2       lB       uB    P
[1,]   1 5  3  0  1  2 0.017773 0.017779 0.01
[1] " "
     Dir D d3 m0 m1 m2        lB       uB     P
[1,]   1 5  3  0  1  2 0.0048981 0.004958 0.001
[1] " "
     Dir D d3 m0 m1 m2       lB        uB     P
[1,]   1 5  3  0  1  2 0.002118 0.0021236 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 72
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m1 m2      lB      uB   P
[1,]   1 0  0  1  2 0.23957 0.23957 0.1
[1] " "
     Dir D m0 m1 m2       lB       uB    P
[1,]   1 0  0  1  2 0.055672 0.055672 0.01
[1] " "
     Dir D m0 m1 m2       lB       uB     P
[1,]   1 0  0  1  2 0.015578 0.015579 0.001
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 0  0  1  2 0.0067683 0.0067687 1e-04
[1] " "
     Dir D m0 m1 m2      lB      uB   P
[1,]   1 1  0  1  2 0.15905 0.15906 0.1
[1] " "
     Dir D m0 m1 m2       lB       uB    P
[1,]   1 1  0  1  2 0.024743 0.024744 0.01
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 1  0  1  2 0.0069023 0.0069028 0.001
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 1  0  1  2 0.0029712 0.0029715 1e-04
[1] " "
     Dir D m0 m1 m2      lB      uB   P
[1,]   1 2  0  1  2 0.11589 0.14204 0.1
[1] " "
     Dir D m0 m1 m2       lB       uB    P
[1,]   1 2  0  1  2 0.020877 0.020877 0.01
[1] " "
     Dir D m0 m1 m2        lB       uB     P
[1,]   1 2  0  1  2 0.0057513 0.005757 0.001
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 2  0  1  2 0.0023512 0.0023711 1e-04
[1] " "
     Dir D m0 m1 m2      lB      uB   P
[1,]   1 3  0  1  2 0.11176 0.13207 0.1
[1] " "
     Dir D m0 m1 m2      lB       uB    P
[1,]   1 3  0  1  2 0.01812 0.019099 0.01
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 3  0  1  2 0.0047478 0.0049838 0.001
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 3  0  1  2 0.0017361 0.0020283 1e-04
[1] " "
     Dir D m0 m1 m2       lB      uB   P
[1,]   1 4  0  1  2 0.046941 0.13014 0.1
[1] " "
     Dir D m0 m1 m2       lB       uB    P
[1,]   1 4  0  1  2 0.016886 0.018235 0.01
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 4  0  1  2 0.0043069 0.0047895 0.001
[1] " "
     Dir D m0 m1 m2         lB        uB     P
[1,]   1 4  0  1  2 0.00075745 0.0016911 1e-04
[1] " "
     Dir D m0 m1 m2       lB      uB   P
[1,]   1 5  0  1  2 0.057132 0.13081 0.1
[1] " "
     Dir D m0 m1 m2      lB       uB    P
[1,]   1 5  0  1  2 0.01744 0.017741 0.01
[1] " "
     Dir D m0 m1 m2        lB        uB     P
[1,]   1 5  0  1  2 0.0037083 0.0040449 0.001
[1] " "
     Dir D m0 m1 m2         lB        uB     P
[1,]   1 5  0  1  2 0.00091781 0.0016569 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 73
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m1 m2      lB      uB   P
[1,]   1 3  3  2  1  1  2 0.15442 0.15442 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2       lB       uB    P
[1,]   1 3  3  2  1  1  2 0.019585 0.019586 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2        lB       uB     P
[1,]   1 3  3  2  1  1  2 0.0054436 0.005444 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2        lB        uB     P
[1,]   1 3  3  2  1  1  2 0.0023221 0.0023222 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m2      lB      uB   P
[1,]   1 4  3  2  1  1  2 0.14975 0.14976 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2       lB       uB    P
[1,]   1 4  3  2  1  1  2 0.018652 0.018653 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2        lB        uB     P
[1,]   1 4  3  2  1  1  2 0.0051801 0.0051804 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2        lB        uB     P
[1,]   1 4  3  2  1  1  2 0.0022014 0.0022015 1e-04
[1] " "
     Dir D d3 d2 d1 m1 m2      lB      uB   P
[1,]   1 5  3  2  1  1  2 0.14674 0.14675 0.1
[1] " "
     Dir D d3 d2 d1 m1 m2       lB       uB    P
[1,]   1 5  3  2  1  1  2 0.018038 0.018047 0.01
[1] " "
     Dir D d3 d2 d1 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  1  2 0.0050036 0.0050089 0.001
[1] " "
     Dir D d3 d2 d1 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  1  2 0.0021241 0.0021242 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 74
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m1 m2      lB      uB   P
[1,]   1 2  2  1  1  2 0.16149 0.16149 0.1
[1] " "
     Dir D d2 d1 m1 m2      lB       uB    P
[1,]   1 2  2  1  1  2 0.02109 0.021092 0.01
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 2  2  1  1  2 0.0058575 0.0058577 0.001
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 2  2  1  1  2 0.0025094 0.0025096 1e-04
[1] " "
     Dir D d2 d1 m1 m2      lB      uB   P
[1,]   1 3  2  1  1  2 0.15327 0.15328 0.1
[1] " "
     Dir D d2 d1 m1 m2       lB       uB    P
[1,]   1 3  2  1  1  2 0.019436 0.019436 0.01
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 3  2  1  1  2 0.0053874 0.0053878 0.001
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 3  2  1  1  2 0.0022946 0.0022947 1e-04
[1] " "
     Dir D d2 d1 m1 m2      lB      uB   P
[1,]   1 4  2  1  1  2 0.14865 0.14866 0.1
[1] " "
     Dir D d2 d1 m1 m2       lB       uB    P
[1,]   1 4  2  1  1  2 0.018485 0.018496 0.01
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 4  2  1  1  2 0.0051253 0.0051254 0.001
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 4  2  1  1  2 0.0021739 0.0021739 1e-04
[1] " "
     Dir D d2 d1 m1 m2      lB      uB   P
[1,]   1 5  2  1  1  2 0.14497 0.14541 0.1
[1] " "
     Dir D d2 d1 m1 m2       lB       uB    P
[1,]   1 5  2  1  1  2 0.016561 0.016875 0.01
[1] " "
     Dir D d2 d1 m1 m2       lB        uB     P
[1,]   1 5  2  1  1  2 0.004349 0.0046381 0.001
[1] " "
     Dir D d2 d1 m1 m2        lB        uB     P
[1,]   1 5  2  1  1  2 0.0019185 0.0020239 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 75
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m1 m2      lB      uB   P
[1,]   1 3  3  1  1  2 0.15327 0.15328 0.1
[1] " "
     Dir D d3 d1 m1 m2       lB       uB    P
[1,]   1 3  3  1  1  2 0.019434 0.019435 0.01
[1] " "
     Dir D d3 d1 m1 m2        lB        uB     P
[1,]   1 3  3  1  1  2 0.0053875 0.0053878 0.001
[1] " "
     Dir D d3 d1 m1 m2        lB        uB     P
[1,]   1 3  3  1  1  2 0.0022946 0.0022948 1e-04
[1] " "
     Dir D d3 d1 m1 m2      lB      uB   P
[1,]   1 4  3  1  1  2 0.14866 0.14867 0.1
[1] " "
     Dir D d3 d1 m1 m2       lB       uB    P
[1,]   1 4  3  1  1  2 0.018507 0.018509 0.01
[1] " "
     Dir D d3 d1 m1 m2        lB       uB     P
[1,]   1 4  3  1  1  2 0.0051258 0.005126 0.001
[1] " "
     Dir D d3 d1 m1 m2        lB        uB     P
[1,]   1 4  3  1  1  2 0.0021746 0.0021746 1e-04
[1] " "
     Dir D d3 d1 m1 m2      lB      uB   P
[1,]   1 5  3  1  1  2 0.14568 0.14569 0.1
[1] " "
     Dir D d3 d1 m1 m2       lB       uB    P
[1,]   1 5  3  1  1  2 0.017896 0.017907 0.01
[1] " "
     Dir D d3 d1 m1 m2        lB        uB     P
[1,]   1 5  3  1  1  2 0.0049528 0.0049567 0.001
[1] " "
     Dir D d3 d1 m1 m2        lB        uB     P
[1,]   1 5  3  1  1  2 0.0020977 0.0020978 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 76
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m1 m2      lB      uB   P
[1,]   1 1  1  1  2 0.17823 0.17823 0.1
[1] " "
     Dir D d1 m1 m2       lB       uB    P
[1,]   1 1  1  1  2 0.024743 0.024743 0.01
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 1  1  1  2 0.0068671 0.0068676 0.001
[1] " "
     Dir D d1 m1 m2        lB       uB     P
[1,]   1 1  1  1  2 0.0029648 0.002965 1e-04
[1] " "
     Dir D d1 m1 m2      lB      uB   P
[1,]   1 2  1  1  2 0.15842 0.15842 0.1
[1] " "
     Dir D d1 m1 m2       lB       uB    P
[1,]   1 2  1  1  2 0.020877 0.020879 0.01
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 2  1  1  2 0.0057647 0.0057652 0.001
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 2  1  1  2 0.0024626 0.0024627 1e-04
[1] " "
     Dir D d1 m1 m2      lB      uB   P
[1,]   1 3  1  1  2 0.14528 0.14918 0.1
[1] " "
     Dir D d1 m1 m2      lB      uB    P
[1,]   1 3  1  1  2 0.01924 0.01924 0.01
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 3  1  1  2 0.0052442 0.0052566 0.001
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 3  1  1  2 0.0021723 0.0021898 1e-04
[1] " "
     Dir D d1 m1 m2       lB      uB   P
[1,]   1 4  1  1  2 0.095171 0.12359 0.1
[1] " "
     Dir D d1 m1 m2       lB       uB    P
[1,]   1 4  1  1  2 0.018328 0.018328 0.01
[1] " "
     Dir D d1 m1 m2        lB       uB     P
[1,]   1 4  1  1  2 0.0048612 0.004925 0.001
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 4  1  1  2 0.0018177 0.0018556 1e-04
[1] " "
     Dir D d1 m1 m2       lB       uB   P
[1,]   1 5  1  1  2 0.052575 0.089691 0.1
[1] " "
     Dir D d1 m1 m2       lB       uB    P
[1,]   1 5  1  1  2 0.016784 0.017531 0.01
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 5  1  1  2 0.0044026 0.0045479 0.001
[1] " "
     Dir D d1 m1 m2        lB        uB     P
[1,]   1 5  1  1  2 0.0010637 0.0013987 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 77
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m1 m2      lB      uB   P
[1,]   1 3  3  2  1  2 0.15329 0.15329 0.1
[1] " "
     Dir D d3 d2 m1 m2       lB      uB    P
[1,]   1 3  3  2  1  2 0.019439 0.01944 0.01
[1] " "
     Dir D d3 d2 m1 m2        lB        uB     P
[1,]   1 3  3  2  1  2 0.0053939 0.0053941 0.001
[1] " "
     Dir D d3 d2 m1 m2        lB        uB     P
[1,]   1 3  3  2  1  2 0.0023233 0.0023234 1e-04
[1] " "
     Dir D d3 d2 m1 m2      lB      uB   P
[1,]   1 4  3  2  1  2 0.14883 0.14883 0.1
[1] " "
     Dir D d3 d2 m1 m2       lB       uB    P
[1,]   1 4  3  2  1  2 0.018518 0.018518 0.01
[1] " "
     Dir D d3 d2 m1 m2       lB        uB     P
[1,]   1 4  3  2  1  2 0.005127 0.0051273 0.001
[1] " "
     Dir D d3 d2 m1 m2        lB        uB     P
[1,]   1 4  3  2  1  2 0.0021973 0.0021974 1e-04
[1] " "
     Dir D d3 d2 m1 m2      lB      uB   P
[1,]   1 5  3  2  1  2 0.14602 0.14602 0.1
[1] " "
     Dir D d3 d2 m1 m2       lB       uB    P
[1,]   1 5  3  2  1  2 0.017929 0.017929 0.01
[1] " "
     Dir D d3 d2 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  2 0.0049497 0.0049531 0.001
[1] " "
     Dir D d3 d2 m1 m2        lB        uB     P
[1,]   1 5  3  2  1  2 0.0021167 0.0021168 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 78
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m1 m2      lB      uB   P
[1,]   1 2  2  1  2 0.15842 0.15842 0.1
[1] " "
     Dir D d2 m1 m2       lB       uB    P
[1,]   1 2  2  1  2 0.020877 0.020877 0.01
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 2  2  1  2 0.0057901 0.0057905 0.001
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 2  2  1  2 0.0025102 0.0025103 1e-04
[1] " "
     Dir D d2 m1 m2      lB      uB   P
[1,]   1 3  2  1  2 0.15038 0.15038 0.1
[1] " "
     Dir D d2 m1 m2      lB      uB    P
[1,]   1 3  2  1  2 0.01924 0.01924 0.01
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 3  2  1  2 0.0053105 0.0053109 0.001
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 3  2  1  2 0.0022833 0.0022835 1e-04
[1] " "
     Dir D d2 m1 m2    lB    uB   P
[1,]   1 4  2  1  2 0.146 0.146 0.1
[1] " "
     Dir D d2 m1 m2       lB       uB    P
[1,]   1 4  2  1  2 0.018328 0.018328 0.01
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 4  2  1  2 0.0050158 0.0050334 0.001
[1] " "
     Dir D d2 m1 m2       lB        uB     P
[1,]   1 4  2  1  2 0.002116 0.0021177 1e-04
[1] " "
     Dir D d2 m1 m2      lB      uB   P
[1,]   1 5  2  1  2 0.13772 0.14028 0.1
[1] " "
     Dir D d2 m1 m2       lB       uB    P
[1,]   1 5  2  1  2 0.017745 0.017745 0.01
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 5  2  1  2 0.0047614 0.0047619 0.001
[1] " "
     Dir D d2 m1 m2        lB        uB     P
[1,]   1 5  2  1  2 0.0019331 0.0019365 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 79
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m1 m2      lB      uB   P
[1,]   1 3  3  1  2 0.15038 0.15038 0.1
[1] " "
     Dir D d3 m1 m2      lB      uB    P
[1,]   1 3  3  1  2 0.01924 0.01924 0.01
[1] " "
     Dir D d3 m1 m2        lB        uB     P
[1,]   1 3  3  1  2 0.0053379 0.0053383 0.001
[1] " "
     Dir D d3 m1 m2        lB        uB     P
[1,]   1 3  3  1  2 0.0023209 0.0023211 1e-04
[1] " "
     Dir D d3 m1 m2    lB    uB   P
[1,]   1 4  3  1  2 0.146 0.146 0.1
[1] " "
     Dir D d3 m1 m2       lB       uB    P
[1,]   1 4  3  1  2 0.018328 0.018329 0.01
[1] " "
     Dir D d3 m1 m2        lB        uB     P
[1,]   1 4  3  1  2 0.0050628 0.0050632 0.001
[1] " "
     Dir D d3 m1 m2       lB        uB     P
[1,]   1 4  3  1  2 0.002187 0.0021871 1e-04
[1] " "
     Dir D d3 m1 m2      lB      uB   P
[1,]   1 5  3  1  2 0.14325 0.14325 0.1
[1] " "
     Dir D d3 m1 m2       lB       uB    P
[1,]   1 5  3  1  2 0.017745 0.017745 0.01
[1] " "
     Dir D d3 m1 m2        lB        uB     P
[1,]   1 5  3  1  2 0.0048694 0.0048822 0.001
[1] " "
     Dir D d3 m1 m2        lB        uB     P
[1,]   1 5  3  1  2 0.0020766 0.0021006 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 80
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m1 m2      lB      uB   P
[1,]   1 0  1  2 0.34711 0.34711 0.1
[1] " "
     Dir D m1 m2       lB       uB    P
[1,]   1 0  1  2 0.052655 0.052655 0.01
[1] " "
     Dir D m1 m2       lB      uB     P
[1,]   1 0  1  2 0.014809 0.01481 0.001
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 0  1  2 0.0065524 0.0065527 1e-04
[1] " "
     Dir D m1 m2      lB      uB   P
[1,]   1 1  1  2 0.17355 0.17355 0.1
[1] " "
     Dir D m1 m2       lB       uB    P
[1,]   1 1  1  2 0.023402 0.023402 0.01
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 1  1  2 0.0065737 0.0065743 0.001
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 1  1  2 0.0029019 0.0029021 1e-04
[1] " "
     Dir D m1 m2      lB      uB   P
[1,]   1 2  1  2 0.15427 0.15427 0.1
[1] " "
     Dir D m1 m2       lB       uB    P
[1,]   1 2  1  2 0.019746 0.019746 0.01
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 2  1  2 0.0055172 0.0055281 0.001
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 2  1  2 0.0024063 0.0024147 1e-04
[1] " "
     Dir D m1 m2      lB      uB   P
[1,]   1 3  1  2 0.14291 0.14421 0.1
[1] " "
     Dir D m1 m2       lB       uB    P
[1,]   1 3  1  2 0.018197 0.018198 0.01
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 3  1  2 0.0049647 0.0050003 0.001
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 3  1  2 0.0020425 0.0020714 1e-04
[1] " "
     Dir D m1 m2      lB    uB   P
[1,]   1 4  1  2 0.12443 0.141 0.1
[1] " "
     Dir D m1 m2       lB       uB    P
[1,]   1 4  1  2 0.015606 0.016896 0.01
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 4  1  2 0.0039527 0.0043674 0.001
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 4  1  2 0.0015361 0.0018303 1e-04
[1] " "
     Dir D m1 m2       lB      uB   P
[1,]   1 5  1  2 0.056358 0.13068 0.1
[1] " "
     Dir D m1 m2       lB      uB    P
[1,]   1 5  1  2 0.016516 0.01678 0.01
[1] " "
     Dir D m1 m2        lB        uB     P
[1,]   1 5  1  2 0.0033439 0.0033623 0.001
[1] " "
     Dir D m1 m2         lB        uB     P
[1,]   1 5  1  2 0.00063736 0.0014616 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 81
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m2     lB     uB   P
[1,]   1 3  3  2  1  0  2 0.1512 0.1512 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2       lB       uB    P
[1,]   1 3  3  2  1  0  2 0.019505 0.019507 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2        lB        uB     P
[1,]   1 3  3  2  1  0  2 0.0053923 0.0053925 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2       lB       uB     P
[1,]   1 3  3  2  1  0  2 0.002381 0.002381 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m2      lB      uB   P
[1,]   1 4  3  2  1  0  2 0.14633 0.14633 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2       lB       uB    P
[1,]   1 4  3  2  1  0  2 0.018567 0.018568 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2        lB        uB     P
[1,]   1 4  3  2  1  0  2 0.0051154 0.0051158 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2        lB        uB     P
[1,]   1 4  3  2  1  0  2 0.0022543 0.0022545 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m2      lB      uB   P
[1,]   1 5  3  2  1  0  2 0.14298 0.14299 0.1
[1] " "
     Dir D d3 d2 d1 m0 m2       lB       uB    P
[1,]   1 5  3  2  1  0  2 0.017924 0.017935 0.01
[1] " "
     Dir D d3 d2 d1 m0 m2        lB        uB     P
[1,]   1 5  3  2  1  0  2 0.0049377 0.0049381 0.001
[1] " "
     Dir D d3 d2 d1 m0 m2        lB        uB     P
[1,]   1 5  3  2  1  0  2 0.0021727 0.0021729 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 82
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m2      lB      uB   P
[1,]   1 2  2  1  0  2 0.15897 0.15898 0.1
[1] " "
     Dir D d2 d1 m0 m2       lB       uB    P
[1,]   1 2  2  1  0  2 0.021018 0.021019 0.01
[1] " "
     Dir D d2 d1 m0 m2        lB        uB     P
[1,]   1 2  2  1  0  2 0.0058358 0.0058363 0.001
[1] " "
     Dir D d2 d1 m0 m2       lB        uB     P
[1,]   1 2  2  1  0  2 0.002583 0.0025831 1e-04
[1] " "
     Dir D d2 d1 m0 m2      lB     uB   P
[1,]   1 3  2  1  0  2 0.15058 0.1506 0.1
[1] " "
     Dir D d2 d1 m0 m2       lB       uB    P
[1,]   1 3  2  1  0  2 0.019346 0.019348 0.01
[1] " "
     Dir D d2 d1 m0 m2        lB        uB     P
[1,]   1 3  2  1  0  2 0.0053439 0.0053444 0.001
[1] " "
     Dir D d2 d1 m0 m2        lB        uB     P
[1,]   1 3  2  1  0  2 0.0023591 0.0023593 1e-04
[1] " "
     Dir D d2 d1 m0 m2      lB      uB   P
[1,]   1 4  2  1  0  2 0.14558 0.14559 0.1
[1] " "
     Dir D d2 d1 m0 m2       lB       uB    P
[1,]   1 4  2  1  0  2 0.018318 0.018412 0.01
[1] " "
     Dir D d2 d1 m0 m2        lB       uB     P
[1,]   1 4  2  1  0  2 0.0049846 0.005032 0.001
[1] " "
     Dir D d2 d1 m0 m2       lB        uB     P
[1,]   1 4  2  1  0  2 0.002201 0.0022317 1e-04
[1] " "
     Dir D d2 d1 m0 m2      lB      uB   P
[1,]   1 5  2  1  0  2 0.14224 0.14225 0.1
[1] " "
     Dir D d2 d1 m0 m2       lB       uB    P
[1,]   1 5  2  1  0  2 0.016561 0.016875 0.01
[1] " "
     Dir D d2 d1 m0 m2       lB        uB     P
[1,]   1 5  2  1  0  2 0.004349 0.0045165 0.001
[1] " "
     Dir D d2 d1 m0 m2        lB        uB     P
[1,]   1 5  2  1  0  2 0.0019185 0.0019861 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 83
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m2      lB      uB   P
[1,]   1 3  3  1  0  2 0.15037 0.15038 0.1
[1] " "
     Dir D d3 d1 m0 m2       lB       uB    P
[1,]   1 3  3  1  0  2 0.019364 0.019365 0.01
[1] " "
     Dir D d3 d1 m0 m2        lB        uB     P
[1,]   1 3  3  1  0  2 0.0053441 0.0053443 0.001
[1] " "
     Dir D d3 d1 m0 m2        lB        uB     P
[1,]   1 3  3  1  0  2 0.0023591 0.0023592 1e-04
[1] " "
     Dir D d3 d1 m0 m2      lB      uB   P
[1,]   1 4  3  1  0  2 0.14554 0.14554 0.1
[1] " "
     Dir D d3 d1 m0 m2       lB       uB    P
[1,]   1 4  3  1  0  2 0.018434 0.018434 0.01
[1] " "
     Dir D d3 d1 m0 m2        lB        uB     P
[1,]   1 4  3  1  0  2 0.0050685 0.0050687 0.001
[1] " "
     Dir D d3 d1 m0 m2       lB        uB     P
[1,]   1 4  3  1  0  2 0.002233 0.0022332 1e-04
[1] " "
     Dir D d3 d1 m0 m2      lB      uB   P
[1,]   1 5  3  1  0  2 0.14224 0.14225 0.1
[1] " "
     Dir D d3 d1 m0 m2       lB       uB    P
[1,]   1 5  3  1  0  2 0.017776 0.017791 0.01
[1] " "
     Dir D d3 d1 m0 m2        lB       uB     P
[1,]   1 5  3  1  0  2 0.0048915 0.004892 0.001
[1] " "
     Dir D d3 d1 m0 m2        lB       uB     P
[1,]   1 5  3  1  0  2 0.0021518 0.002152 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 84
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m2      lB      uB   P
[1,]   1 1  1  0  2 0.17534 0.17536 0.1
[1] " "
     Dir D d1 m0 m2       lB       uB    P
[1,]   1 1  1  0  2 0.024672 0.024673 0.01
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 1  1  0  2 0.0069042 0.0069048 0.001
[1] " "
     Dir D d1 m0 m2        lB       uB     P
[1,]   1 1  1  0  2 0.0030657 0.003066 1e-04
[1] " "
     Dir D d1 m0 m2      lB      uB   P
[1,]   1 2  1  0  2 0.15735 0.15736 0.1
[1] " "
     Dir D d1 m0 m2       lB       uB    P
[1,]   1 2  1  0  2 0.020788 0.020789 0.01
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 2  1  0  2 0.0057642 0.0057643 0.001
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 2  1  0  2 0.0025502 0.0025503 1e-04
[1] " "
     Dir D d1 m0 m2      lB      uB   P
[1,]   1 3  1  0  2 0.14877 0.14878 0.1
[1] " "
     Dir D d1 m0 m2       lB       uB    P
[1,]   1 3  1  0  2 0.018854 0.018901 0.01
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 3  1  0  2 0.0048393 0.0049711 0.001
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 3  1  0  2 0.0020974 0.0021986 1e-04
[1] " "
     Dir D d1 m0 m2      lB      uB   P
[1,]   1 4  1  0  2 0.14321 0.14365 0.1
[1] " "
     Dir D d1 m0 m2       lB       uB    P
[1,]   1 4  1  0  2 0.016035 0.017233 0.01
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 4  1  0  2 0.0031138 0.0042939 0.001
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 4  1  0  2 0.0012995 0.0018847 1e-04
[1] " "
     Dir D d1 m0 m2      lB      uB   P
[1,]   1 5  1  0  2 0.12965 0.13015 0.1
[1] " "
     Dir D d1 m0 m2       lB       uB    P
[1,]   1 5  1  0  2 0.013426 0.013984 0.01
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 5  1  0  2 0.0032478 0.0044209 0.001
[1] " "
     Dir D d1 m0 m2        lB        uB     P
[1,]   1 5  1  0  2 0.0013874 0.0019424 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 85
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m2      lB      uB   P
[1,]   1 3  3  2  0  2 0.15071 0.15072 0.1
[1] " "
     Dir D d3 d2 m0 m2       lB       uB    P
[1,]   1 3  3  2  0  2 0.019346 0.019348 0.01
[1] " "
     Dir D d3 d2 m0 m2        lB        uB     P
[1,]   1 3  3  2  0  2 0.0053851 0.0053855 0.001
[1] " "
     Dir D d3 d2 m0 m2        lB        uB     P
[1,]   1 3  3  2  0  2 0.0023883 0.0023885 1e-04
[1] " "
     Dir D d3 d2 m0 m2     lB      uB   P
[1,]   1 4  3  2  0  2 0.1456 0.14561 0.1
[1] " "
     Dir D d3 d2 m0 m2       lB       uB    P
[1,]   1 4  3  2  0  2 0.018414 0.018415 0.01
[1] " "
     Dir D d3 d2 m0 m2        lB        uB     P
[1,]   1 4  3  2  0  2 0.0050992 0.0050996 0.001
[1] " "
     Dir D d3 d2 m0 m2        lB        uB     P
[1,]   1 4  3  2  0  2 0.0022577 0.0022578 1e-04
[1] " "
     Dir D d3 d2 m0 m2      lB      uB   P
[1,]   1 5  3  2  0  2 0.14224 0.14225 0.1
[1] " "
     Dir D d3 d2 m0 m2       lB       uB    P
[1,]   1 5  3  2  0  2 0.017773 0.017779 0.01
[1] " "
     Dir D d3 d2 m0 m2        lB        uB     P
[1,]   1 5  3  2  0  2 0.0048981 0.0049077 0.001
[1] " "
     Dir D d3 d2 m0 m2       lB        uB     P
[1,]   1 5  3  2  0  2 0.002167 0.0021704 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 86
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m2      lB      uB   P
[1,]   1 2  2  0  2 0.15735 0.15736 0.1
[1] " "
     Dir D d2 m0 m2       lB       uB    P
[1,]   1 2  2  0  2 0.020802 0.020803 0.01
[1] " "
     Dir D d2 m0 m2        lB        uB     P
[1,]   1 2  2  0  2 0.0058261 0.0058266 0.001
[1] " "
     Dir D d2 m0 m2        lB       uB     P
[1,]   1 2  2  0  2 0.0025888 0.002589 1e-04
[1] " "
     Dir D d2 m0 m2      lB      uB   P
[1,]   1 3  2  0  2 0.14878 0.14878 0.1
[1] " "
     Dir D d2 m0 m2       lB       uB    P
[1,]   1 3  2  0  2 0.019134 0.019136 0.01
[1] " "
     Dir D d2 m0 m2        lB        uB     P
[1,]   1 3  2  0  2 0.0053224 0.0053224 0.001
[1] " "
     Dir D d2 m0 m2        lB      uB     P
[1,]   1 3  2  0  2 0.0023599 0.00236 1e-04
[1] " "
     Dir D d2 m0 m2      lB      uB   P
[1,]   1 4  2  0  2 0.14374 0.14375 0.1
[1] " "
     Dir D d2 m0 m2       lB       uB    P
[1,]   1 4  2  0  2 0.018112 0.018157 0.01
[1] " "
     Dir D d2 m0 m2        lB        uB     P
[1,]   1 4  2  0  2 0.0049192 0.0049737 0.001
[1] " "
     Dir D d2 m0 m2        lB        uB     P
[1,]   1 4  2  0  2 0.0021698 0.0022058 1e-04
[1] " "
     Dir D d2 m0 m2      lB      uB   P
[1,]   1 5  2  0  2 0.14042 0.14043 0.1
[1] " "
     Dir D d2 m0 m2       lB       uB    P
[1,]   1 5  2  0  2 0.017081 0.017086 0.01
[1] " "
     Dir D d2 m0 m2        lB      uB     P
[1,]   1 5  2  0  2 0.0040547 0.00445 0.001
[1] " "
     Dir D d2 m0 m2        lB        uB     P
[1,]   1 5  2  0  2 0.0017028 0.0019574 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 87
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m2      lB      uB   P
[1,]   1 3  3  0  2 0.14878 0.14879 0.1
[1] " "
     Dir D d3 m0 m2       lB       uB    P
[1,]   1 3  3  0  2 0.019172 0.019173 0.01
[1] " "
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 3  3  0  2 0.0053748 0.0053751 0.001
[1] " "
[1] "Cycle"
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 3  3  0  2 0.0023893 0.0023897 1e-04
[1] " "
     Dir D d3 m0 m2      lB      uB   P
[1,]   1 4  3  0  2 0.14374 0.14375 0.1
[1] " "
     Dir D d3 m0 m2      lB      uB    P
[1,]   1 4  3  0  2 0.01823 0.01823 0.01
[1] " "
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 4  3  0  2 0.0050846 0.0050849 0.001
[1] " "
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 4  3  0  2 0.0022572 0.0022573 1e-04
[1] " "
     Dir D d3 m0 m2      lB      uB   P
[1,]   1 5  3  0  2 0.14043 0.14043 0.1
[1] " "
     Dir D d3 m0 m2       lB       uB    P
[1,]   1 5  3  0  2 0.017566 0.017585 0.01
[1] " "
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 5  3  0  2 0.0048301 0.0048349 0.001
[1] " "
     Dir D d3 m0 m2        lB        uB     P
[1,]   1 5  3  0  2 0.0021361 0.0021401 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 88
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m2      lB      uB   P
[1,]   1 0  0  2 0.23695 0.23695 0.1
[1] " "
     Dir D m0 m2       lB       uB    P
[1,]   1 0  0  2 0.052655 0.052655 0.01
[1] " "
     Dir D m0 m2       lB       uB     P
[1,]   1 0  0  2 0.014864 0.014864 0.001
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 0  0  2 0.0066203 0.0066203 1e-04
[1] " "
     Dir D m0 m2      lB      uB   P
[1,]   1 1  0  2 0.17198 0.17199 0.1
[1] " "
     Dir D m0 m2       lB       uB    P
[1,]   1 1  0  2 0.023402 0.023402 0.01
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 1  0  2 0.0066064 0.0066064 0.001
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 1  0  2 0.0029424 0.0029424 1e-04
[1] " "
     Dir D m0 m2       lB      uB   P
[1,]   1 2  0  2 0.088882 0.10761 0.1
[1] " "
     Dir D m0 m2       lB       uB    P
[1,]   1 2  0  2 0.019746 0.019746 0.01
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 2  0  2 0.0055741 0.0055746 0.001
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 2  0  2 0.0024826 0.0024826 1e-04
[1] " "
     Dir D m0 m2       lB      uB   P
[1,]   1 3  0  2 0.032852 0.11269 0.1
[1] " "
     Dir D m0 m2       lB       uB    P
[1,]   1 3  0  2 0.015282 0.017592 0.01
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 3  0  2 0.0051371 0.0051372 0.001
[1] " "
     Dir D m0 m2       lB       uB     P
[1,]   1 3  0  2 0.002288 0.002288 1e-04
[1] " "
     Dir D m0 m2       lB       uB   P
[1,]   1 4  0  2 0.010305 0.029876 0.1
[1] " "
     Dir D m0 m2        lB        uB    P
[1,]   1 4  0  2 0.0062989 0.0079532 0.01
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 4  0  2 0.0038409 0.0047214 0.001
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 4  0  2 0.0021701 0.0021726 1e-04
[1] " "
     Dir D m0 m2        lB       uB   P
[1,]   1 5  0  2 0.0055459 0.035391 0.1
[1] " "
     Dir D m0 m2        lB        uB    P
[1,]   1 5  0  2 0.0038637 0.0089412 0.01
[1] " "
     Dir D m0 m2       lB        uB     P
[1,]   1 5  0  2 0.002638 0.0039692 0.001
[1] " "
     Dir D m0 m2        lB        uB     P
[1,]   1 5  0  2 0.0017549 0.0020482 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 89
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m2      lB      uB   P
[1,]   1 3  3  2  1  2 0.22891 0.22892 0.1
[1] " "
     Dir D d3 d2 d1 m2       lB       uB    P
[1,]   1 3  3  2  1  2 0.019434 0.019435 0.01
[1] " "
     Dir D d3 d2 d1 m2        lB        uB     P
[1,]   1 3  3  2  1  2 0.0054853 0.0054856 0.001
[1] " "
     Dir D d3 d2 d1 m2       lB        uB     P
[1,]   1 3  3  2  1  2 0.002443 0.0024431 1e-04
[1] " "
     Dir D d3 d2 d1 m2     lB      uB   P
[1,]   1 4  3  2  1  2 0.2116 0.21161 0.1
[1] " "
     Dir D d3 d2 d1 m2       lB       uB    P
[1,]   1 4  3  2  1  2 0.018508 0.018508 0.01
[1] " "
     Dir D d3 d2 d1 m2        lB        uB     P
[1,]   1 4  3  2  1  2 0.0052226 0.0052229 0.001
[1] " "
     Dir D d3 d2 d1 m2        lB       uB     P
[1,]   1 4  3  2  1  2 0.0023259 0.002326 1e-04
[1] " "
     Dir D d3 d2 d1 m2    lB      uB   P
[1,]   1 5  3  2  1  2 0.201 0.20101 0.1
[1] " "
     Dir D d3 d2 d1 m2       lB       uB    P
[1,]   1 5  3  2  1  2 0.017895 0.017908 0.01
[1] " "
     Dir D d3 d2 d1 m2        lB        uB     P
[1,]   1 5  3  2  1  2 0.0050439 0.0050496 0.001
[1] " "
     Dir D d3 d2 d1 m2        lB        uB     P
[1,]   1 5  3  2  1  2 0.0022456 0.0022488 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 90
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m2      lB      uB   P
[1,]   1 2  2  1  2 0.25991 0.25992 0.1
[1] " "
     Dir D d2 d1 m2       lB       uB    P
[1,]   1 2  2  1  2 0.020874 0.020876 0.01
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 2  2  1  2 0.0058924 0.0058928 0.001
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 2  2  1  2 0.0026244 0.0026245 1e-04
[1] " "
     Dir D d2 d1 m2      lB      uB   P
[1,]   1 3  2  1  2 0.22684 0.22685 0.1
[1] " "
     Dir D d2 d1 m2       lB       uB    P
[1,]   1 3  2  1  2 0.019235 0.019237 0.01
[1] " "
     Dir D d2 d1 m2       lB        uB     P
[1,]   1 3  2  1  2 0.005429 0.0054292 0.001
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 3  2  1  2 0.0024179 0.0024181 1e-04
[1] " "
     Dir D d2 d1 m2      lB     uB   P
[1,]   1 4  2  1  2 0.20969 0.2097 0.1
[1] " "
     Dir D d2 d1 m2       lB       uB    P
[1,]   1 4  2  1  2 0.018292 0.018304 0.01
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 4  2  1  2 0.0051531 0.0051619 0.001
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 4  2  1  2 0.0022936 0.0022989 1e-04
[1] " "
     Dir D d2 d1 m2      lB      uB   P
[1,]   1 5  2  1  2 0.19796 0.19813 0.1
[1] " "
     Dir D d2 d1 m2       lB       uB    P
[1,]   1 5  2  1  2 0.016271 0.016676 0.01
[1] " "
     Dir D d2 d1 m2        lB        uB     P
[1,]   1 5  2  1  2 0.0042664 0.0045824 0.001
[1] " "
     Dir D d2 d1 m2       lB        uB     P
[1,]   1 5  2  1  2 0.001882 0.0020361 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 91
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m2      lB      uB   P
[1,]   1 3  3  1  2 0.22684 0.22685 0.1
[1] " "
     Dir D d3 d1 m2       lB       uB    P
[1,]   1 3  3  1  2 0.019234 0.019236 0.01
[1] " "
     Dir D d3 d1 m2       lB        uB     P
[1,]   1 3  3  1  2 0.005429 0.0054293 0.001
[1] " "
     Dir D d3 d1 m2        lB        uB     P
[1,]   1 3  3  1  2 0.0024179 0.0024181 1e-04
[1] " "
     Dir D d3 d1 m2      lB     uB   P
[1,]   1 4  3  1  2 0.20969 0.2097 0.1
[1] " "
     Dir D d3 d1 m2       lB       uB    P
[1,]   1 4  3  1  2 0.018317 0.018318 0.01
[1] " "
     Dir D d3 d1 m2        lB        uB     P
[1,]   1 4  3  1  2 0.0051685 0.0051687 0.001
[1] " "
     Dir D d3 d1 m2        lB        uB     P
[1,]   1 4  3  1  2 0.0023018 0.0023019 1e-04
[1] " "
     Dir D d3 d1 m2      lB      uB   P
[1,]   1 5  3  1  2 0.19918 0.19919 0.1
[1] " "
     Dir D d3 d1 m2       lB       uB    P
[1,]   1 5  3  1  2 0.017703 0.017724 0.01
[1] " "
     Dir D d3 d1 m2        lB        uB     P
[1,]   1 5  3  1  2 0.0049873 0.0049977 0.001
[1] " "
     Dir D d3 d1 m2        lB        uB     P
[1,]   1 5  3  1  2 0.0022203 0.0022257 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 92
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m2      lB      uB   P
[1,]   1 1  1  2 0.33834 0.33837 0.1
[1] " "
     Dir D d1 m2       lB       uB    P
[1,]   1 1  1  2 0.023402 0.023402 0.01
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 1  1  2 0.0066064 0.0066064 0.001
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 1  1  2 0.0029424 0.0029424 1e-04
[1] " "
     Dir D d1 m2      lB      uB   P
[1,]   1 2  1  2 0.25051 0.25052 0.1
[1] " "
     Dir D d1 m2       lB       uB    P
[1,]   1 2  1  2 0.019746 0.019747 0.01
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 2  1  2 0.0055742 0.0055742 0.001
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 2  1  2 0.0024826 0.0024826 1e-04
[1] " "
     Dir D d1 m2      lB      uB   P
[1,]   1 3  1  2 0.16055 0.20902 0.1
[1] " "
     Dir D d1 m2       lB       uB    P
[1,]   1 3  1  2 0.018198 0.018198 0.01
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 3  1  2 0.0051371 0.0051371 0.001
[1] " "
     Dir D d1 m2       lB       uB     P
[1,]   1 3  1  2 0.002288 0.002288 1e-04
[1] " "
     Dir D d1 m2       lB      uB   P
[1,]   1 4  1  2 0.086957 0.10358 0.1
[1] " "
     Dir D d1 m2       lB       uB    P
[1,]   1 4  1  2 0.017334 0.017336 0.01
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 4  1  2 0.0048936 0.0048937 0.001
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 4  1  2 0.0021795 0.0021796 1e-04
[1] " "
     Dir D d1 m2       lB       uB   P
[1,]   1 5  1  2 0.038452 0.062387 0.1
[1] " "
     Dir D d1 m2       lB       uB    P
[1,]   1 5  1  2 0.014954 0.016233 0.01
[1] " "
     Dir D d1 m2       lB       uB     P
[1,]   1 5  1  2 0.004738 0.004738 0.001
[1] " "
     Dir D d1 m2        lB        uB     P
[1,]   1 5  1  2 0.0021102 0.0021102 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 93
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m2      lB      uB   P
[1,]   1 3  3  2  2 0.33631 0.33633 0.1
[1] " "
     Dir D d3 d2 m2      lB       uB    P
[1,]   1 3  3  2  2 0.01924 0.019241 0.01
[1] " "
     Dir D d3 d2 m2        lB        uB     P
[1,]   1 3  3  2  2 0.0054314 0.0054317 0.001
[1] " "
     Dir D d3 d2 m2        lB        uB     P
[1,]   1 3  3  2  2 0.0024191 0.0024192 1e-04
[1] " "
     Dir D d3 d2 m2      lB     uB   P
[1,]   1 4  3  2  2 0.30087 0.3009 0.1
[1] " "
     Dir D d3 d2 m2       lB      uB    P
[1,]   1 4  3  2  2 0.018328 0.01833 0.01
[1] " "
     Dir D d3 d2 m2        lB        uB     P
[1,]   1 4  3  2  2 0.0051739 0.0051743 0.001
[1] " "
     Dir D d3 d2 m2        lB        uB     P
[1,]   1 4  3  2  2 0.0023044 0.0023046 1e-04
[1] " "
     Dir D d3 d2 m2      lB      uB   P
[1,]   1 5  3  2  2 0.27968 0.27969 0.1
[1] " "
     Dir D d3 d2 m2       lB       uB    P
[1,]   1 5  3  2  2 0.017745 0.017746 0.01
[1] " "
     Dir D d3 d2 m2        lB        uB     P
[1,]   1 5  3  2  2 0.0050093 0.0050097 0.001
[1] " "
     Dir D d3 d2 m2       lB        uB     P
[1,]   1 5  3  2  2 0.002231 0.0022312 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 94
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m2      lB      uB   P
[1,]   1 2  2  2 0.36213 0.36215 0.1
[1] " "
     Dir D d2 m2       lB       uB    P
[1,]   1 2  2  2 0.019746 0.019746 0.01
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 2  2  2 0.0055742 0.0055742 0.001
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 2  2  2 0.0024826 0.0024826 1e-04
[1] " "
     Dir D d2 m2      lB     uB   P
[1,]   1 3  2  2 0.31939 0.3194 0.1
[1] " "
     Dir D d2 m2       lB       uB    P
[1,]   1 3  2  2 0.018198 0.018198 0.01
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 3  2  2 0.0051371 0.0051374 0.001
[1] " "
     Dir D d2 m2       lB       uB     P
[1,]   1 3  2  2 0.002288 0.002288 1e-04
[1] " "
     Dir D d2 m2      lB      uB   P
[1,]   1 4  2  2 0.24495 0.28322 0.1
[1] " "
     Dir D d2 m2       lB       uB    P
[1,]   1 4  2  2 0.017335 0.017335 0.01
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 4  2  2 0.0048936 0.0048936 0.001
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 4  2  2 0.0021795 0.0021796 1e-04
[1] " "
     Dir D d2 m2      lB      uB   P
[1,]   1 5  2  2 0.16265 0.18223 0.1
[1] " "
     Dir D d2 m2       lB       uB    P
[1,]   1 5  2  2 0.016784 0.016784 0.01
[1] " "
     Dir D d2 m2       lB       uB     P
[1,]   1 5  2  2 0.004738 0.004738 0.001
[1] " "
     Dir D d2 m2        lB        uB     P
[1,]   1 5  2  2 0.0021102 0.0021102 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 95
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m2      lB      uB   P
[1,]   1 3  3  2 0.33071 0.33073 0.1
[1] " "
     Dir D d3 m2       lB       uB    P
[1,]   1 3  3  2 0.018198 0.018198 0.01
[1] " "
     Dir D d3 m2        lB        uB     P
[1,]   1 3  3  2 0.0051371 0.0051371 0.001
[1] " "
     Dir D d3 m2       lB       uB     P
[1,]   1 3  3  2 0.002288 0.002288 1e-04
[1] " "
     Dir D d3 m2      lB      uB   P
[1,]   1 4  3  2 0.31328 0.31332 0.1
[1] " "
     Dir D d3 m2       lB       uB    P
[1,]   1 4  3  2 0.017335 0.017335 0.01
[1] " "
     Dir D d3 m2        lB        uB     P
[1,]   1 4  3  2 0.0048936 0.0048936 0.001
[1] " "
     Dir D d3 m2        lB        uB     P
[1,]   1 4  3  2 0.0021795 0.0021796 1e-04
[1] " "
     Dir D d3 m2      lB      uB   P
[1,]   1 5  3  2 0.29668 0.30104 0.1
[1] " "
     Dir D d3 m2       lB       uB    P
[1,]   1 5  3  2 0.016784 0.016784 0.01
[1] " "
     Dir D d3 m2       lB        uB     P
[1,]   1 5  3  2 0.004738 0.0047381 0.001
[1] " "
     Dir D d3 m2        lB        uB     P
[1,]   1 5  3  2 0.0021102 0.0021102 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 96
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m2 lB uB   P
[1,]   1 0  2  1  1 0.1
[1] " "
     Dir D m2       lB       uB    P
[1,]   1 0  2 0.050979 0.050979 0.01
[1] " "
     Dir D m2       lB       uB     P
[1,]   1 0  2 0.014391 0.014391 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 0  2 0.0064096 0.0064096 1e-04
[1] " "
     Dir D m2      lB      uB   P
[1,]   1 1  2 0.42763 0.42765 0.1
[1] " "
     Dir D m2       lB       uB    P
[1,]   1 1  2 0.022657 0.022658 0.01
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 1  2 0.0063961 0.0063961 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 1  2 0.0028487 0.0028487 1e-04
[1] " "
     Dir D m2      lB      uB   P
[1,]   1 2  2 0.25479 0.25711 0.1
[1] " "
     Dir D m2       lB       uB    P
[1,]   1 2  2 0.019117 0.019117 0.01
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 2  2 0.0053967 0.0053967 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 2  2 0.0024036 0.0024036 1e-04
[1] " "
     Dir D m2      lB      uB   P
[1,]   1 3  2 0.11052 0.24471 0.1
[1] " "
     Dir D m2       lB       uB    P
[1,]   1 3  2 0.017618 0.017618 0.01
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 3  2 0.0049736 0.0049738 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 3  2 0.0022152 0.0022152 1e-04
[1] " "
     Dir D m2       lB      uB   P
[1,]   1 4  2 0.033685 0.11653 0.1
[1] " "
     Dir D m2       lB       uB    P
[1,]   1 4  2 0.014454 0.016422 0.01
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 4  2 0.0047379 0.0047379 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 4  2 0.0021102 0.0021102 1e-04
[1] " "
     Dir D m2        lB       uB   P
[1,]   1 5  2 0.0098725 0.034264 0.1
[1] " "
     Dir D m2        lB        uB    P
[1,]   1 5  2 0.0058383 0.0086566 0.01
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 5  2 0.0034467 0.0038429 0.001
[1] " "
     Dir D m2        lB        uB     P
[1,]   1 5  2 0.0019937 0.0020418 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 97
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0 m1     lB      uB   P
[1,]   1 3  3  2  1  0  1 0.1412 0.14121 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1       lB      uB    P
[1,]   1 3  3  2  1  0  1 0.032917 0.03292 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 3  3  2  1  0  1 0.016493 0.016494 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 3  3  2  1  0  1 0.010686 0.010686 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1      lB      uB   P
[1,]   1 4  3  2  1  0  1 0.13766 0.13766 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1      lB       uB    P
[1,]   1 4  3  2  1  0  1 0.03175 0.031752 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 4  3  2  1  0  1 0.015885 0.015886 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 4  3  2  1  0  1 0.010268 0.010268 1e-04
[1] " "
     Dir D d3 d2 d1 m0 m1     lB      uB   P
[1,]   1 5  3  2  1  0  1 0.1354 0.13541 0.1
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB    P
[1,]   1 5  3  2  1  0  1 0.030698 0.030982 0.01
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 5  3  2  1  0  1 0.015378 0.015458 0.001
[1] " "
     Dir D d3 d2 d1 m0 m1       lB       uB     P
[1,]   1 5  3  2  1  0  1 0.010002 0.010002 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 98
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0 m1      lB      uB   P
[1,]   1 2  2  1  0  1 0.14666 0.14667 0.1
[1] " "
     Dir D d2 d1 m0 m1      lB       uB    P
[1,]   1 2  2  1  0  1 0.03465 0.034653 0.01
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 2  2  1  0  1 0.017404 0.017405 0.001
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 2  2  1  0  1 0.011313 0.011314 1e-04
[1] " "
     Dir D d2 d1 m0 m1      lB      uB   P
[1,]   1 3  2  1  0  1 0.14034 0.14034 0.1
[1] " "
     Dir D d2 d1 m0 m1      lB       uB    P
[1,]   1 3  2  1  0  1 0.03257 0.032572 0.01
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 3  2  1  0  1 0.016295 0.016295 0.001
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 3  2  1  0  1 0.010552 0.010552 1e-04
[1] " "
     Dir D d2 d1 m0 m1     lB      uB   P
[1,]   1 4  2  1  0  1 0.1368 0.13681 0.1
[1] " "
     Dir D d2 d1 m0 m1       lB       uB    P
[1,]   1 4  2  1  0  1 0.030612 0.030822 0.01
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 4  2  1  0  1 0.015232 0.015667 0.001
[1] " "
     Dir D d2 d1 m0 m1        lB       uB     P
[1,]   1 4  2  1  0  1 0.0097682 0.010104 1e-04
[1] " "
     Dir D d2 d1 m0 m1      lB      uB   P
[1,]   1 5  2  1  0  1 0.13456 0.13456 0.1
[1] " "
     Dir D d2 d1 m0 m1      lB       uB    P
[1,]   1 5  2  1  0  1 0.02472 0.026734 0.01
[1] " "
     Dir D d2 d1 m0 m1       lB       uB     P
[1,]   1 5  2  1  0  1 0.011934 0.012925 0.001
[1] " "
     Dir D d2 d1 m0 m1        lB        uB     P
[1,]   1 5  2  1  0  1 0.0078418 0.0083588 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 99
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0 m1      lB      uB   P
[1,]   1 3  3  1  0  1 0.14034 0.14035 0.1
[1] " "
     Dir D d3 d1 m0 m1       lB       uB    P
[1,]   1 3  3  1  0  1 0.032714 0.032717 0.01
[1] " "
     Dir D d3 d1 m0 m1       lB       uB     P
[1,]   1 3  3  1  0  1 0.016295 0.016296 0.001
[1] " "
     Dir D d3 d1 m0 m1       lB       uB     P
[1,]   1 3  3  1  0  1 0.010552 0.010552 1e-04
[1] " "
     Dir D d3 d1 m0 m1      lB      uB   P
[1,]   1 4  3  1  0  1 0.13681 0.13681 0.1
[1] " "
     Dir D d3 d1 m0 m1       lB       uB    P
[1,]   1 4  3  1  0  1 0.031644 0.031646 0.01
[1] " "
     Dir D d3 d1 m0 m1       lB       uB     P
[1,]   1 4  3  1  0  1 0.015689 0.015689 0.001
[1] " "
     Dir D d3 d1 m0 m1       lB       uB     P
[1,]   1 4  3  1  0  1 0.010135 0.010135 1e-04
[1] " "
     Dir D d3 d1 m0 m1      lB      uB   P
[1,]   1 5  3  1  0  1 0.13456 0.13457 0.1
[1] " "
     Dir D d3 d1 m0 m1       lB       uB    P
[1,]   1 5  3  1  0  1 0.030351 0.030829 0.01
[1] " "
     Dir D d3 d1 m0 m1       lB       uB     P
[1,]   1 5  3  1  0  1 0.015191 0.015263 0.001
[1] " "
     Dir D d3 d1 m0 m1        lB        uB     P
[1,]   1 5  3  1  0  1 0.0098696 0.0098699 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 100
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0 m1      lB      uB   P
[1,]   1 1  1  0  1 0.15906 0.15906 0.1
[1] " "
     Dir D d1 m0 m1       lB       uB    P
[1,]   1 1  1  0  1 0.038467 0.038468 0.01
[1] " "
     Dir D d1 m0 m1       lB       uB     P
[1,]   1 1  1  0  1 0.019581 0.019582 0.001
[1] " "
     Dir D d1 m0 m1      lB       uB     P
[1,]   1 1  1  0  1 0.01281 0.012811 1e-04
[1] " "
     Dir D d1 m0 m1      lB      uB   P
[1,]   1 2  1  0  1 0.14425 0.14426 0.1
[1] " "
     Dir D d1 m0 m1       lB       uB    P
[1,]   1 2  1  0  1 0.033757 0.033758 0.01
[1] " "
     Dir D d1 m0 m1       lB       uB     P
[1,]   1 2  1  0  1 0.016898 0.016899 0.001
[1] " "
     Dir D d1 m0 m1       lB       uB     P
[1,]   1 2  1  0  1 0.010972 0.010973 1e-04
[1] " "
     Dir D d1 m0 m1      lB      uB   P
[1,]   1 3  1  0  1 0.13796 0.13796 0.1
[1] " "
     Dir D d1 m0 m1       lB       uB    P
[1,]   1 3  1  0  1 0.030058 0.030851 0.01
[1] " "
     Dir D d1 m0 m1       lB      uB     P
[1,]   1 3  1  0  1 0.013616 0.01447 0.001
[1] " "
     Dir D d1 m0 m1        lB       uB     P
[1,]   1 3  1  0  1 0.0086508 0.009422 1e-04
[1] " "
     Dir D d1 m0 m1     lB      uB   P
[1,]   1 4  1  0  1 0.1292 0.13263 0.1
[1] " "
     Dir D d1 m0 m1       lB       uB    P
[1,]   1 4  1  0  1 0.022947 0.027335 0.01
[1] " "
     Dir D d1 m0 m1        lB       uB     P
[1,]   1 4  1  0  1 0.0075414 0.011858 0.001
[1] " "
     Dir D d1 m0 m1        lB        uB     P
[1,]   1 4  1  0  1 0.0045617 0.0075908 1e-04
[1] " "
     Dir D d1 m0 m1      lB      uB   P
[1,]   1 5  1  0  1 0.13214 0.13217 0.1
[1] " "
     Dir D d1 m0 m1       lB       uB    P
[1,]   1 5  1  0  1 0.020749 0.020921 0.01
[1] " "
     Dir D d1 m0 m1        lB       uB     P
[1,]   1 5  1  0  1 0.0077193 0.012582 0.001
[1] " "
     Dir D d1 m0 m1      lB      uB     P
[1,]   1 5  1  0  1 0.00475 0.00814 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 101
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0 m1      lB      uB   P
[1,]   1 3  3  2  0  1 0.14034 0.14035 0.1
[1] " "
     Dir D d3 d2 m0 m1      lB       uB    P
[1,]   1 3  3  2  0  1 0.03257 0.032572 0.01
[1] " "
     Dir D d3 d2 m0 m1       lB       uB     P
[1,]   1 3  3  2  0  1 0.016496 0.016497 0.001
[1] " "
     Dir D d3 d2 m0 m1       lB       uB     P
[1,]   1 3  3  2  0  1 0.010794 0.010795 1e-04
[1] " "
     Dir D d3 d2 m0 m1      lB      uB   P
[1,]   1 4  3  2  0  1 0.13681 0.13681 0.1
[1] " "
     Dir D d3 d2 m0 m1     lB       uB    P
[1,]   1 4  3  2  0  1 0.0314 0.031403 0.01
[1] " "
     Dir D d3 d2 m0 m1       lB       uB     P
[1,]   1 4  3  2  0  1 0.015784 0.015785 0.001
[1] " "
     Dir D d3 d2 m0 m1       lB       uB     P
[1,]   1 4  3  2  0  1 0.010298 0.010299 1e-04
[1] " "
     Dir D d3 d2 m0 m1      lB      uB   P
[1,]   1 5  3  2  0  1 0.13456 0.13457 0.1
[1] " "
     Dir D d3 d2 m0 m1       lB       uB    P
[1,]   1 5  3  2  0  1 0.030341 0.030423 0.01
[1] " "
     Dir D d3 d2 m0 m1       lB       uB     P
[1,]   1 5  3  2  0  1 0.015198 0.015337 0.001
[1] " "
     Dir D d3 d2 m0 m1        lB        uB     P
[1,]   1 5  3  2  0  1 0.0099089 0.0099587 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 102
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0 m1      lB      uB   P
[1,]   1 2  2  0  1 0.14425 0.14426 0.1
[1] " "
     Dir D d2 m0 m1       lB       uB    P
[1,]   1 2  2  0  1 0.033907 0.033908 0.01
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 2  2  0  1 0.017363 0.017365 0.001
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 2  2  0  1 0.011414 0.011414 1e-04
[1] " "
     Dir D d2 m0 m1      lB      uB   P
[1,]   1 3  2  0  1 0.13796 0.13797 0.1
[1] " "
     Dir D d2 m0 m1       lB       uB    P
[1,]   1 3  2  0  1 0.031736 0.031737 0.01
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 3  2  0  1 0.016045 0.016046 0.001
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 3  2  0  1 0.010494 0.010495 1e-04
[1] " "
     Dir D d2 m0 m1      lB      uB   P
[1,]   1 4  2  0  1 0.13448 0.13449 0.1
[1] " "
     Dir D d2 m0 m1       lB       uB    P
[1,]   1 4  2  0  1 0.029675 0.030535 0.01
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 4  2  0  1 0.014503 0.015203 0.001
[1] " "
     Dir D d2 m0 m1        lB        uB     P
[1,]   1 4  2  0  1 0.0093153 0.0099904 1e-04
[1] " "
     Dir D d2 m0 m1      lB      uB   P
[1,]   1 5  2  0  1 0.13226 0.13227 0.1
[1] " "
     Dir D d2 m0 m1       lB       uB    P
[1,]   1 5  2  0  1 0.026757 0.027679 0.01
[1] " "
     Dir D d2 m0 m1       lB       uB     P
[1,]   1 5  2  0  1 0.011412 0.012916 0.001
[1] " "
     Dir D d2 m0 m1        lB        uB     P
[1,]   1 5  2  0  1 0.0069767 0.0083554 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 103
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0 m1      lB      uB   P
[1,]   1 3  3  0  1 0.13796 0.13797 0.1
[1] " "
     Dir D d3 m0 m1       lB       uB    P
[1,]   1 3  3  0  1 0.032158 0.032161 0.01
[1] " "
     Dir D d3 m0 m1      lB      uB     P
[1,]   1 3  3  0  1 0.01655 0.01655 0.001
[1] " "
     Dir D d3 m0 m1       lB       uB     P
[1,]   1 3  3  0  1 0.010906 0.010907 1e-04
[1] " "
     Dir D d3 m0 m1      lB      uB   P
[1,]   1 4  3  0  1 0.13448 0.13449 0.1
[1] " "
     Dir D d3 m0 m1      lB       uB    P
[1,]   1 4  3  0  1 0.03082 0.030823 0.01
[1] " "
     Dir D d3 m0 m1       lB       uB     P
[1,]   1 4  3  0  1 0.015705 0.015706 0.001
[1] " "
     Dir D d3 m0 m1       lB       uB     P
[1,]   1 4  3  0  1 0.010311 0.010312 1e-04
[1] " "
     Dir D d3 m0 m1      lB      uB   P
[1,]   1 5  3  0  1 0.13227 0.13227 0.1
[1] " "
     Dir D d3 m0 m1       lB       uB    P
[1,]   1 5  3  0  1 0.029463 0.029622 0.01
[1] " "
     Dir D d3 m0 m1       lB       uB     P
[1,]   1 5  3  0  1 0.014735 0.014944 0.001
[1] " "
     Dir D d3 m0 m1        lB        uB     P
[1,]   1 5  3  0  1 0.0096011 0.0097655 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 104
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0 m1      lB      uB   P
[1,]   1 0  0  1 0.23695 0.23695 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 0  0  1 0.077693 0.077693 0.01
[1] " "
     Dir D m0 m1      lB      uB     P
[1,]   1 0  0  1 0.04128 0.04128 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 0  0  1 0.027549 0.027549 1e-04
[1] " "
     Dir D m0 m1      lB      uB   P
[1,]   1 1  0  1 0.15606 0.15608 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 1  0  1 0.038846 0.038846 0.01
[1] " "
     Dir D m0 m1      lB      uB     P
[1,]   1 1  0  1 0.02064 0.02064 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 1  0  1 0.013774 0.013774 1e-04
[1] " "
     Dir D m0 m1       lB      uB   P
[1,]   1 2  0  1 0.094326 0.13795 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 2  0  1 0.034529 0.034531 0.01
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 2  0  1 0.018346 0.018346 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 2  0  1 0.012244 0.012244 1e-04
[1] " "
     Dir D m0 m1       lB       uB   P
[1,]   1 3  0  1 0.043012 0.080482 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 3  0  1 0.026751 0.029178 0.01
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 3  0  1 0.017402 0.017412 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 3  0  1 0.011622 0.011622 1e-04
[1] " "
     Dir D m0 m1       lB       uB   P
[1,]   1 4  0  1 0.028828 0.085263 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 4  0  1 0.020945 0.029612 0.01
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 4  0  1 0.015356 0.016806 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 4  0  1 0.011233 0.011284 1e-04
[1] " "
     Dir D m0 m1       lB       uB   P
[1,]   1 5  0  1 0.028603 0.089606 0.1
[1] " "
     Dir D m0 m1       lB       uB    P
[1,]   1 5  0  1 0.021631 0.029885 0.01
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 5  0  1 0.015716 0.016568 0.001
[1] " "
     Dir D m0 m1       lB       uB     P
[1,]   1 5  0  1 0.011034 0.011034 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 105
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m1      lB      uB   P
[1,]   1 3  3  2  1  1 0.15327 0.15329 0.1
[1] " "
     Dir D d3 d2 d1 m1       lB       uB    P
[1,]   1 3  3  2  1  1 0.034144 0.034145 0.01
[1] " "
     Dir D d3 d2 d1 m1       lB      uB     P
[1,]   1 3  3  2  1  1 0.018119 0.01812 0.001
[1] " "
     Dir D d3 d2 d1 m1       lB       uB     P
[1,]   1 3  3  2  1  1 0.012088 0.012089 1e-04
[1] " "
     Dir D d3 d2 d1 m1      lB      uB   P
[1,]   1 4  3  2  1  1 0.14866 0.14866 0.1
[1] " "
     Dir D d3 d2 d1 m1       lB       uB    P
[1,]   1 4  3  2  1  1 0.033026 0.033028 0.01
[1] " "
     Dir D d3 d2 d1 m1       lB       uB     P
[1,]   1 4  3  2  1  1 0.017517 0.017518 0.001
[1] " "
     Dir D d3 d2 d1 m1       lB       uB     P
[1,]   1 4  3  2  1  1 0.011685 0.011686 1e-04
[1] " "
     Dir D d3 d2 d1 m1      lB      uB   P
[1,]   1 5  3  2  1  1 0.14568 0.14568 0.1
[1] " "
     Dir D d3 d2 d1 m1       lB       uB    P
[1,]   1 5  3  2  1  1 0.031964 0.032057 0.01
[1] " "
     Dir D d3 d2 d1 m1       lB       uB     P
[1,]   1 5  3  2  1  1 0.016892 0.016918 0.001
[1] " "
     Dir D d3 d2 d1 m1       lB       uB     P
[1,]   1 5  3  2  1  1 0.011226 0.011248 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 106
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m1      lB      uB   P
[1,]   1 2  2  1  1 0.15842 0.15843 0.1
[1] " "
     Dir D d2 d1 m1       lB       uB    P
[1,]   1 2  2  1  1 0.035365 0.035367 0.01
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 2  2  1  1 0.018778 0.018779 0.001
[1] " "
     Dir D d2 d1 m1      lB       uB     P
[1,]   1 2  2  1  1 0.01253 0.012531 1e-04
[1] " "
     Dir D d2 d1 m1      lB      uB   P
[1,]   1 3  2  1  1 0.15037 0.15038 0.1
[1] " "
     Dir D d2 d1 m1       lB       uB    P
[1,]   1 3  2  1  1 0.033488 0.033489 0.01
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 3  2  1  1 0.017767 0.017767 0.001
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 3  2  1  1 0.011852 0.011853 1e-04
[1] " "
     Dir D d2 d1 m1      lB      uB   P
[1,]   1 4  2  1  1 0.14588 0.14588 0.1
[1] " "
     Dir D d2 d1 m1       lB       uB    P
[1,]   1 4  2  1  1 0.031861 0.032303 0.01
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 4  2  1  1 0.016758 0.017147 0.001
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 4  2  1  1 0.011159 0.011441 1e-04
[1] " "
     Dir D d2 d1 m1      lB      uB   P
[1,]   1 5  2  1  1 0.14047 0.14265 0.1
[1] " "
     Dir D d2 d1 m1       lB       uB    P
[1,]   1 5  2  1  1 0.023702 0.026043 0.01
[1] " "
     Dir D d2 d1 m1       lB       uB     P
[1,]   1 5  2  1  1 0.011402 0.013206 0.001
[1] " "
     Dir D d2 d1 m1        lB        uB     P
[1,]   1 5  2  1  1 0.0074921 0.0087491 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 107
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m1      lB      uB   P
[1,]   1 3  3  1  1 0.15038 0.15039 0.1
[1] " "
     Dir D d3 d1 m1       lB       uB    P
[1,]   1 3  3  1  1 0.033475 0.033477 0.01
[1] " "
     Dir D d3 d1 m1       lB       uB     P
[1,]   1 3  3  1  1 0.017768 0.017769 0.001
[1] " "
     Dir D d3 d1 m1       lB       uB     P
[1,]   1 3  3  1  1 0.011855 0.011856 1e-04
[1] " "
     Dir D d3 d1 m1      lB      uB   P
[1,]   1 4  3  1  1 0.14588 0.14589 0.1
[1] " "
     Dir D d3 d1 m1       lB       uB    P
[1,]   1 4  3  1  1 0.032365 0.032365 0.01
[1] " "
     Dir D d3 d1 m1       lB       uB     P
[1,]   1 4  3  1  1 0.017163 0.017163 0.001
[1] " "
     Dir D d3 d1 m1       lB       uB     P
[1,]   1 4  3  1  1 0.011449 0.011449 1e-04
[1] " "
     Dir D d3 d1 m1      lB      uB   P
[1,]   1 5  3  1  1 0.14297 0.14298 0.1
[1] " "
     Dir D d3 d1 m1       lB       uB    P
[1,]   1 5  3  1  1 0.031288 0.031429 0.01
[1] " "
     Dir D d3 d1 m1       lB       uB     P
[1,]   1 5  3  1  1 0.016523 0.016585 0.001
[1] " "
     Dir D d3 d1 m1      lB       uB     P
[1,]   1 5  3  1  1 0.01098 0.011026 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 108
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m1      lB      uB   P
[1,]   1 1  1  1 0.17355 0.17355 0.1
[1] " "
     Dir D d1 m1       lB       uB    P
[1,]   1 1  1  1 0.038846 0.038846 0.01
[1] " "
     Dir D d1 m1      lB      uB     P
[1,]   1 1  1  1 0.02064 0.02064 0.001
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 1  1  1 0.013774 0.013774 1e-04
[1] " "
     Dir D d1 m1      lB      uB   P
[1,]   1 2  1  1 0.15426 0.15427 0.1
[1] " "
     Dir D d1 m1      lB       uB    P
[1,]   1 2  1  1 0.03453 0.034533 0.01
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 2  1  1 0.018346 0.018346 0.001
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 2  1  1 0.012244 0.012244 1e-04
[1] " "
     Dir D d1 m1     lB      uB   P
[1,]   1 3  1  1 0.1384 0.14222 0.1
[1] " "
     Dir D d1 m1       lB       uB    P
[1,]   1 3  1  1 0.032777 0.032777 0.01
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 3  1  1 0.017415 0.017415 0.001
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 3  1  1 0.011622 0.011622 1e-04
[1] " "
     Dir D d1 m1       lB      uB   P
[1,]   1 4  1  1 0.099046 0.10211 0.1
[1] " "
     Dir D d1 m1       lB       uB    P
[1,]   1 4  1  1 0.031823 0.031824 0.01
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 4  1  1 0.016908 0.016908 0.001
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 4  1  1 0.011284 0.011284 1e-04
[1] " "
     Dir D d1 m1       lB      uB   P
[1,]   1 5  1  1 0.058433 0.07766 0.1
[1] " "
     Dir D d1 m1       lB       uB    P
[1,]   1 5  1  1 0.030925 0.031202 0.01
[1] " "
     Dir D d1 m1       lB      uB     P
[1,]   1 5  1  1 0.016589 0.01659 0.001
[1] " "
     Dir D d1 m1       lB       uB     P
[1,]   1 5  1  1 0.011034 0.011034 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 109
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m1      lB      uB   P
[1,]   1 3  3  2  1 0.15038 0.15038 0.1
[1] " "
     Dir D d3 d2 m1       lB      uB    P
[1,]   1 3  3  2  1 0.033659 0.03366 0.01
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 3  3  2  1 0.017884 0.017884 0.001
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 3  3  2  1 0.011935 0.011936 1e-04
[1] " "
     Dir D d3 d2 m1    lB    uB   P
[1,]   1 4  3  2  1 0.146 0.146 0.1
[1] " "
     Dir D d3 d2 m1       lB       uB    P
[1,]   1 4  3  2  1 0.032679 0.032681 0.01
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 4  3  2  1 0.017363 0.017364 0.001
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 4  3  2  1 0.011588 0.011588 1e-04
[1] " "
     Dir D d3 d2 m1      lB      uB   P
[1,]   1 5  3  2  1 0.14325 0.14325 0.1
[1] " "
     Dir D d3 d2 m1       lB       uB    P
[1,]   1 5  3  2  1 0.032063 0.032064 0.01
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 5  3  2  1 0.017035 0.017037 0.001
[1] " "
     Dir D d3 d2 m1       lB       uB     P
[1,]   1 5  3  2  1 0.011331 0.011332 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 110
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m1      lB      uB   P
[1,]   1 2  2  1 0.15427 0.15427 0.1
[1] " "
     Dir D d2 m1      lB      uB    P
[1,]   1 2  2  1 0.03453 0.03453 0.01
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 2  2  1 0.018346 0.018346 0.001
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 2  2  1 0.012244 0.012244 1e-04
[1] " "
     Dir D d2 m1      lB      uB   P
[1,]   1 3  2  1 0.14644 0.14644 0.1
[1] " "
     Dir D d2 m1       lB       uB    P
[1,]   1 3  2  1 0.032777 0.032777 0.01
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 3  2  1 0.017415 0.017415 0.001
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 3  2  1 0.011622 0.011622 1e-04
[1] " "
     Dir D d2 m1      lB      uB   P
[1,]   1 4  2  1 0.14217 0.14218 0.1
[1] " "
     Dir D d2 m1       lB       uB    P
[1,]   1 4  2  1 0.031823 0.031823 0.01
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 4  2  1 0.016908 0.016908 0.001
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 4  2  1 0.011284 0.011284 1e-04
[1] " "
     Dir D d2 m1      lB      uB   P
[1,]   1 5  2  1 0.13366 0.13758 0.1
[1] " "
     Dir D d2 m1       lB       uB    P
[1,]   1 5  2  1 0.031223 0.031224 0.01
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 5  2  1 0.016589 0.016591 0.001
[1] " "
     Dir D d2 m1       lB       uB     P
[1,]   1 5  2  1 0.011034 0.011034 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 111
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m1      lB      uB   P
[1,]   1 3  3  1 0.14644 0.14644 0.1
[1] " "
     Dir D d3 m1       lB       uB    P
[1,]   1 3  3  1 0.032777 0.032777 0.01
[1] " "
     Dir D d3 m1       lB       uB     P
[1,]   1 3  3  1 0.017415 0.017415 0.001
[1] " "
[1] "Cycle"
     Dir D d3 m1       lB       uB     P
[1,]   1 3  3  1 0.011622 0.011626 1e-04
[1] " "
     Dir D d3 m1      lB      uB   P
[1,]   1 4  3  1 0.14217 0.14218 0.1
[1] " "
     Dir D d3 m1       lB       uB    P
[1,]   1 4  3  1 0.031823 0.031823 0.01
[1] " "
     Dir D d3 m1       lB       uB     P
[1,]   1 4  3  1 0.016908 0.016908 0.001
[1] " "
     Dir D d3 m1       lB       uB     P
[1,]   1 4  3  1 0.011284 0.011284 1e-04
[1] " "
     Dir D d3 m1      lB      uB   P
[1,]   1 5  3  1 0.13949 0.13949 0.1
[1] " "
     Dir D d3 m1       lB       uB    P
[1,]   1 5  3  1 0.031223 0.031223 0.01
[1] " "
     Dir D d3 m1       lB       uB     P
[1,]   1 5  3  1 0.016589 0.016589 0.001
[1] " "
     Dir D d3 m1       lB       uB     P
[1,]   1 5  3  1 0.011034 0.011034 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 112
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m1      lB      uB   P
[1,]   1 0  1 0.33376 0.33376 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 0  1 0.074706 0.074706 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 0  1 0.039693 0.039693 0.001
[1] " "
     Dir D m1      lB      uB     P
[1,]   1 0  1 0.02649 0.02649 1e-04
[1] " "
     Dir D m1      lB      uB   P
[1,]   1 1  1 0.16688 0.16688 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 1  1 0.037353 0.037353 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 1  1 0.019846 0.019846 0.001
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 1  1 0.013245 0.013245 1e-04
[1] " "
     Dir D m1      lB      uB   P
[1,]   1 2  1 0.14834 0.14834 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 2  1 0.033203 0.033203 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 2  1 0.017641 0.017641 0.001
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 2  1 0.011773 0.011773 1e-04
[1] " "
     Dir D m1      lB      uB   P
[1,]   1 3  1 0.11587 0.12882 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 3  1 0.031516 0.031517 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 3  1 0.016745 0.016745 0.001
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 3  1 0.011175 0.011175 1e-04
[1] " "
     Dir D m1       lB       uB   P
[1,]   1 4  1 0.045659 0.081985 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 4  1 0.026505 0.028474 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 4  1 0.016258 0.016258 0.001
[1] " "
     Dir D m1      lB      uB     P
[1,]   1 4  1 0.01085 0.01085 1e-04
[1] " "
     Dir D m1       lB       uB   P
[1,]   1 5  1 0.030807 0.086161 0.1
[1] " "
     Dir D m1       lB       uB    P
[1,]   1 5  1 0.021743 0.028736 0.01
[1] " "
     Dir D m1       lB       uB     P
[1,]   1 5  1 0.015258 0.015931 0.001
[1] " "
     Dir D m1      lB      uB     P
[1,]   1 5  1 0.01061 0.01061 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 113
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1 m0      lB      uB   P
[1,]   1 3  3  2  1  0 0.22322 0.22324 0.1
[1] " "
     Dir D d3 d2 d1 m0      lB      uB    P
[1,]   1 3  3  2  1  0 0.22322 0.22323 0.01
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 3  3  2  1  0 0.22322 0.22323 0.001
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 3  3  2  1  0 0.22322 0.22323 1e-04
[1] " "
     Dir D d3 d2 d1 m0      lB      uB   P
[1,]   1 4  3  2  1  0 0.21835 0.21837 0.1
[1] " "
     Dir D d3 d2 d1 m0      lB      uB    P
[1,]   1 4  3  2  1  0 0.21835 0.21837 0.01
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 4  3  2  1  0 0.21835 0.21836 0.001
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 4  3  2  1  0 0.21835 0.21836 1e-04
[1] " "
     Dir D d3 d2 d1 m0      lB      uB   P
[1,]   1 5  3  2  1  0 0.20451 0.21432 0.1
[1] " "
     Dir D d3 d2 d1 m0      lB      uB    P
[1,]   1 5  3  2  1  0 0.20409 0.21447 0.01
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 5  3  2  1  0 0.20456 0.21352 0.001
[1] " "
     Dir D d3 d2 d1 m0      lB      uB     P
[1,]   1 5  3  2  1  0 0.20456 0.21352 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 114
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1 m0      lB      uB   P
[1,]   1 2  2  1  0 0.22431 0.22432 0.1
[1] " "
     Dir D d2 d1 m0     lB      uB    P
[1,]   1 2  2  1  0 0.2243 0.22432 0.01
[1] " "
     Dir D d2 d1 m0     lB      uB     P
[1,]   1 2  2  1  0 0.2243 0.22432 0.001
[1] " "
     Dir D d2 d1 m0     lB      uB     P
[1,]   1 2  2  1  0 0.2243 0.22432 1e-04
[1] " "
     Dir D d2 d1 m0      lB      uB   P
[1,]   1 3  2  1  0 0.21922 0.21924 0.1
[1] " "
     Dir D d2 d1 m0      lB      uB    P
[1,]   1 3  2  1  0 0.21923 0.21924 0.01
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 3  2  1  0 0.21923 0.21924 0.001
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 3  2  1  0 0.21923 0.21924 1e-04
[1] " "
     Dir D d2 d1 m0      lB      uB   P
[1,]   1 4  2  1  0 0.19441 0.21653 0.1
[1] " "
     Dir D d2 d1 m0      lB      uB    P
[1,]   1 4  2  1  0 0.19717 0.20618 0.01
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 4  2  1  0 0.19717 0.20618 0.001
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 4  2  1  0 0.19717 0.20618 1e-04
[1] " "
     Dir D d2 d1 m0      lB      uB   P
[1,]   1 5  2  1  0 0.15962 0.18295 0.1
[1] " "
     Dir D d2 d1 m0      lB     uB    P
[1,]   1 5  2  1  0 0.10561 0.1358 0.01
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 5  2  1  0 0.10389 0.13274 0.001
[1] " "
     Dir D d2 d1 m0      lB      uB     P
[1,]   1 5  2  1  0 0.10389 0.13274 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 115
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1 m0      lB      uB   P
[1,]   1 3  3  1  0 0.21965 0.21967 0.1
[1] " "
     Dir D d3 d1 m0      lB      uB    P
[1,]   1 3  3  1  0 0.21965 0.21966 0.01
[1] " "
     Dir D d3 d1 m0      lB      uB     P
[1,]   1 3  3  1  0 0.21965 0.21966 0.001
[1] " "
     Dir D d3 d1 m0      lB      uB     P
[1,]   1 3  3  1  0 0.21965 0.21966 1e-04
[1] " "
     Dir D d3 d1 m0     lB      uB   P
[1,]   1 4  3  1  0 0.2137 0.21371 0.1
[1] " "
     Dir D d3 d1 m0     lB      uB    P
[1,]   1 4  3  1  0 0.2137 0.21371 0.01
[1] " "
     Dir D d3 d1 m0     lB      uB     P
[1,]   1 4  3  1  0 0.2137 0.21371 0.001
[1] " "
     Dir D d3 d1 m0     lB      uB     P
[1,]   1 4  3  1  0 0.2137 0.21371 1e-04
[1] " "
     Dir D d3 d1 m0      lB      uB   P
[1,]   1 5  3  1  0 0.19887 0.21002 0.1
[1] " "
     Dir D d3 d1 m0     lB     uB    P
[1,]   1 5  3  1  0 0.1983 0.2099 0.01
[1] " "
     Dir D d3 d1 m0      lB      uB     P
[1,]   1 5  3  1  0 0.19856 0.20993 0.001
[1] " "
     Dir D d3 d1 m0      lB      uB     P
[1,]   1 5  3  1  0 0.19856 0.20993 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 116
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 m0      lB      uB   P
[1,]   1 1  1  0 0.23695 0.23695 0.1
[1] " "
     Dir D d1 m0      lB      uB    P
[1,]   1 1  1  0 0.23695 0.23695 0.01
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 1  1  0 0.23695 0.23695 0.001
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 1  1  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d1 m0      lB      uB   P
[1,]   1 2  1  0 0.23695 0.23695 0.1
[1] " "
     Dir D d1 m0      lB      uB    P
[1,]   1 2  1  0 0.23695 0.23695 0.01
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 2  1  0 0.23695 0.23695 0.001
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 2  1  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d1 m0      lB      uB   P
[1,]   1 3  1  0 0.23695 0.23695 0.1
[1] " "
     Dir D d1 m0      lB      uB    P
[1,]   1 3  1  0 0.23695 0.23695 0.01
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 3  1  0 0.23695 0.23695 0.001
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 3  1  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d1 m0      lB      uB   P
[1,]   1 4  1  0 0.23695 0.23695 0.1
[1] " "
     Dir D d1 m0      lB      uB    P
[1,]   1 4  1  0 0.23695 0.23695 0.01
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 4  1  0 0.23695 0.23695 0.001
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 4  1  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d1 m0      lB      uB   P
[1,]   1 5  1  0 0.23695 0.23695 0.1
[1] " "
     Dir D d1 m0      lB      uB    P
[1,]   1 5  1  0 0.23695 0.23695 0.01
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 5  1  0 0.23695 0.23695 0.001
[1] " "
     Dir D d1 m0      lB      uB     P
[1,]   1 5  1  0 0.23695 0.23695 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 117
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 m0      lB      uB   P
[1,]   1 3  3  2  0 0.23955 0.23957 0.1
[1] " "
     Dir D d3 d2 m0      lB      uB    P
[1,]   1 3  3  2  0 0.23956 0.23957 0.01
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 3  3  2  0 0.23956 0.23957 0.001
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 3  3  2  0 0.23956 0.23957 1e-04
[1] " "
     Dir D d3 d2 m0      lB      uB   P
[1,]   1 4  3  2  0 0.23956 0.23956 0.1
[1] " "
     Dir D d3 d2 m0      lB      uB    P
[1,]   1 4  3  2  0 0.23955 0.23957 0.01
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 4  3  2  0 0.23955 0.23957 0.001
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 4  3  2  0 0.23955 0.23957 1e-04
[1] " "
     Dir D d3 d2 m0      lB      uB   P
[1,]   1 5  3  2  0 0.23955 0.23956 0.1
[1] " "
     Dir D d3 d2 m0      lB      uB    P
[1,]   1 5  3  2  0 0.23954 0.23956 0.01
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 5  3  2  0 0.23954 0.23956 0.001
[1] " "
     Dir D d3 d2 m0      lB      uB     P
[1,]   1 5  3  2  0 0.23954 0.23956 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 118
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 m0      lB      uB   P
[1,]   1 2  2  0 0.23695 0.23695 0.1
[1] " "
     Dir D d2 m0      lB      uB    P
[1,]   1 2  2  0 0.23695 0.23695 0.01
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 2  2  0 0.23695 0.23695 0.001
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 2  2  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d2 m0      lB      uB   P
[1,]   1 3  2  0 0.23695 0.23695 0.1
[1] " "
     Dir D d2 m0      lB      uB    P
[1,]   1 3  2  0 0.23695 0.23695 0.01
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 3  2  0 0.23695 0.23695 0.001
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 3  2  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d2 m0      lB      uB   P
[1,]   1 4  2  0 0.23695 0.23695 0.1
[1] " "
     Dir D d2 m0      lB      uB    P
[1,]   1 4  2  0 0.23695 0.23695 0.01
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 4  2  0 0.23695 0.23695 0.001
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 4  2  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d2 m0      lB      uB   P
[1,]   1 5  2  0 0.23695 0.23695 0.1
[1] " "
     Dir D d2 m0      lB      uB    P
[1,]   1 5  2  0 0.23695 0.23695 0.01
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 5  2  0 0.23695 0.23695 0.001
[1] " "
     Dir D d2 m0      lB      uB     P
[1,]   1 5  2  0 0.23695 0.23695 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 119
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 m0      lB      uB   P
[1,]   1 3  3  0 0.23695 0.23695 0.1
[1] " "
     Dir D d3 m0      lB      uB    P
[1,]   1 3  3  0 0.23695 0.23695 0.01
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 3  3  0 0.23695 0.23695 0.001
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 3  3  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d3 m0      lB      uB   P
[1,]   1 4  3  0 0.23695 0.23695 0.1
[1] " "
     Dir D d3 m0      lB      uB    P
[1,]   1 4  3  0 0.23695 0.23695 0.01
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 4  3  0 0.23695 0.23695 0.001
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 4  3  0 0.23695 0.23695 1e-04
[1] " "
     Dir D d3 m0      lB      uB   P
[1,]   1 5  3  0 0.23695 0.23695 0.1
[1] " "
     Dir D d3 m0      lB      uB    P
[1,]   1 5  3  0 0.23695 0.23695 0.01
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 5  3  0 0.23695 0.23695 0.001
[1] " "
     Dir D d3 m0      lB      uB     P
[1,]   1 5  3  0 0.23695 0.23695 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 120
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D m0      lB      uB   P
[1,]   1 0  0 0.23345 0.23345 0.1
[1] " "
     Dir D m0      lB      uB    P
[1,]   1 0  0 0.23345 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 0  0 0.23345 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 0  0 0.23345 0.23345 1e-04
[1] " "
     Dir D m0      lB      uB   P
[1,]   1 1  0 0.23013 0.23345 0.1
[1] " "
     Dir D m0      lB      uB    P
[1,]   1 1  0 0.21861 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 1  0 0.20551 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 1  0 0.19159 0.23345 1e-04
[1] " "
     Dir D m0      lB      uB   P
[1,]   1 2  0 0.23015 0.23345 0.1
[1] " "
     Dir D m0      lB      uB    P
[1,]   1 2  0 0.21908 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 2  0 0.20718 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 2  0 0.19534 0.23345 1e-04
[1] " "
     Dir D m0      lB      uB   P
[1,]   1 3  0 0.23181 0.23345 0.1
[1] " "
     Dir D m0      lB      uB    P
[1,]   1 3  0 0.22649 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 3  0 0.22109 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 3  0 0.21605 0.23345 1e-04
[1] " "
     Dir D m0      lB      uB   P
[1,]   1 4  0 0.23291 0.23345 0.1
[1] " "
     Dir D m0     lB      uB    P
[1,]   1 4  0 0.2312 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 4  0 0.22956 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 4  0 0.22814 0.23345 1e-04
[1] " "
     Dir D m0      lB      uB   P
[1,]   1 5  0 0.23332 0.23345 0.1
[1] " "
     Dir D m0      lB      uB    P
[1,]   1 5  0 0.23291 0.23345 0.01
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 5  0 0.23253 0.23345 0.001
[1] " "
     Dir D m0      lB      uB     P
[1,]   1 5  0 0.23223 0.23345 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 121
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2 d1      lB      uB   P
[1,]   1 3  3  2  1 0.97962 0.97968 0.1
[1] " "
     Dir D d3 d2 d1      lB      uB    P
[1,]   1 3  3  2  1 0.97965 0.97968 0.01
[1] " "
     Dir D d3 d2 d1      lB      uB     P
[1,]   1 3  3  2  1 0.97963 0.97968 0.001
[1] " "
     Dir D d3 d2 d1      lB     uB     P
[1,]   1 3  3  2  1 0.97964 0.9797 1e-04
[1] " "
     Dir D d3 d2 d1      lB      uB   P
[1,]   1 4  3  2  1 0.97412 0.97415 0.1
[1] " "
     Dir D d3 d2 d1      lB      uB    P
[1,]   1 4  3  2  1 0.97411 0.97416 0.01
[1] " "
     Dir D d3 d2 d1      lB      uB     P
[1,]   1 4  3  2  1 0.97409 0.97416 0.001
[1] " "
     Dir D d3 d2 d1      lB      uB     P
[1,]   1 4  3  2  1 0.97413 0.97415 1e-04
[1] " "
     Dir D d3 d2 d1      lB      uB   P
[1,]   1 5  3  2  1 0.95949 0.96246 0.1
[1] " "
     Dir D d3 d2 d1      lB      uB    P
[1,]   1 5  3  2  1 0.95876 0.97041 0.01
[1] " "
     Dir D d3 d2 d1      lB      uB     P
[1,]   1 5  3  2  1 0.96032 0.96565 0.001
[1] " "
     Dir D d3 d2 d1      lB      uB     P
[1,]   1 5  3  2  1 0.95928 0.96291 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 122
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 d1      lB      uB   P
[1,]   1 2  2  1 0.98362 0.98362 0.1
[1] " "
     Dir D d2 d1      lB      uB    P
[1,]   1 2  2  1 0.98358 0.98363 0.01
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 2  2  1 0.98357 0.98364 0.001
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 2  2  1 0.98357 0.98364 1e-04
[1] " "
     Dir D d2 d1      lB      uB   P
[1,]   1 3  2  1 0.97811 0.97818 0.1
[1] " "
     Dir D d2 d1      lB      uB    P
[1,]   1 3  2  1 0.97814 0.97817 0.01
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 3  2  1 0.97816 0.97817 0.001
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 3  2  1 0.97809 0.97817 1e-04
[1] " "
     Dir D d2 d1      lB      uB   P
[1,]   1 4  2  1 0.95321 0.96091 0.1
[1] " "
     Dir D d2 d1      lB     uB    P
[1,]   1 4  2  1 0.95087 0.9512 0.01
[1] " "
     Dir D d2 d1      lB     uB     P
[1,]   1 4  2  1 0.95479 0.9685 0.001
[1] " "
     Dir D d2 d1      lB     uB     P
[1,]   1 4  2  1 0.95566 0.9662 1e-04
[1] " "
     Dir D d2 d1      lB      uB   P
[1,]   1 5  2  1 0.90958 0.91384 0.1
[1] " "
     Dir D d2 d1      lB      uB    P
[1,]   1 5  2  1 0.85024 0.87699 0.01
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 5  2  1 0.84353 0.91601 0.001
[1] " "
     Dir D d2 d1      lB      uB     P
[1,]   1 5  2  1 0.85172 0.90266 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 123
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d1      lB      uB   P
[1,]   1 3  3  1 0.97901 0.97904 0.1
[1] " "
     Dir D d3 d1      lB      uB    P
[1,]   1 3  3  1 0.97903 0.97904 0.01
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 3  3  1 0.97896 0.97906 0.001
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 3  3  1 0.97898 0.97904 1e-04
[1] " "
     Dir D d3 d1     lB      uB   P
[1,]   1 4  3  1 0.9727 0.97279 0.1
[1] " "
     Dir D d3 d1      lB      uB    P
[1,]   1 4  3  1 0.97273 0.97277 0.01
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 4  3  1 0.97269 0.97277 0.001
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 4  3  1 0.97276 0.97277 1e-04
[1] " "
     Dir D d3 d1      lB      uB   P
[1,]   1 5  3  1 0.95713 0.95829 0.1
[1] " "
     Dir D d3 d1      lB      uB    P
[1,]   1 5  3  1 0.95731 0.96766 0.01
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 5  3  1 0.95712 0.96097 0.001
[1] " "
     Dir D d3 d1      lB      uB     P
[1,]   1 5  3  1 0.95646 0.95734 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 124
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d1 lB uB   P
[1,]   1 1  1  1  1 0.1
[1] " "
     Dir D d1 lB uB    P
[1,]   1 1  1  1  1 0.01
[1] " "
     Dir D d1 lB uB     P
[1,]   1 1  1  1  1 0.001
[1] " "
     Dir D d1 lB uB     P
[1,]   1 1  1  1  1 1e-04
[1] " "
     Dir D d1 lB uB   P
[1,]   1 2  1  1  1 0.1
[1] " "
     Dir D d1 lB uB    P
[1,]   1 2  1  1  1 0.01
[1] " "
     Dir D d1 lB uB     P
[1,]   1 2  1  1  1 0.001
[1] " "
     Dir D d1 lB uB     P
[1,]   1 2  1  1  1 1e-04
[1] " "
     Dir D d1 lB uB   P
[1,]   1 3  1  1  1 0.1
[1] " "
     Dir D d1 lB uB    P
[1,]   1 3  1  1  1 0.01
[1] " "
     Dir D d1 lB uB     P
[1,]   1 3  1  1  1 0.001
[1] " "
     Dir D d1 lB uB     P
[1,]   1 3  1  1  1 1e-04
[1] " "
     Dir D d1 lB uB   P
[1,]   1 4  1  1  1 0.1
[1] " "
     Dir D d1 lB uB    P
[1,]   1 4  1  1  1 0.01
[1] " "
     Dir D d1 lB uB     P
[1,]   1 4  1  1  1 0.001
[1] " "
     Dir D d1 lB uB     P
[1,]   1 4  1  1  1 1e-04
[1] " "
     Dir D d1 lB uB   P
[1,]   1 5  1  1  1 0.1
[1] " "
     Dir D d1 lB uB    P
[1,]   1 5  1  1  1 0.01
[1] " "
     Dir D d1 lB uB     P
[1,]   1 5  1  1  1 0.001
[1] " "
     Dir D d1 lB uB     P
[1,]   1 5  1  1  1 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 125
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 d2      lB      uB   P
[1,]   1 3  3  2 0.99997 0.99999 0.1
[1] " "
     Dir D d3 d2      lB uB    P
[1,]   1 3  3  2 0.99995  1 0.01
[1] " "
     Dir D d3 d2      lB uB     P
[1,]   1 3  3  2 0.99995  1 0.001
[1] " "
     Dir D d3 d2      lB uB     P
[1,]   1 3  3  2 0.99995  1 1e-04
[1] " "
     Dir D d3 d2      lB      uB   P
[1,]   1 4  3  2 0.99996 0.99999 0.1
[1] " "
     Dir D d3 d2      lB      uB    P
[1,]   1 4  3  2 0.99993 0.99999 0.01
[1] " "
     Dir D d3 d2      lB      uB     P
[1,]   1 4  3  2 0.99992 0.99999 0.001
[1] " "
     Dir D d3 d2      lB      uB     P
[1,]   1 4  3  2 0.99992 0.99999 1e-04
[1] " "
     Dir D d3 d2      lB      uB   P
[1,]   1 5  3  2 0.99993 0.99994 0.1
[1] " "
     Dir D d3 d2     lB      uB    P
[1,]   1 5  3  2 0.9999 0.99993 0.01
[1] " "
     Dir D d3 d2      lB      uB     P
[1,]   1 5  3  2 0.99987 0.99994 0.001
[1] " "
     Dir D d3 d2      lB      uB     P
[1,]   1 5  3  2 0.99986 0.99993 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 126
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d2 lB uB   P
[1,]   1 2  2  1  1 0.1
[1] " "
     Dir D d2 lB uB    P
[1,]   1 2  2  1  1 0.01
[1] " "
     Dir D d2 lB uB     P
[1,]   1 2  2  1  1 0.001
[1] " "
     Dir D d2 lB uB     P
[1,]   1 2  2  1  1 1e-04
[1] " "
     Dir D d2 lB uB   P
[1,]   1 3  2  1  1 0.1
[1] " "
     Dir D d2 lB uB    P
[1,]   1 3  2  1  1 0.01
[1] " "
     Dir D d2 lB uB     P
[1,]   1 3  2  1  1 0.001
[1] " "
     Dir D d2 lB uB     P
[1,]   1 3  2  1  1 1e-04
[1] " "
     Dir D d2 lB uB   P
[1,]   1 4  2  1  1 0.1
[1] " "
     Dir D d2 lB uB    P
[1,]   1 4  2  1  1 0.01
[1] " "
     Dir D d2 lB uB     P
[1,]   1 4  2  1  1 0.001
[1] " "
     Dir D d2 lB uB     P
[1,]   1 4  2  1  1 1e-04
[1] " "
     Dir D d2 lB uB   P
[1,]   1 5  2  1  1 0.1
[1] " "
     Dir D d2 lB uB    P
[1,]   1 5  2  1  1 0.01
[1] " "
     Dir D d2 lB uB     P
[1,]   1 5  2  1  1 0.001
[1] " "
     Dir D d2 lB uB     P
[1,]   1 5  2  1  1 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 127
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D d3 lB uB   P
[1,]   1 3  3  1  1 0.1
[1] " "
     Dir D d3 lB uB    P
[1,]   1 3  3  1  1 0.01
[1] " "
     Dir D d3 lB uB     P
[1,]   1 3  3  1  1 0.001
[1] " "
     Dir D d3 lB uB     P
[1,]   1 3  3  1  1 1e-04
[1] " "
     Dir D d3 lB uB   P
[1,]   1 4  3  1  1 0.1
[1] " "
     Dir D d3 lB uB    P
[1,]   1 4  3  1  1 0.01
[1] " "
     Dir D d3 lB uB     P
[1,]   1 4  3  1  1 0.001
[1] " "
     Dir D d3 lB uB     P
[1,]   1 4  3  1  1 1e-04
[1] " "
     Dir D d3 lB uB   P
[1,]   1 5  3  1  1 0.1
[1] " "
     Dir D d3 lB uB    P
[1,]   1 5  3  1  1 0.01
[1] " "
     Dir D d3 lB uB     P
[1,]   1 5  3  1  1 0.001
[1] " "
     Dir D d3 lB uB     P
[1,]   1 5  3  1  1 1e-04
[1] " "
> 
> rm(list=ls())
> library(dplyr)
> source("R/extras.R")
> 
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) #n=1
[1] 128
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Load optim_param
> load("data/log_Hill_Horror_dist.Rdata")
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P", "direction",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> direction <- 1 # Maximize optimization program
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Is the objective function an indicator?
+   objFuncIndic <- D == 0
+   
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(buildMomentDerConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: GLPPhase1(new_constFun,
+                              constRHS,
+                              constDir,
+                              paramConsFun = a,
+                              xf =  C,
+                              IterMax = 200)
+   
+   for (p in P)
+   {
+     # Parameters of the objective function
+     paramObjFun <- list(a = a, c = DistributionPty::qlhorror(p))
+     
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       a <- paramObjFun$a
+       c <- paramObjFun$c
+       
+       output <-  if (max(c-a,0) < x) direction*x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::GLPPhase2(initBFS = initBFS,
+                           objFun = objFun[[k]] ,
+                           constFun = constFun[[k]] ,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           objLambda,
+                           paramConsFun = a,
+                           paramObjFun,
+                           gamma = gamma,
+                           xf = C,
+                           IterMax = 200,
+                           objFuncIndic = objFuncIndic,
+                           factor = direction)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$direction[k] <- direction
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- if (optim$direction[k] == 1)  out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$r, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(direction,D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("Dir","D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     Dir D lB uB   P
[1,]   1 0  1  1 0.1
[1] " "
     Dir D lB uB    P
[1,]   1 0  1  1 0.01
[1] " "
     Dir D lB uB     P
[1,]   1 0  1  1 0.001
[1] " "
     Dir D lB uB     P
[1,]   1 0  1  1 1e-04
[1] " "
     Dir D      lB uB   P
[1,]   1 1 0.98577  1 0.1
[1] " "
     Dir D      lB uB    P
[1,]   1 1 0.93642  1 0.01
[1] " "
     Dir D      lB uB     P
[1,]   1 1 0.88033  1 0.001
[1] " "
     Dir D      lB uB     P
[1,]   1 1 0.82068  1 1e-04
[1] " "
     Dir D      lB uB   P
[1,]   1 2 0.98587  1 0.1
[1] " "
     Dir D      lB uB    P
[1,]   1 2 0.93844  1 0.01
[1] " "
     Dir D      lB uB     P
[1,]   1 2 0.88749  1 0.001
[1] " "
     Dir D      lB uB     P
[1,]   1 2 0.83676  1 1e-04
[1] " "
     Dir D      lB uB   P
[1,]   1 3 0.99298  1 0.1
[1] " "
     Dir D      lB uB    P
[1,]   1 3 0.97019  1 0.01
[1] " "
     Dir D      lB uB     P
[1,]   1 3 0.94704  1 0.001
[1] " "
     Dir D      lB uB     P
[1,]   1 3 0.92546  1 1e-04
[1] " "
     Dir D      lB uB   P
[1,]   1 4 0.99768  1 0.1
[1] " "
     Dir D      lB uB    P
[1,]   1 4 0.99037  1 0.01
[1] " "
     Dir D      lB uB     P
[1,]   1 4 0.98336  1 0.001
[1] " "
     Dir D      lB uB     P
[1,]   1 4 0.97723  1 1e-04
[1] " "
     Dir D      lB uB   P
[1,]   1 5 0.99942  1 0.1
[1] " "
     Dir D      lB uB    P
[1,]   1 5 0.99767  1 0.01
[1] " "
     Dir D      lB uB     P
[1,]   1 5 0.99607  1 0.001
[1] " "
     Dir D      lB uB     P
[1,]   1 5 0.99477  1 1e-04
[1] " "
> 
