> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 1
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 3  3  2  1  0  1  2  3 0.14194 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 3  3  2  1  0  1  2  3 0.017226 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 3  3  2  1  0  1  2  3 0.0025533 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 3  3  2  1  0  1  2  3 0.00074474 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 4  3  2  1  0  1  2  3 0.13837 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 4  3  2  1  0  1  2  3 0.016192 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 4  3  2  1  0  1  2  3 0.0023968 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 4  3  2  1  0  1  2  3 0.00069624 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 5  3  2  1  0  1  2  3 0.13609 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 5  3  2  1  0  1  2  3 0.015523 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 5  3  2  1  0  1  2  3 0.0022955 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 5  3  2  1  0  1  2  3 0.00066471 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 2
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 2  2  1  0  1  2  3 0.14819 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 2  2  1  0  1  2  3 0.018826 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 2  2  1  0  1  2  3 0.0027949 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 2  2  1  0  1  2  3 0.00081911 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 3  2  1  0  1  2  3 0.14177 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 3  2  1  0  1  2  3 0.017023 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 3  2  1  0  1  2  3 0.0025211 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 3  2  1  0  1  2  3 0.00073504 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2 m3     lB  uB   P
[1,] 4  2  1  0  1  2  3 0.1382 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 4  2  1  0  1  2  3 0.016002 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 4  2  1  0  1  2  3 0.0023662 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 4  2  1  0  1  2  3 0.00068704 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2 m3      lB  uB   P
[1,] 5  2  1  0  1  2  3 0.13593 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2 m3       lB  uB    P
[1,] 5  2  1  0  1  2  3 0.015342 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2 m3        lB  uB     P
[1,] 5  2  1  0  1  2  3 0.0022659 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2 m3         lB  uB     P
[1,] 5  2  1  0  1  2  3 0.00065519 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 3
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m1 m2 m3      lB  uB   P
[1,] 3  3  1  0  1  2  3 0.14177 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2 m3       lB  uB    P
[1,] 3  3  1  0  1  2  3 0.017023 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2 m3        lB  uB     P
[1,] 3  3  1  0  1  2  3 0.0025211 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2 m3         lB  uB     P
[1,] 3  3  1  0  1  2  3 0.00073504 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m2 m3     lB  uB   P
[1,] 4  3  1  0  1  2  3 0.1382 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2 m3       lB  uB    P
[1,] 4  3  1  0  1  2  3 0.016002 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2 m3        lB  uB     P
[1,] 4  3  1  0  1  2  3 0.0023662 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2 m3         lB  uB     P
[1,] 4  3  1  0  1  2  3 0.00068698 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m2 m3      lB  uB   P
[1,] 5  3  1  0  1  2  3 0.13593 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2 m3       lB  uB    P
[1,] 5  3  1  0  1  2  3 0.015341 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2 m3        lB  uB     P
[1,] 5  3  1  0  1  2  3 0.0022658 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2 m3         lB  uB     P
[1,] 5  3  1  0  1  2  3 0.00065579 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 4
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m1 m2 m3      lB  uB   P
[1,] 1  1  0  1  2  3 0.16266 Inf 0.1
[1] " "
     D d1 m0 m1 m2 m3       lB  uB    P
[1,] 1  1  0  1  2  3 0.022906 Inf 0.01
[1] " "
     D d1 m0 m1 m2 m3       lB  uB     P
[1,] 1  1  0  1  2  3 0.003413 Inf 0.001
[1] " "
     D d1 m0 m1 m2 m3        lB  uB     P
[1,] 1  1  0  1  2  3 0.0010029 Inf 1e-04
[1] " "
     D d1 m0 m1 m2 m3     lB  uB   P
[1,] 2  1  0  1  2  3 0.1476 Inf 0.1
[1] " "
     D d1 m0 m1 m2 m3       lB  uB    P
[1,] 2  1  0  1  2  3 0.018765 Inf 0.01
[1] " "
     D d1 m0 m1 m2 m3        lB  uB     P
[1,] 2  1  0  1  2  3 0.0027843 Inf 0.001
[1] " "
     D d1 m0 m1 m2 m3         lB  uB     P
[1,] 2  1  0  1  2  3 0.00081582 Inf 1e-04
[1] " "
     D d1 m0 m1 m2 m3     lB  uB   P
[1,] 3  1  0  1  2  3 0.1412 Inf 0.1
[1] " "
     D d1 m0 m1 m2 m3       lB  uB    P
[1,] 3  1  0  1  2  3 0.016969 Inf 0.01
[1] " "
     D d1 m0 m1 m2 m3        lB  uB     P
[1,] 3  1  0  1  2  3 0.0025112 Inf 0.001
[1] " "
     D d1 m0 m1 m2 m3         lB  uB     P
[1,] 3  1  0  1  2  3 0.00073185 Inf 1e-04
[1] " "
     D d1 m0 m1 m2 m3      lB  uB   P
[1,] 4  1  0  1  2  3 0.13766 Inf 0.1
[1] " "
     D d1 m0 m1 m2 m3       lB  uB    P
[1,] 4  1  0  1  2  3 0.015951 Inf 0.01
[1] " "
     D d1 m0 m1 m2 m3        lB  uB     P
[1,] 4  1  0  1  2  3 0.0023565 Inf 0.001
[1] " "
     D d1 m0 m1 m2 m3        lB  uB     P
[1,] 4  1  0  1  2  3 0.0006839 Inf 1e-04
[1] " "
     D d1 m0 m1 m2 m3     lB  uB   P
[1,] 5  1  0  1  2  3 0.1354 Inf 0.1
[1] " "
     D d1 m0 m1 m2 m3       lB  uB    P
[1,] 5  1  0  1  2  3 0.015293 Inf 0.01
[1] " "
     D d1 m0 m1 m2 m3       lB  uB     P
[1,] 5  1  0  1  2  3 0.002256 Inf 0.001
[1] " "
     D d1 m0 m1 m2 m3         lB  uB     P
[1,] 5  1  0  1  2  3 0.00065265 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 5
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m1 m2 m3      lB  uB   P
[1,] 3  3  2  0  1  2  3 0.14177 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2 m3       lB  uB    P
[1,] 3  3  2  0  1  2  3 0.017023 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2 m3        lB  uB     P
[1,] 3  3  2  0  1  2  3 0.0025325 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2 m3         lB  uB     P
[1,] 3  3  2  0  1  2  3 0.00073968 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m2 m3     lB  uB   P
[1,] 4  3  2  0  1  2  3 0.1382 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2 m3       lB  uB    P
[1,] 4  3  2  0  1  2  3 0.016002 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2 m3        lB  uB     P
[1,] 4  3  2  0  1  2  3 0.0023757 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2 m3         lB  uB     P
[1,] 4  3  2  0  1  2  3 0.00069363 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m2 m3      lB  uB   P
[1,] 5  3  2  0  1  2  3 0.13593 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2 m3       lB  uB    P
[1,] 5  3  2  0  1  2  3 0.015342 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2 m3        lB  uB     P
[1,] 5  3  2  0  1  2  3 0.0022742 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2 m3         lB  uB     P
[1,] 5  3  2  0  1  2  3 0.00066316 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 6
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m1 m2 m3     lB  uB   P
[1,] 2  2  0  1  2  3 0.1476 Inf 0.1
[1] " "
     D d2 m0 m1 m2 m3       lB  uB    P
[1,] 2  2  0  1  2  3 0.018765 Inf 0.01
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 2  2  0  1  2  3 0.0027941 Inf 0.001
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 2  2  0  1  2  3 0.0008171 Inf 1e-04
[1] " "
     D d2 m0 m1 m2 m3     lB  uB   P
[1,] 3  2  0  1  2  3 0.1412 Inf 0.1
[1] " "
     D d2 m0 m1 m2 m3       lB  uB    P
[1,] 3  2  0  1  2  3 0.016968 Inf 0.01
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 3  2  0  1  2  3 0.0025228 Inf 0.001
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 3  2  0  1  2  3 0.0007361 Inf 1e-04
[1] " "
     D d2 m0 m1 m2 m3      lB  uB   P
[1,] 4  2  0  1  2  3 0.13766 Inf 0.1
[1] " "
     D d2 m0 m1 m2 m3       lB  uB    P
[1,] 4  2  0  1  2  3 0.015951 Inf 0.01
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 4  2  0  1  2  3 0.0023661 Inf 0.001
[1] " "
     D d2 m0 m1 m2 m3         lB  uB     P
[1,] 4  2  0  1  2  3 0.00069011 Inf 1e-04
[1] " "
     D d2 m0 m1 m2 m3     lB  uB   P
[1,] 5  2  0  1  2  3 0.1354 Inf 0.1
[1] " "
     D d2 m0 m1 m2 m3       lB  uB    P
[1,] 5  2  0  1  2  3 0.015293 Inf 0.01
[1] " "
     D d2 m0 m1 m2 m3        lB  uB     P
[1,] 5  2  0  1  2  3 0.0022642 Inf 0.001
[1] " "
     D d2 m0 m1 m2 m3         lB  uB     P
[1,] 5  2  0  1  2  3 0.00065974 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 7
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m1 m2 m3     lB  uB   P
[1,] 3  3  0  1  2  3 0.1412 Inf 0.1
[1] " "
     D d3 m0 m1 m2 m3       lB  uB    P
[1,] 3  3  0  1  2  3 0.016968 Inf 0.01
[1] " "
     D d3 m0 m1 m2 m3        lB  uB     P
[1,] 3  3  0  1  2  3 0.0025251 Inf 0.001
[1] " "
     D d3 m0 m1 m2 m3         lB  uB     P
[1,] 3  3  0  1  2  3 0.00073606 Inf 1e-04
[1] " "
     D d3 m0 m1 m2 m3      lB  uB   P
[1,] 4  3  0  1  2  3 0.13766 Inf 0.1
[1] " "
     D d3 m0 m1 m2 m3       lB  uB    P
[1,] 4  3  0  1  2  3 0.015951 Inf 0.01
[1] " "
     D d3 m0 m1 m2 m3       lB  uB     P
[1,] 4  3  0  1  2  3 0.002373 Inf 0.001
[1] " "
     D d3 m0 m1 m2 m3         lB  uB     P
[1,] 4  3  0  1  2  3 0.00069011 Inf 1e-04
[1] " "
     D d3 m0 m1 m2 m3     lB  uB   P
[1,] 5  3  0  1  2  3 0.1354 Inf 0.1
[1] " "
     D d3 m0 m1 m2 m3       lB  uB    P
[1,] 5  3  0  1  2  3 0.015293 Inf 0.01
[1] " "
     D d3 m0 m1 m2 m3        lB  uB     P
[1,] 5  3  0  1  2  3 0.0022729 Inf 0.001
[1] " "
     D d3 m0 m1 m2 m3         lB  uB     P
[1,] 5  3  0  1  2  3 0.00065976 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 8
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m1 m2 m3      lB  uB   P
[1,] 0  0  1  2  3 0.24291 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 0  0  1  2  3 0.053693 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 0  0  1  2  3 0.0080188 Inf 0.001
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 0  0  1  2  3 0.0023691 Inf 1e-04
[1] " "
     D m0 m1 m2 m3      lB  uB   P
[1,] 1  0  1  2  3 0.16171 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 1  0  1  2  3 0.022652 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 1  0  1  2  3 0.0033738 Inf 0.001
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 1  0  1  2  3 0.0009903 Inf 1e-04
[1] " "
     D m0 m1 m2 m3      lB  uB   P
[1,] 2  0  1  2  3 0.14671 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 2  0  1  2  3 0.018556 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 2  0  1  2  3 0.0027603 Inf 0.001
[1] " "
     D m0 m1 m2 m3         lB  uB     P
[1,] 2  0  1  2  3 0.00080642 Inf 1e-04
[1] " "
     D m0 m1 m2 m3      lB  uB   P
[1,] 3  0  1  2  3 0.14034 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 3  0  1  2  3 0.016779 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 3  0  1  2  3 0.0024942 Inf 0.001
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 3  0  1  2  3 0.0007262 Inf 1e-04
[1] " "
     D m0 m1 m2 m3      lB  uB   P
[1,] 4  0  1  2  3 0.13681 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 4  0  1  2  3 0.015773 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 4  0  1  2  3 0.0023437 Inf 0.001
[1] " "
     D m0 m1 m2 m3         lB  uB     P
[1,] 4  0  1  2  3 0.00068065 Inf 1e-04
[1] " "
     D m0 m1 m2 m3      lB  uB   P
[1,] 5  0  1  2  3 0.13456 Inf 0.1
[1] " "
     D m0 m1 m2 m3       lB  uB    P
[1,] 5  0  1  2  3 0.015122 Inf 0.01
[1] " "
     D m0 m1 m2 m3        lB  uB     P
[1,] 5  0  1  2  3 0.0022466 Inf 0.001
[1] " "
     D m0 m1 m2 m3         lB  uB     P
[1,] 5  0  1  2  3 0.00065021 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 9
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m1 m2 m3      lB  uB   P
[1,] 3  3  2  1  1  2  3 0.15482 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2 m3       lB  uB    P
[1,] 3  3  2  1  1  2  3 0.017023 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2 m3        lB  uB     P
[1,] 3  3  2  1  1  2  3 0.0025211 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2 m3         lB  uB     P
[1,] 3  3  2  1  1  2  3 0.00073504 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m2 m3      lB  uB   P
[1,] 4  3  2  1  1  2  3 0.15014 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2 m3       lB  uB    P
[1,] 4  3  2  1  1  2  3 0.016002 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2 m3        lB  uB     P
[1,] 4  3  2  1  1  2  3 0.0023662 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2 m3         lB  uB     P
[1,] 4  3  2  1  1  2  3 0.00068698 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m2 m3      lB  uB   P
[1,] 5  3  2  1  1  2  3 0.14712 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2 m3       lB  uB    P
[1,] 5  3  2  1  1  2  3 0.015341 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2 m3        lB  uB     P
[1,] 5  3  2  1  1  2  3 0.0022657 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2 m3        lB  uB     P
[1,] 5  3  2  1  1  2  3 0.0006557 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 10
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m1 m2 m3     lB  uB   P
[1,] 2  2  1  1  2  3 0.1627 Inf 0.1
[1] " "
     D d2 d1 m1 m2 m3       lB  uB    P
[1,] 2  2  1  1  2  3 0.018766 Inf 0.01
[1] " "
     D d2 d1 m1 m2 m3        lB  uB     P
[1,] 2  2  1  1  2  3 0.0027843 Inf 0.001
[1] " "
     D d2 d1 m1 m2 m3         lB  uB     P
[1,] 2  2  1  1  2  3 0.00081581 Inf 1e-04
[1] " "
     D d2 d1 m1 m2 m3      lB  uB   P
[1,] 3  2  1  1  2  3 0.15442 Inf 0.1
[1] " "
     D d2 d1 m1 m2 m3       lB  uB    P
[1,] 3  2  1  1  2  3 0.016968 Inf 0.01
[1] " "
     D d2 d1 m1 m2 m3        lB  uB     P
[1,] 3  2  1  1  2  3 0.0025112 Inf 0.001
[1] " "
     D d2 d1 m1 m2 m3         lB  uB     P
[1,] 3  2  1  1  2  3 0.00073187 Inf 1e-04
[1] " "
     D d2 d1 m1 m2 m3      lB  uB   P
[1,] 4  2  1  1  2  3 0.14975 Inf 0.1
[1] " "
     D d2 d1 m1 m2 m3      lB  uB    P
[1,] 4  2  1  1  2  3 0.01595 Inf 0.01
[1] " "
     D d2 d1 m1 m2 m3        lB  uB     P
[1,] 4  2  1  1  2  3 0.0023565 Inf 0.001
[1] " "
     D d2 d1 m1 m2 m3         lB  uB     P
[1,] 4  2  1  1  2  3 0.00068391 Inf 1e-04
[1] " "
     D d2 d1 m1 m2 m3      lB  uB   P
[1,] 5  2  1  1  2  3 0.14674 Inf 0.1
[1] " "
     D d2 d1 m1 m2 m3       lB  uB    P
[1,] 5  2  1  1  2  3 0.015292 Inf 0.01
[1] " "
     D d2 d1 m1 m2 m3        lB  uB     P
[1,] 5  2  1  1  2  3 0.0022566 Inf 0.001
[1] " "
     D d2 d1 m1 m2 m3         lB  uB     P
[1,] 5  2  1  1  2  3 0.00065264 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 11
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m1 m2 m3      lB  uB   P
[1,] 3  3  1  1  2  3 0.15442 Inf 0.1
[1] " "
     D d3 d1 m1 m2 m3       lB  uB    P
[1,] 3  3  1  1  2  3 0.016968 Inf 0.01
[1] " "
     D d3 d1 m1 m2 m3        lB  uB     P
[1,] 3  3  1  1  2  3 0.0025112 Inf 0.001
[1] " "
     D d3 d1 m1 m2 m3         lB  uB     P
[1,] 3  3  1  1  2  3 0.00073187 Inf 1e-04
[1] " "
     D d3 d1 m1 m2 m3      lB  uB   P
[1,] 4  3  1  1  2  3 0.14975 Inf 0.1
[1] " "
     D d3 d1 m1 m2 m3      lB  uB    P
[1,] 4  3  1  1  2  3 0.01595 Inf 0.01
[1] " "
     D d3 d1 m1 m2 m3        lB  uB     P
[1,] 4  3  1  1  2  3 0.0023566 Inf 0.001
[1] " "
     D d3 d1 m1 m2 m3         lB  uB     P
[1,] 4  3  1  1  2  3 0.00068392 Inf 1e-04
[1] " "
     D d3 d1 m1 m2 m3      lB  uB   P
[1,] 5  3  1  1  2  3 0.14674 Inf 0.1
[1] " "
     D d3 d1 m1 m2 m3       lB  uB    P
[1,] 5  3  1  1  2  3 0.015291 Inf 0.01
[1] " "
     D d3 d1 m1 m2 m3        lB  uB     P
[1,] 5  3  1  1  2  3 0.0022564 Inf 0.001
[1] " "
     D d3 d1 m1 m2 m3         lB  uB     P
[1,] 5  3  1  1  2  3 0.00065264 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 12
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m1 m2 m3      lB  uB   P
[1,] 1  1  1  2  3 0.18167 Inf 0.1
[1] " "
     D d1 m1 m2 m3       lB  uB    P
[1,] 1  1  1  2  3 0.022652 Inf 0.01
[1] " "
     D d1 m1 m2 m3        lB  uB     P
[1,] 1  1  1  2  3 0.0033729 Inf 0.001
[1] " "
     D d1 m1 m2 m3         lB  uB     P
[1,] 1  1  1  2  3 0.00099472 Inf 1e-04
[1] " "
     D d1 m1 m2 m3      lB  uB   P
[1,] 2  1  1  2  3 0.16149 Inf 0.1
[1] " "
     D d1 m1 m2 m3       lB  uB    P
[1,] 2  1  1  2  3 0.018556 Inf 0.01
[1] " "
     D d1 m1 m2 m3        lB  uB     P
[1,] 2  1  1  2  3 0.0027505 Inf 0.001
[1] " "
     D d1 m1 m2 m3         lB  uB     P
[1,] 2  1  1  2  3 0.00080553 Inf 1e-04
[1] " "
     D d1 m1 m2 m3      lB  uB   P
[1,] 3  1  1  2  3 0.15327 Inf 0.1
[1] " "
     D d1 m1 m2 m3       lB  uB    P
[1,] 3  1  1  2  3 0.016779 Inf 0.01
[1] " "
     D d1 m1 m2 m3      lB  uB     P
[1,] 3  1  1  2  3 0.00248 Inf 0.001
[1] " "
     D d1 m1 m2 m3         lB  uB     P
[1,] 3  1  1  2  3 0.00072231 Inf 1e-04
[1] " "
     D d1 m1 m2 m3      lB  uB   P
[1,] 4  1  1  2  3 0.14866 Inf 0.1
[1] " "
     D d1 m1 m2 m3       lB  uB    P
[1,] 4  1  1  2  3 0.015773 Inf 0.01
[1] " "
     D d1 m1 m2 m3        lB  uB     P
[1,] 4  1  1  2  3 0.0023268 Inf 0.001
[1] " "
     D d1 m1 m2 m3         lB  uB     P
[1,] 4  1  1  2  3 0.00067467 Inf 1e-04
[1] " "
     D d1 m1 m2 m3      lB  uB   P
[1,] 5  1  1  2  3 0.14568 Inf 0.1
[1] " "
     D d1 m1 m2 m3       lB  uB    P
[1,] 5  1  1  2  3 0.015122 Inf 0.01
[1] " "
     D d1 m1 m2 m3        lB  uB     P
[1,] 5  1  1  2  3 0.0022275 Inf 0.001
[1] " "
     D d1 m1 m2 m3         lB  uB     P
[1,] 5  1  1  2  3 0.00064349 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 13
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m1 m2 m3      lB  uB   P
[1,] 3  3  2  1  2  3 0.15443 Inf 0.1
[1] " "
     D d3 d2 m1 m2 m3       lB  uB    P
[1,] 3  3  2  1  2  3 0.016969 Inf 0.01
[1] " "
     D d3 d2 m1 m2 m3        lB  uB     P
[1,] 3  3  2  1  2  3 0.0025228 Inf 0.001
[1] " "
     D d3 d2 m1 m2 m3         lB  uB     P
[1,] 3  3  2  1  2  3 0.00074248 Inf 1e-04
[1] " "
     D d3 d2 m1 m2 m3      lB  uB   P
[1,] 4  3  2  1  2  3 0.14994 Inf 0.1
[1] " "
     D d3 d2 m1 m2 m3       lB  uB    P
[1,] 4  3  2  1  2  3 0.015951 Inf 0.01
[1] " "
     D d3 d2 m1 m2 m3        lB  uB     P
[1,] 4  3  2  1  2  3 0.0023662 Inf 0.001
[1] " "
     D d3 d2 m1 m2 m3         lB  uB     P
[1,] 4  3  2  1  2  3 0.00069394 Inf 1e-04
[1] " "
     D d3 d2 m1 m2 m3      lB  uB   P
[1,] 5  3  2  1  2  3 0.14711 Inf 0.1
[1] " "
     D d3 d2 m1 m2 m3       lB  uB    P
[1,] 5  3  2  1  2  3 0.015293 Inf 0.01
[1] " "
     D d3 d2 m1 m2 m3        lB  uB     P
[1,] 5  3  2  1  2  3 0.0022649 Inf 0.001
[1] " "
     D d3 d2 m1 m2 m3        lB  uB     P
[1,] 5  3  2  1  2  3 0.0006616 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 14
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m1 m2 m3      lB  uB   P
[1,] 2  2  1  2  3 0.16149 Inf 0.1
[1] " "
     D d2 m1 m2 m3       lB  uB    P
[1,] 2  2  1  2  3 0.018556 Inf 0.01
[1] " "
     D d2 m1 m2 m3        lB  uB     P
[1,] 2  2  1  2  3 0.0027663 Inf 0.001
[1] " "
     D d2 m1 m2 m3         lB  uB     P
[1,] 2  2  1  2  3 0.00081741 Inf 1e-04
[1] " "
     D d2 m1 m2 m3      lB  uB   P
[1,] 3  2  1  2  3 0.15329 Inf 0.1
[1] " "
     D d2 m1 m2 m3       lB  uB    P
[1,] 3  2  1  2  3 0.016779 Inf 0.01
[1] " "
     D d2 m1 m2 m3        lB  uB     P
[1,] 3  2  1  2  3 0.0024925 Inf 0.001
[1] " "
     D d2 m1 m2 m3        lB  uB     P
[1,] 3  2  1  2  3 0.0007331 Inf 1e-04
[1] " "
     D d2 m1 m2 m3      lB  uB   P
[1,] 4  2  1  2  3 0.14883 Inf 0.1
[1] " "
     D d2 m1 m2 m3       lB  uB    P
[1,] 4  2  1  2  3 0.015773 Inf 0.01
[1] " "
     D d2 m1 m2 m3        lB  uB     P
[1,] 4  2  1  2  3 0.0023368 Inf 0.001
[1] " "
     D d2 m1 m2 m3         lB  uB     P
[1,] 4  2  1  2  3 0.00068513 Inf 1e-04
[1] " "
     D d2 m1 m2 m3      lB  uB   P
[1,] 5  2  1  2  3 0.14602 Inf 0.1
[1] " "
     D d2 m1 m2 m3       lB  uB    P
[1,] 5  2  1  2  3 0.015122 Inf 0.01
[1] " "
     D d2 m1 m2 m3        lB  uB     P
[1,] 5  2  1  2  3 0.0022358 Inf 0.001
[1] " "
     D d2 m1 m2 m3         lB  uB     P
[1,] 5  2  1  2  3 0.00065333 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 15
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m1 m2 m3      lB  uB   P
[1,] 3  3  1  2  3 0.15329 Inf 0.1
[1] " "
     D d3 m1 m2 m3       lB  uB    P
[1,] 3  3  1  2  3 0.016779 Inf 0.01
[1] " "
     D d3 m1 m2 m3        lB  uB     P
[1,] 3  3  1  2  3 0.0025033 Inf 0.001
[1] " "
     D d3 m1 m2 m3         lB  uB     P
[1,] 3  3  1  2  3 0.00074039 Inf 1e-04
[1] " "
     D d3 m1 m2 m3      lB  uB   P
[1,] 4  3  1  2  3 0.14883 Inf 0.1
[1] " "
     D d3 m1 m2 m3       lB  uB    P
[1,] 4  3  1  2  3 0.015773 Inf 0.01
[1] " "
     D d3 m1 m2 m3        lB  uB     P
[1,] 4  3  1  2  3 0.0023472 Inf 0.001
[1] " "
     D d3 m1 m2 m3        lB  uB     P
[1,] 4  3  1  2  3 0.0006918 Inf 1e-04
[1] " "
     D d3 m1 m2 m3      lB  uB   P
[1,] 5  3  1  2  3 0.14602 Inf 0.1
[1] " "
     D d3 m1 m2 m3       lB  uB    P
[1,] 5  3  1  2  3 0.015122 Inf 0.01
[1] " "
     D d3 m1 m2 m3        lB  uB     P
[1,] 5  3  1  2  3 0.0022455 Inf 0.001
[1] " "
     D d3 m1 m2 m3         lB  uB     P
[1,] 5  3  1  2  3 0.00066027 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 16
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m1 m2 m3      lB  uB   P
[1,] 0  1  2  3 0.35589 Inf 0.1
[1] " "
     D m1 m2 m3       lB  uB    P
[1,] 0  1  2  3 0.049958 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 0  1  2  3 0.0074906 Inf 0.001
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 0  1  2  3 0.0022226 Inf 1e-04
[1] " "
     D m1 m2 m3      lB  uB   P
[1,] 1  1  2  3 0.17823 Inf 0.1
[1] " "
     D m1 m2 m3       lB  uB    P
[1,] 1  1  2  3 0.021076 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 1  1  2  3 0.0031594 Inf 0.001
[1] " "
     D m1 m2 m3         lB  uB     P
[1,] 1  1  2  3 0.00093705 Inf 1e-04
[1] " "
     D m1 m2 m3      lB  uB   P
[1,] 2  1  2  3 0.15842 Inf 0.1
[1] " "
     D m1 m2 m3       lB  uB    P
[1,] 2  1  2  3 0.017265 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 2  1  2  3 0.0025878 Inf 0.001
[1] " "
     D m1 m2 m3         lB  uB     P
[1,] 2  1  2  3 0.00076746 Inf 1e-04
[1] " "
     D m1 m2 m3      lB  uB   P
[1,] 3  1  2  3 0.15038 Inf 0.1
[1] " "
     D m1 m2 m3       lB  uB    P
[1,] 3  1  2  3 0.015612 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 3  1  2  3 0.0023396 Inf 0.001
[1] " "
     D m1 m2 m3         lB  uB     P
[1,] 3  1  2  3 0.00069357 Inf 1e-04
[1] " "
     D m1 m2 m3    lB  uB   P
[1,] 4  1  2  3 0.146 Inf 0.1
[1] " "
     D m1 m2 m3       lB  uB    P
[1,] 4  1  2  3 0.014675 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 4  1  2  3 0.0021994 Inf 0.001
[1] " "
     D m1 m2 m3         lB  uB     P
[1,] 4  1  2  3 0.00065191 Inf 1e-04
[1] " "
     D m1 m2 m3      lB  uB   P
[1,] 5  1  2  3 0.14325 Inf 0.1
[1] " "
     D m1 m2 m3      lB  uB    P
[1,] 5  1  2  3 0.01407 Inf 0.01
[1] " "
     D m1 m2 m3        lB  uB     P
[1,] 5  1  2  3 0.0021023 Inf 0.001
[1] " "
     D m1 m2 m3         lB  uB     P
[1,] 5  1  2  3 0.00062243 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 17
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m2 m3      lB  uB   P
[1,] 3  3  2  1  0  2  3 0.15335 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2 m3       lB  uB    P
[1,] 3  3  2  1  0  2  3 0.017023 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2 m3        lB  uB     P
[1,] 3  3  2  1  0  2  3 0.0025407 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2 m3         lB  uB     P
[1,] 3  3  2  1  0  2  3 0.00075347 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m2 m3      lB  uB   P
[1,] 4  3  2  1  0  2  3 0.14845 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2 m3       lB  uB    P
[1,] 4  3  2  1  0  2  3 0.016002 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2 m3        lB  uB     P
[1,] 4  3  2  1  0  2  3 0.0023848 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2 m3         lB  uB     P
[1,] 4  3  2  1  0  2  3 0.00070657 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m2 m3      lB  uB   P
[1,] 5  3  2  1  0  2  3 0.14507 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2 m3       lB  uB    P
[1,] 5  3  2  1  0  2  3 0.015341 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2 m3        lB  uB     P
[1,] 5  3  2  1  0  2  3 0.0022836 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2 m3        lB  uB     P
[1,] 5  3  2  1  0  2  3 0.0006758 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 18
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m2 m3      lB  uB   P
[1,] 2  2  1  0  2  3 0.15983 Inf 0.1
[1] " "
     D d2 d1 m0 m2 m3       lB  uB    P
[1,] 2  2  1  0  2  3 0.018765 Inf 0.01
[1] " "
     D d2 d1 m0 m2 m3        lB  uB     P
[1,] 2  2  1  0  2  3 0.0028057 Inf 0.001
[1] " "
     D d2 d1 m0 m2 m3         lB  uB     P
[1,] 2  2  1  0  2  3 0.00083294 Inf 1e-04
[1] " "
     D d2 d1 m0 m2 m3      lB  uB   P
[1,] 3  2  1  0  2  3 0.15139 Inf 0.1
[1] " "
     D d2 d1 m0 m2 m3       lB  uB    P
[1,] 3  2  1  0  2  3 0.016968 Inf 0.01
[1] " "
     D d2 d1 m0 m2 m3        lB  uB     P
[1,] 3  2  1  0  2  3 0.0025324 Inf 0.001
[1] " "
     D d2 d1 m0 m2 m3         lB  uB     P
[1,] 3  2  1  0  2  3 0.00075098 Inf 1e-04
[1] " "
     D d2 d1 m0 m2 m3      lB  uB   P
[1,] 4  2  1  0  2  3 0.14636 Inf 0.1
[1] " "
     D d2 d1 m0 m2 m3       lB  uB    P
[1,] 4  2  1  0  2  3 0.015951 Inf 0.01
[1] " "
     D d2 d1 m0 m2 m3        lB  uB     P
[1,] 4  2  1  0  2  3 0.0023771 Inf 0.001
[1] " "
     D d2 d1 m0 m2 m3         lB  uB     P
[1,] 4  2  1  0  2  3 0.00070417 Inf 1e-04
[1] " "
     D d2 d1 m0 m2 m3      lB  uB   P
[1,] 5  2  1  0  2  3 0.14298 Inf 0.1
[1] " "
     D d2 d1 m0 m2 m3       lB  uB    P
[1,] 5  2  1  0  2  3 0.015292 Inf 0.01
[1] " "
     D d2 d1 m0 m2 m3        lB  uB     P
[1,] 5  2  1  0  2  3 0.0022756 Inf 0.001
[1] " "
     D d2 d1 m0 m2 m3         lB  uB     P
[1,] 5  2  1  0  2  3 0.00067289 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 19
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m2 m3     lB  uB   P
[1,] 3  3  1  0  2  3 0.1512 Inf 0.1
[1] " "
     D d3 d1 m0 m2 m3       lB  uB    P
[1,] 3  3  1  0  2  3 0.016968 Inf 0.01
[1] " "
     D d3 d1 m0 m2 m3        lB  uB     P
[1,] 3  3  1  0  2  3 0.0025324 Inf 0.001
[1] " "
     D d3 d1 m0 m2 m3         lB  uB     P
[1,] 3  3  1  0  2  3 0.00075099 Inf 1e-04
[1] " "
     D d3 d1 m0 m2 m3      lB  uB   P
[1,] 4  3  1  0  2  3 0.14633 Inf 0.1
[1] " "
     D d3 d1 m0 m2 m3      lB  uB    P
[1,] 4  3  1  0  2  3 0.01595 Inf 0.01
[1] " "
     D d3 d1 m0 m2 m3        lB  uB     P
[1,] 4  3  1  0  2  3 0.0023771 Inf 0.001
[1] " "
     D d3 d1 m0 m2 m3         lB  uB     P
[1,] 4  3  1  0  2  3 0.00070423 Inf 1e-04
[1] " "
     D d3 d1 m0 m2 m3      lB  uB   P
[1,] 5  3  1  0  2  3 0.14298 Inf 0.1
[1] " "
     D d3 d1 m0 m2 m3       lB  uB    P
[1,] 5  3  1  0  2  3 0.015291 Inf 0.01
[1] " "
     D d3 d1 m0 m2 m3       lB  uB     P
[1,] 5  3  1  0  2  3 0.002276 Inf 0.001
[1] " "
     D d3 d1 m0 m2 m3         lB  uB     P
[1,] 5  3  1  0  2  3 0.00067355 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 20
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m2 m3      lB  uB   P
[1,] 1  1  0  2  3 0.17767 Inf 0.1
[1] " "
     D d1 m0 m2 m3      lB  uB    P
[1,] 1  1  0  2  3 0.02265 Inf 0.01
[1] " "
     D d1 m0 m2 m3        lB  uB     P
[1,] 1  1  0  2  3 0.0033936 Inf 0.001
[1] " "
     D d1 m0 m2 m3        lB  uB     P
[1,] 1  1  0  2  3 0.0010084 Inf 1e-04
[1] " "
     D d1 m0 m2 m3      lB  uB   P
[1,] 2  1  0  2  3 0.15941 Inf 0.1
[1] " "
     D d1 m0 m2 m3       lB  uB    P
[1,] 2  1  0  2  3 0.018556 Inf 0.01
[1] " "
     D d1 m0 m2 m3        lB  uB     P
[1,] 2  1  0  2  3 0.0027739 Inf 0.001
[1] " "
     D d1 m0 m2 m3         lB  uB     P
[1,] 2  1  0  2  3 0.00082343 Inf 1e-04
[1] " "
     D d1 m0 m2 m3      lB  uB   P
[1,] 3  1  0  2  3 0.15071 Inf 0.1
[1] " "
     D d1 m0 m2 m3       lB  uB    P
[1,] 3  1  0  2  3 0.016779 Inf 0.01
[1] " "
     D d1 m0 m2 m3        lB  uB     P
[1,] 3  1  0  2  3 0.0025033 Inf 0.001
[1] " "
     D d1 m0 m2 m3         lB  uB     P
[1,] 3  1  0  2  3 0.00074228 Inf 1e-04
[1] " "
     D d1 m0 m2 m3     lB  uB   P
[1,] 4  1  0  2  3 0.1456 Inf 0.1
[1] " "
     D d1 m0 m2 m3       lB  uB    P
[1,] 4  1  0  2  3 0.015772 Inf 0.01
[1] " "
     D d1 m0 m2 m3        lB  uB     P
[1,] 4  1  0  2  3 0.0023495 Inf 0.001
[1] " "
     D d1 m0 m2 m3         lB  uB     P
[1,] 4  1  0  2  3 0.00069593 Inf 1e-04
[1] " "
     D d1 m0 m2 m3      lB  uB   P
[1,] 5  1  0  2  3 0.14224 Inf 0.1
[1] " "
     D d1 m0 m2 m3       lB  uB    P
[1,] 5  1  0  2  3 0.015122 Inf 0.01
[1] " "
     D d1 m0 m2 m3       lB  uB     P
[1,] 5  1  0  2  3 0.002249 Inf 0.001
[1] " "
     D d1 m0 m2 m3         lB  uB     P
[1,] 5  1  0  2  3 0.00066574 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 21
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m2 m3      lB  uB   P
[1,] 3  3  2  0  2  3 0.15149 Inf 0.1
[1] " "
     D d3 d2 m0 m2 m3       lB  uB    P
[1,] 3  3  2  0  2  3 0.016968 Inf 0.01
[1] " "
     D d3 d2 m0 m2 m3       lB  uB     P
[1,] 3  3  2  0  2  3 0.002538 Inf 0.001
[1] " "
     D d3 d2 m0 m2 m3         lB  uB     P
[1,] 3  3  2  0  2  3 0.00075364 Inf 1e-04
[1] " "
     D d3 d2 m0 m2 m3      lB  uB   P
[1,] 4  3  2  0  2  3 0.14636 Inf 0.1
[1] " "
     D d3 d2 m0 m2 m3       lB  uB    P
[1,] 4  3  2  0  2  3 0.015951 Inf 0.01
[1] " "
     D d3 d2 m0 m2 m3        lB  uB     P
[1,] 4  3  2  0  2  3 0.0023818 Inf 0.001
[1] " "
     D d3 d2 m0 m2 m3         lB  uB     P
[1,] 4  3  2  0  2  3 0.00070688 Inf 1e-04
[1] " "
     D d3 d2 m0 m2 m3      lB  uB   P
[1,] 5  3  2  0  2  3 0.14298 Inf 0.1
[1] " "
     D d3 d2 m0 m2 m3       lB  uB    P
[1,] 5  3  2  0  2  3 0.015293 Inf 0.01
[1] " "
     D d3 d2 m0 m2 m3        lB  uB     P
[1,] 5  3  2  0  2  3 0.0022802 Inf 0.001
[1] " "
     D d3 d2 m0 m2 m3         lB  uB     P
[1,] 5  3  2  0  2  3 0.00067599 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 22
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m2 m3      lB  uB   P
[1,] 2  2  0  2  3 0.15941 Inf 0.1
[1] " "
     D d2 m0 m2 m3       lB  uB    P
[1,] 2  2  0  2  3 0.018555 Inf 0.01
[1] " "
     D d2 m0 m2 m3        lB  uB     P
[1,] 2  2  0  2  3 0.0027798 Inf 0.001
[1] " "
     D d2 m0 m2 m3         lB  uB     P
[1,] 2  2  0  2  3 0.00082595 Inf 1e-04
[1] " "
     D d2 m0 m2 m3      lB  uB   P
[1,] 3  2  0  2  3 0.15071 Inf 0.1
[1] " "
     D d2 m0 m2 m3       lB  uB    P
[1,] 3  2  0  2  3 0.016778 Inf 0.01
[1] " "
     D d2 m0 m2 m3        lB  uB     P
[1,] 3  2  0  2  3 0.0025089 Inf 0.001
[1] " "
     D d2 m0 m2 m3        lB  uB     P
[1,] 3  2  0  2  3 0.0007451 Inf 1e-04
[1] " "
     D d2 m0 m2 m3     lB  uB   P
[1,] 4  2  0  2  3 0.1456 Inf 0.1
[1] " "
     D d2 m0 m2 m3       lB  uB    P
[1,] 4  2  0  2  3 0.015772 Inf 0.01
[1] " "
     D d2 m0 m2 m3        lB  uB     P
[1,] 4  2  0  2  3 0.0023545 Inf 0.001
[1] " "
     D d2 m0 m2 m3         lB  uB     P
[1,] 4  2  0  2  3 0.00069855 Inf 1e-04
[1] " "
     D d2 m0 m2 m3      lB  uB   P
[1,] 5  2  0  2  3 0.14224 Inf 0.1
[1] " "
     D d2 m0 m2 m3       lB  uB    P
[1,] 5  2  0  2  3 0.015122 Inf 0.01
[1] " "
     D d2 m0 m2 m3        lB  uB     P
[1,] 5  2  0  2  3 0.0022538 Inf 0.001
[1] " "
     D d2 m0 m2 m3         lB  uB     P
[1,] 5  2  0  2  3 0.00066849 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 23
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m2 m3      lB  uB   P
[1,] 3  3  0  2  3 0.15071 Inf 0.1
[1] " "
     D d3 m0 m2 m3       lB  uB    P
[1,] 3  3  0  2  3 0.016778 Inf 0.01
[1] " "
     D d3 m0 m2 m3        lB  uB     P
[1,] 3  3  0  2  3 0.0025138 Inf 0.001
[1] " "
     D d3 m0 m2 m3         lB  uB     P
[1,] 3  3  0  2  3 0.00074649 Inf 1e-04
[1] " "
     D d3 m0 m2 m3     lB  uB   P
[1,] 4  3  0  2  3 0.1456 Inf 0.1
[1] " "
     D d3 m0 m2 m3       lB  uB    P
[1,] 4  3  0  2  3 0.015772 Inf 0.01
[1] " "
     D d3 m0 m2 m3      lB  uB     P
[1,] 4  3  0  2  3 0.00236 Inf 0.001
[1] " "
     D d3 m0 m2 m3         lB  uB     P
[1,] 4  3  0  2  3 0.00070086 Inf 1e-04
[1] " "
     D d3 m0 m2 m3      lB  uB   P
[1,] 5  3  0  2  3 0.14224 Inf 0.1
[1] " "
     D d3 m0 m2 m3       lB  uB    P
[1,] 5  3  0  2  3 0.015122 Inf 0.01
[1] " "
     D d3 m0 m2 m3       lB  uB     P
[1,] 5  3  0  2  3 0.002259 Inf 0.001
[1] " "
     D d3 m0 m2 m3         lB  uB     P
[1,] 5  3  0  2  3 0.00067018 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 24
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m2 m3      lB  uB   P
[1,] 0  0  2  3 0.23957 Inf 0.1
[1] " "
     D m0 m2 m3       lB  uB    P
[1,] 0  0  2  3 0.049958 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 0  0  2  3 0.0074931 Inf 0.001
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 0  0  2  3 0.0022177 Inf 1e-04
[1] " "
     D m0 m2 m3      lB  uB   P
[1,] 1  0  2  3 0.17534 Inf 0.1
[1] " "
     D m0 m2 m3       lB  uB    P
[1,] 1  0  2  3 0.021076 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 1  0  2  3 0.0031612 Inf 0.001
[1] " "
     D m0 m2 m3         lB  uB     P
[1,] 1  0  2  3 0.00093445 Inf 1e-04
[1] " "
     D m0 m2 m3      lB  uB   P
[1,] 2  0  2  3 0.15735 Inf 0.1
[1] " "
     D m0 m2 m3       lB  uB    P
[1,] 2  0  2  3 0.017265 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 2  0  2  3 0.0025896 Inf 0.001
[1] " "
     D m0 m2 m3         lB  uB     P
[1,] 2  0  2  3 0.00076503 Inf 1e-04
[1] " "
     D m0 m2 m3      lB  uB   P
[1,] 3  0  2  3 0.14878 Inf 0.1
[1] " "
     D m0 m2 m3       lB  uB    P
[1,] 3  0  2  3 0.015612 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 3  0  2  3 0.0023416 Inf 0.001
[1] " "
     D m0 m2 m3         lB  uB     P
[1,] 3  0  2  3 0.00069148 Inf 1e-04
[1] " "
     D m0 m2 m3      lB  uB   P
[1,] 4  0  2  3 0.14374 Inf 0.1
[1] " "
     D m0 m2 m3       lB  uB    P
[1,] 4  0  2  3 0.014675 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 4  0  2  3 0.0022011 Inf 0.001
[1] " "
     D m0 m2 m3         lB  uB     P
[1,] 4  0  2  3 0.00064973 Inf 1e-04
[1] " "
     D m0 m2 m3      lB  uB   P
[1,] 5  0  2  3 0.14042 Inf 0.1
[1] " "
     D m0 m2 m3      lB  uB    P
[1,] 5  0  2  3 0.01407 Inf 0.01
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 5  0  2  3 0.0021103 Inf 0.001
[1] " "
     D m0 m2 m3        lB  uB     P
[1,] 5  0  2  3 0.0006218 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 25
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m2 m3      lB  uB   P
[1,] 3  3  2  1  2  3 0.23028 Inf 0.1
[1] " "
     D d3 d2 d1 m2 m3       lB  uB    P
[1,] 3  3  2  1  2  3 0.016968 Inf 0.01
[1] " "
     D d3 d2 d1 m2 m3        lB  uB     P
[1,] 3  3  2  1  2  3 0.0025445 Inf 0.001
[1] " "
     D d3 d2 d1 m2 m3         lB  uB     P
[1,] 3  3  2  1  2  3 0.00075632 Inf 1e-04
[1] " "
     D d3 d2 d1 m2 m3      lB  uB   P
[1,] 4  3  2  1  2  3 0.21287 Inf 0.1
[1] " "
     D d3 d2 d1 m2 m3      lB  uB    P
[1,] 4  3  2  1  2  3 0.01595 Inf 0.01
[1] " "
     D d3 d2 d1 m2 m3        lB  uB     P
[1,] 4  3  2  1  2  3 0.0023918 Inf 0.001
[1] " "
     D d3 d2 d1 m2 m3         lB  uB     P
[1,] 4  3  2  1  2  3 0.00071048 Inf 1e-04
[1] " "
     D d3 d2 d1 m2 m3      lB  uB   P
[1,] 5  3  2  1  2  3 0.20221 Inf 0.1
[1] " "
     D d3 d2 d1 m2 m3       lB  uB    P
[1,] 5  3  2  1  2  3 0.015291 Inf 0.01
[1] " "
     D d3 d2 d1 m2 m3        lB  uB     P
[1,] 5  3  2  1  2  3 0.0022928 Inf 0.001
[1] " "
     D d3 d2 d1 m2 m3         lB  uB     P
[1,] 5  3  2  1  2  3 0.00068097 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 26
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m2 m3      lB  uB   P
[1,] 2  2  1  2  3 0.26228 Inf 0.1
[1] " "
     D d2 d1 m2 m3       lB  uB    P
[1,] 2  2  1  2  3 0.018556 Inf 0.01
[1] " "
     D d2 d1 m2 m3        lB  uB     P
[1,] 2  2  1  2  3 0.0027832 Inf 0.001
[1] " "
     D d2 d1 m2 m3         lB  uB     P
[1,] 2  2  1  2  3 0.00082658 Inf 1e-04
[1] " "
     D d2 d1 m2 m3      lB  uB   P
[1,] 3  2  1  2  3 0.22891 Inf 0.1
[1] " "
     D d2 d1 m2 m3       lB  uB    P
[1,] 3  2  1  2  3 0.016779 Inf 0.01
[1] " "
     D d2 d1 m2 m3        lB  uB     P
[1,] 3  2  1  2  3 0.0025166 Inf 0.001
[1] " "
     D d2 d1 m2 m3         lB  uB     P
[1,] 3  2  1  2  3 0.00074746 Inf 1e-04
[1] " "
     D d2 d1 m2 m3      lB  uB   P
[1,] 4  2  1  2  3 0.21161 Inf 0.1
[1] " "
     D d2 d1 m2 m3       lB  uB    P
[1,] 4  2  1  2  3 0.015772 Inf 0.01
[1] " "
     D d2 d1 m2 m3        lB  uB     P
[1,] 4  2  1  2  3 0.0023655 Inf 0.001
[1] " "
     D d2 d1 m2 m3         lB  uB     P
[1,] 4  2  1  2  3 0.00070259 Inf 1e-04
[1] " "
     D d2 d1 m2 m3    lB  uB   P
[1,] 5  2  1  2  3 0.201 Inf 0.1
[1] " "
     D d2 d1 m2 m3       lB  uB    P
[1,] 5  2  1  2  3 0.015121 Inf 0.01
[1] " "
     D d2 d1 m2 m3        lB  uB     P
[1,] 5  2  1  2  3 0.0022676 Inf 0.001
[1] " "
     D d2 d1 m2 m3         lB  uB     P
[1,] 5  2  1  2  3 0.00067338 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 27
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m2 m3      lB  uB   P
[1,] 3  3  1  2  3 0.22891 Inf 0.1
[1] " "
     D d3 d1 m2 m3       lB  uB    P
[1,] 3  3  1  2  3 0.016779 Inf 0.01
[1] " "
     D d3 d1 m2 m3        lB  uB     P
[1,] 3  3  1  2  3 0.0025161 Inf 0.001
[1] " "
     D d3 d1 m2 m3         lB  uB     P
[1,] 3  3  1  2  3 0.00074737 Inf 1e-04
[1] " "
     D d3 d1 m2 m3      lB  uB   P
[1,] 4  3  1  2  3 0.21161 Inf 0.1
[1] " "
     D d3 d1 m2 m3       lB  uB    P
[1,] 4  3  1  2  3 0.015772 Inf 0.01
[1] " "
     D d3 d1 m2 m3        lB  uB     P
[1,] 4  3  1  2  3 0.0023651 Inf 0.001
[1] " "
     D d3 d1 m2 m3         lB  uB     P
[1,] 4  3  1  2  3 0.00070247 Inf 1e-04
[1] " "
     D d3 d1 m2 m3    lB  uB   P
[1,] 5  3  1  2  3 0.201 Inf 0.1
[1] " "
     D d3 d1 m2 m3      lB  uB    P
[1,] 5  3  1  2  3 0.01512 Inf 0.01
[1] " "
     D d3 d1 m2 m3        lB  uB     P
[1,] 5  3  1  2  3 0.0022672 Inf 0.001
[1] " "
     D d3 d1 m2 m3         lB  uB     P
[1,] 5  3  1  2  3 0.00067333 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 28
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m2 m3      lB  uB   P
[1,] 1  1  2  3 0.35112 Inf 0.1
[1] " "
     D d1 m2 m3       lB  uB    P
[1,] 1  1  2  3 0.021076 Inf 0.01
[1] " "
     D d1 m2 m3        lB  uB     P
[1,] 1  1  2  3 0.0031612 Inf 0.001
[1] " "
     D d1 m2 m3         lB  uB     P
[1,] 1  1  2  3 0.00093409 Inf 1e-04
[1] " "
     D d1 m2 m3      lB  uB   P
[1,] 2  1  2  3 0.25991 Inf 0.1
[1] " "
     D d1 m2 m3       lB  uB    P
[1,] 2  1  2  3 0.017265 Inf 0.01
[1] " "
     D d1 m2 m3        lB  uB     P
[1,] 2  1  2  3 0.0025896 Inf 0.001
[1] " "
     D d1 m2 m3         lB  uB     P
[1,] 2  1  2  3 0.00076407 Inf 1e-04
[1] " "
     D d1 m2 m3      lB  uB   P
[1,] 3  1  2  3 0.22684 Inf 0.1
[1] " "
     D d1 m2 m3       lB  uB    P
[1,] 3  1  2  3 0.015612 Inf 0.01
[1] " "
     D d1 m2 m3        lB  uB     P
[1,] 3  1  2  3 0.0023416 Inf 0.001
[1] " "
     D d1 m2 m3         lB  uB     P
[1,] 3  1  2  3 0.00069032 Inf 1e-04
[1] " "
     D d1 m2 m3      lB  uB   P
[1,] 4  1  2  3 0.20969 Inf 0.1
[1] " "
     D d1 m2 m3       lB  uB    P
[1,] 4  1  2  3 0.014675 Inf 0.01
[1] " "
     D d1 m2 m3        lB  uB     P
[1,] 4  1  2  3 0.0022011 Inf 0.001
[1] " "
     D d1 m2 m3         lB  uB     P
[1,] 4  1  2  3 0.00064859 Inf 1e-04
[1] " "
     D d1 m2 m3      lB  uB   P
[1,] 5  1  2  3 0.19918 Inf 0.1
[1] " "
     D d1 m2 m3      lB  uB    P
[1,] 5  1  2  3 0.01407 Inf 0.01
[1] " "
     D d1 m2 m3        lB  uB     P
[1,] 5  1  2  3 0.0021103 Inf 0.001
[1] " "
     D d1 m2 m3         lB  uB     P
[1,] 5  1  2  3 0.00062147 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 29
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m2 m3      lB  uB   P
[1,] 3  3  2  2  3 0.34009 Inf 0.1
[1] " "
     D d3 d2 m2 m3       lB  uB    P
[1,] 3  3  2  2  3 0.016779 Inf 0.01
[1] " "
     D d3 d2 m2 m3        lB  uB     P
[1,] 3  3  2  2  3 0.0025167 Inf 0.001
[1] " "
     D d3 d2 m2 m3         lB  uB     P
[1,] 3  3  2  2  3 0.00074727 Inf 1e-04
[1] " "
     D d3 d2 m2 m3      lB  uB   P
[1,] 4  3  2  2  3 0.30429 Inf 0.1
[1] " "
     D d3 d2 m2 m3       lB  uB    P
[1,] 4  3  2  2  3 0.015773 Inf 0.01
[1] " "
     D d3 d2 m2 m3        lB  uB     P
[1,] 4  3  2  2  3 0.0023657 Inf 0.001
[1] " "
     D d3 d2 m2 m3         lB  uB     P
[1,] 4  3  2  2  3 0.00070236 Inf 1e-04
[1] " "
     D d3 d2 m2 m3      lB  uB   P
[1,] 5  3  2  2  3 0.28288 Inf 0.1
[1] " "
     D d3 d2 m2 m3       lB  uB    P
[1,] 5  3  2  2  3 0.015122 Inf 0.01
[1] " "
     D d3 d2 m2 m3        lB  uB     P
[1,] 5  3  2  2  3 0.0022681 Inf 0.001
[1] " "
     D d3 d2 m2 m3         lB  uB     P
[1,] 5  3  2  2  3 0.00067333 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 30
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m2 m3      lB  uB   P
[1,] 2  2  2  3 0.37543 Inf 0.1
[1] " "
     D d2 m2 m3       lB  uB    P
[1,] 2  2  2  3 0.017265 Inf 0.01
[1] " "
     D d2 m2 m3        lB  uB     P
[1,] 2  2  2  3 0.0025896 Inf 0.001
[1] " "
     D d2 m2 m3         lB  uB     P
[1,] 2  2  2  3 0.00076514 Inf 1e-04
[1] " "
     D d2 m2 m3      lB  uB   P
[1,] 3  2  2  3 0.33631 Inf 0.1
[1] " "
     D d2 m2 m3       lB  uB    P
[1,] 3  2  2  3 0.015612 Inf 0.01
[1] " "
     D d2 m2 m3        lB  uB     P
[1,] 3  2  2  3 0.0023416 Inf 0.001
[1] " "
     D d2 m2 m3         lB  uB     P
[1,] 3  2  2  3 0.00069075 Inf 1e-04
[1] " "
     D d2 m2 m3      lB  uB   P
[1,] 4  2  2  3 0.30087 Inf 0.1
[1] " "
     D d2 m2 m3       lB  uB    P
[1,] 4  2  2  3 0.014675 Inf 0.01
[1] " "
     D d2 m2 m3        lB  uB     P
[1,] 4  2  2  3 0.0022011 Inf 0.001
[1] " "
     D d2 m2 m3         lB  uB     P
[1,] 4  2  2  3 0.00064875 Inf 1e-04
[1] " "
     D d2 m2 m3      lB  uB   P
[1,] 5  2  2  3 0.27968 Inf 0.1
[1] " "
     D d2 m2 m3      lB  uB    P
[1,] 5  2  2  3 0.01407 Inf 0.01
[1] " "
     D d2 m2 m3        lB  uB     P
[1,] 5  2  2  3 0.0021103 Inf 0.001
[1] " "
     D d2 m2 m3         lB  uB     P
[1,] 5  2  2  3 0.00062126 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 31
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m2 m3      lB  uB   P
[1,] 3  3  2  3 0.34302 Inf 0.1
[1] " "
     D d3 m2 m3       lB  uB    P
[1,] 3  3  2  3 0.015612 Inf 0.01
[1] " "
     D d3 m2 m3        lB  uB     P
[1,] 3  3  2  3 0.0023416 Inf 0.001
[1] " "
     D d3 m2 m3        lB  uB     P
[1,] 3  3  2  3 0.0006915 Inf 1e-04
[1] " "
     D d3 m2 m3      lB  uB   P
[1,] 4  3  2  3 0.32504 Inf 0.1
[1] " "
     D d3 m2 m3       lB  uB    P
[1,] 4  3  2  3 0.014675 Inf 0.01
[1] " "
     D d3 m2 m3        lB  uB     P
[1,] 4  3  2  3 0.0022011 Inf 0.001
[1] " "
     D d3 m2 m3         lB  uB     P
[1,] 4  3  2  3 0.00064869 Inf 1e-04
[1] " "
     D d3 m2 m3      lB  uB   P
[1,] 5  3  2  3 0.31357 Inf 0.1
[1] " "
     D d3 m2 m3      lB  uB    P
[1,] 5  3  2  3 0.01407 Inf 0.01
[1] " "
     D d3 m2 m3        lB  uB     P
[1,] 5  3  2  3 0.0021103 Inf 0.001
[1] " "
     D d3 m2 m3         lB  uB     P
[1,] 5  3  2  3 0.00062112 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 32
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m2 m3 lB  uB   P
[1,] 0  2  3  1 Inf 0.1
[1] " "
     D m2 m3       lB  uB    P
[1,] 0  2  3 0.049106 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 0  2  3 0.0073654 Inf 0.001
[1] " "
     D m2 m3        lB  uB     P
[1,] 0  2  3 0.0021808 Inf 1e-04
[1] " "
     D m2 m3      lB  uB   P
[1,] 1  2  3 0.43683 Inf 0.1
[1] " "
     D m2 m3       lB  uB    P
[1,] 1  2  3 0.020717 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 1  2  3 0.0031073 Inf 0.001
[1] " "
     D m2 m3         lB  uB     P
[1,] 1  2  3 0.00091897 Inf 1e-04
[1] " "
     D m2 m3      lB  uB   P
[1,] 2  2  3 0.36214 Inf 0.1
[1] " "
     D m2 m3       lB  uB    P
[1,] 2  2  3 0.016971 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 2  2  3 0.0025455 Inf 0.001
[1] " "
     D m2 m3         lB  uB     P
[1,] 2  2  3 0.00075233 Inf 1e-04
[1] " "
     D m2 m3      lB  uB   P
[1,] 3  2  3 0.33072 Inf 0.1
[1] " "
     D m2 m3       lB  uB    P
[1,] 3  2  3 0.015346 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 3  2  3 0.0023017 Inf 0.001
[1] " "
     D m2 m3         lB  uB     P
[1,] 3  2  3 0.00067983 Inf 1e-04
[1] " "
     D m2 m3      lB  uB   P
[1,] 4  2  3 0.31329 Inf 0.1
[1] " "
     D m2 m3       lB  uB    P
[1,] 4  2  3 0.014425 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 4  2  3 0.0021636 Inf 0.001
[1] " "
     D m2 m3         lB  uB     P
[1,] 4  2  3 0.00063774 Inf 1e-04
[1] " "
     D m2 m3      lB  uB   P
[1,] 5  2  3 0.30218 Inf 0.1
[1] " "
     D m2 m3      lB  uB    P
[1,] 5  2  3 0.01383 Inf 0.01
[1] " "
     D m2 m3        lB  uB     P
[1,] 5  2  3 0.0020743 Inf 0.001
[1] " "
     D m2 m3         lB  uB     P
[1,] 5  2  3 0.00060817 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 33
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m1 m3      lB  uB   P
[1,] 3  3  2  1  0  1  3 0.14177 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m3       lB  uB    P
[1,] 3  3  2  1  0  1  3 0.017023 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m3        lB  uB     P
[1,] 3  3  2  1  0  1  3 0.0025211 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m3         lB  uB     P
[1,] 3  3  2  1  0  1  3 0.00073504 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m3     lB  uB   P
[1,] 4  3  2  1  0  1  3 0.1382 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m3       lB  uB    P
[1,] 4  3  2  1  0  1  3 0.016002 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m3        lB  uB     P
[1,] 4  3  2  1  0  1  3 0.0023662 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m3         lB  uB     P
[1,] 4  3  2  1  0  1  3 0.00068698 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m3      lB  uB   P
[1,] 5  3  2  1  0  1  3 0.13593 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m3       lB  uB    P
[1,] 5  3  2  1  0  1  3 0.015341 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m3        lB  uB     P
[1,] 5  3  2  1  0  1  3 0.0022658 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m3         lB  uB     P
[1,] 5  3  2  1  0  1  3 0.00065579 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 34
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m1 m3      lB  uB   P
[1,] 2  2  1  0  1  3 0.14757 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m3       lB  uB    P
[1,] 2  2  1  0  1  3 0.018765 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m3        lB  uB     P
[1,] 2  2  1  0  1  3 0.0027843 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m3        lB  uB     P
[1,] 2  2  1  0  1  3 0.0008158 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m3     lB  uB   P
[1,] 3  2  1  0  1  3 0.1412 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m3       lB  uB    P
[1,] 3  2  1  0  1  3 0.016968 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m3        lB  uB     P
[1,] 3  2  1  0  1  3 0.0025112 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m3         lB  uB     P
[1,] 3  2  1  0  1  3 0.00073184 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m3      lB  uB   P
[1,] 4  2  1  0  1  3 0.13766 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m3      lB  uB    P
[1,] 4  2  1  0  1  3 0.01595 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m3        lB  uB     P
[1,] 4  2  1  0  1  3 0.0023567 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m3         lB  uB     P
[1,] 4  2  1  0  1  3 0.00068391 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m3     lB  uB   P
[1,] 5  2  1  0  1  3 0.1354 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m3       lB  uB    P
[1,] 5  2  1  0  1  3 0.015292 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m3        lB  uB     P
[1,] 5  2  1  0  1  3 0.0022568 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m3         lB  uB     P
[1,] 5  2  1  0  1  3 0.00065264 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 35
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m1 m3     lB  uB   P
[1,] 3  3  1  0  1  3 0.1412 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m3       lB  uB    P
[1,] 3  3  1  0  1  3 0.016968 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m3        lB  uB     P
[1,] 3  3  1  0  1  3 0.0025112 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m3         lB  uB     P
[1,] 3  3  1  0  1  3 0.00073187 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m3      lB  uB   P
[1,] 4  3  1  0  1  3 0.13766 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m3      lB  uB    P
[1,] 4  3  1  0  1  3 0.01595 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m3        lB  uB     P
[1,] 4  3  1  0  1  3 0.0023566 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m3         lB  uB     P
[1,] 4  3  1  0  1  3 0.00068392 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m3     lB  uB   P
[1,] 5  3  1  0  1  3 0.1354 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m3       lB  uB    P
[1,] 5  3  1  0  1  3 0.015291 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m3        lB  uB     P
[1,] 5  3  1  0  1  3 0.0022563 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m3         lB  uB     P
[1,] 5  3  1  0  1  3 0.00065277 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 36
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m1 m3      lB  uB   P
[1,] 1  1  0  1  3 0.16171 Inf 0.1
[1] " "
     D d1 m0 m1 m3      lB  uB    P
[1,] 1  1  0  1  3 0.02265 Inf 0.01
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 1  1  0  1  3 0.0033729 Inf 0.001
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 1  1  0  1  3 0.0009903 Inf 1e-04
[1] " "
     D d1 m0 m1 m3      lB  uB   P
[1,] 2  1  0  1  3 0.14671 Inf 0.1
[1] " "
     D d1 m0 m1 m3       lB  uB    P
[1,] 2  1  0  1  3 0.018556 Inf 0.01
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 2  1  0  1  3 0.0027505 Inf 0.001
[1] " "
     D d1 m0 m1 m3         lB  uB     P
[1,] 2  1  0  1  3 0.00080555 Inf 1e-04
[1] " "
     D d1 m0 m1 m3      lB  uB   P
[1,] 3  1  0  1  3 0.14034 Inf 0.1
[1] " "
     D d1 m0 m1 m3       lB  uB    P
[1,] 3  1  0  1  3 0.016779 Inf 0.01
[1] " "
     D d1 m0 m1 m3      lB  uB     P
[1,] 3  1  0  1  3 0.00248 Inf 0.001
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 3  1  0  1  3 0.0007223 Inf 1e-04
[1] " "
     D d1 m0 m1 m3      lB  uB   P
[1,] 4  1  0  1  3 0.13681 Inf 0.1
[1] " "
     D d1 m0 m1 m3       lB  uB    P
[1,] 4  1  0  1  3 0.015773 Inf 0.01
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 4  1  0  1  3 0.0023267 Inf 0.001
[1] " "
     D d1 m0 m1 m3         lB  uB     P
[1,] 4  1  0  1  3 0.00067467 Inf 1e-04
[1] " "
     D d1 m0 m1 m3      lB  uB   P
[1,] 5  1  0  1  3 0.13456 Inf 0.1
[1] " "
     D d1 m0 m1 m3       lB  uB    P
[1,] 5  1  0  1  3 0.015122 Inf 0.01
[1] " "
     D d1 m0 m1 m3        lB  uB     P
[1,] 5  1  0  1  3 0.0022273 Inf 0.001
[1] " "
     D d1 m0 m1 m3         lB  uB     P
[1,] 5  1  0  1  3 0.00064348 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 37
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m1 m3     lB  uB   P
[1,] 3  3  2  0  1  3 0.1412 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m3       lB  uB    P
[1,] 3  3  2  0  1  3 0.016968 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m3        lB  uB     P
[1,] 3  3  2  0  1  3 0.0025228 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m3         lB  uB     P
[1,] 3  3  2  0  1  3 0.00073606 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m3      lB  uB   P
[1,] 4  3  2  0  1  3 0.13766 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m3       lB  uB    P
[1,] 4  3  2  0  1  3 0.015951 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m3        lB  uB     P
[1,] 4  3  2  0  1  3 0.0023661 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m3         lB  uB     P
[1,] 4  3  2  0  1  3 0.00069011 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m3     lB  uB   P
[1,] 5  3  2  0  1  3 0.1354 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m3       lB  uB    P
[1,] 5  3  2  0  1  3 0.015293 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m3        lB  uB     P
[1,] 5  3  2  0  1  3 0.0022647 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m3         lB  uB     P
[1,] 5  3  2  0  1  3 0.00065976 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 38
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m1 m3      lB  uB   P
[1,] 2  2  0  1  3 0.14671 Inf 0.1
[1] " "
     D d2 m0 m1 m3       lB  uB    P
[1,] 2  2  0  1  3 0.018555 Inf 0.01
[1] " "
     D d2 m0 m1 m3        lB  uB     P
[1,] 2  2  0  1  3 0.0027602 Inf 0.001
[1] " "
     D d2 m0 m1 m3         lB  uB     P
[1,] 2  2  0  1  3 0.00080642 Inf 1e-04
[1] " "
     D d2 m0 m1 m3      lB  uB   P
[1,] 3  2  0  1  3 0.14034 Inf 0.1
[1] " "
     D d2 m0 m1 m3       lB  uB    P
[1,] 3  2  0  1  3 0.016778 Inf 0.01
[1] " "
     D d2 m0 m1 m3        lB  uB     P
[1,] 3  2  0  1  3 0.0024924 Inf 0.001
[1] " "
     D d2 m0 m1 m3         lB  uB     P
[1,] 3  2  0  1  3 0.00072619 Inf 1e-04
[1] " "
     D d2 m0 m1 m3      lB  uB   P
[1,] 4  2  0  1  3 0.13681 Inf 0.1
[1] " "
     D d2 m0 m1 m3       lB  uB    P
[1,] 4  2  0  1  3 0.015772 Inf 0.01
[1] " "
     D d2 m0 m1 m3        lB  uB     P
[1,] 4  2  0  1  3 0.0023371 Inf 0.001
[1] " "
     D d2 m0 m1 m3         lB  uB     P
[1,] 4  2  0  1  3 0.00068059 Inf 1e-04
[1] " "
     D d2 m0 m1 m3      lB  uB   P
[1,] 5  2  0  1  3 0.13456 Inf 0.1
[1] " "
     D d2 m0 m1 m3       lB  uB    P
[1,] 5  2  0  1  3 0.015122 Inf 0.01
[1] " "
     D d2 m0 m1 m3        lB  uB     P
[1,] 5  2  0  1  3 0.0022359 Inf 0.001
[1] " "
     D d2 m0 m1 m3         lB  uB     P
[1,] 5  2  0  1  3 0.00065078 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 39
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m1 m3      lB  uB   P
[1,] 3  3  0  1  3 0.14034 Inf 0.1
[1] " "
     D d3 m0 m1 m3       lB  uB    P
[1,] 3  3  0  1  3 0.016778 Inf 0.01
[1] " "
     D d3 m0 m1 m3       lB  uB     P
[1,] 3  3  0  1  3 0.002494 Inf 0.001
[1] " "
     D d3 m0 m1 m3         lB  uB     P
[1,] 3  3  0  1  3 0.00072617 Inf 1e-04
[1] " "
     D d3 m0 m1 m3      lB  uB   P
[1,] 4  3  0  1  3 0.13681 Inf 0.1
[1] " "
     D d3 m0 m1 m3       lB  uB    P
[1,] 4  3  0  1  3 0.015772 Inf 0.01
[1] " "
     D d3 m0 m1 m3        lB  uB     P
[1,] 4  3  0  1  3 0.0023436 Inf 0.001
[1] " "
     D d3 m0 m1 m3         lB  uB     P
[1,] 4  3  0  1  3 0.00068061 Inf 1e-04
[1] " "
     D d3 m0 m1 m3      lB  uB   P
[1,] 5  3  0  1  3 0.13456 Inf 0.1
[1] " "
     D d3 m0 m1 m3       lB  uB    P
[1,] 5  3  0  1  3 0.015122 Inf 0.01
[1] " "
     D d3 m0 m1 m3       lB  uB     P
[1,] 5  3  0  1  3 0.002246 Inf 0.001
[1] " "
     D d3 m0 m1 m3         lB  uB     P
[1,] 5  3  0  1  3 0.00065064 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 40
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m1 m3      lB  uB   P
[1,] 0  0  1  3 0.23957 Inf 0.1
[1] " "
     D m0 m1 m3       lB  uB    P
[1,] 0  0  1  3 0.049958 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 0  0  1  3 0.0074456 Inf 0.001
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 0  0  1  3 0.0021973 Inf 1e-04
[1] " "
     D m0 m1 m3      lB  uB   P
[1,] 1  0  1  3 0.15906 Inf 0.1
[1] " "
     D m0 m1 m3       lB  uB    P
[1,] 1  0  1  3 0.021076 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 1  0  1  3 0.0031271 Inf 0.001
[1] " "
     D m0 m1 m3         lB  uB     P
[1,] 1  0  1  3 0.00091561 Inf 1e-04
[1] " "
     D m0 m1 m3      lB  uB   P
[1,] 2  0  1  3 0.14425 Inf 0.1
[1] " "
     D m0 m1 m3       lB  uB    P
[1,] 2  0  1  3 0.017265 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 2  0  1  3 0.0025557 Inf 0.001
[1] " "
     D m0 m1 m3         lB  uB     P
[1,] 2  0  1  3 0.00074396 Inf 1e-04
[1] " "
     D m0 m1 m3      lB  uB   P
[1,] 3  0  1  3 0.13796 Inf 0.1
[1] " "
     D m0 m1 m3       lB  uB    P
[1,] 3  0  1  3 0.015612 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 3  0  1  3 0.0023079 Inf 0.001
[1] " "
     D m0 m1 m3         lB  uB     P
[1,] 3  0  1  3 0.00066894 Inf 1e-04
[1] " "
     D m0 m1 m3      lB  uB   P
[1,] 4  0  1  3 0.13448 Inf 0.1
[1] " "
     D m0 m1 m3       lB  uB    P
[1,] 4  0  1  3 0.014675 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 4  0  1  3 0.0021673 Inf 0.001
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 4  0  1  3 0.0006262 Inf 1e-04
[1] " "
     D m0 m1 m3      lB  uB   P
[1,] 5  0  1  3 0.13227 Inf 0.1
[1] " "
     D m0 m1 m3      lB  uB    P
[1,] 5  0  1  3 0.01407 Inf 0.01
[1] " "
     D m0 m1 m3        lB  uB     P
[1,] 5  0  1  3 0.0020769 Inf 0.001
[1] " "
     D m0 m1 m3         lB  uB     P
[1,] 5  0  1  3 0.00059836 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 41
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m1 m3      lB  uB   P
[1,] 3  3  2  1  1  3 0.15442 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m3       lB  uB    P
[1,] 3  3  2  1  1  3 0.016968 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m3        lB  uB     P
[1,] 3  3  2  1  1  3 0.0025112 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m3         lB  uB     P
[1,] 3  3  2  1  1  3 0.00073187 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m3      lB  uB   P
[1,] 4  3  2  1  1  3 0.14975 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m3      lB  uB    P
[1,] 4  3  2  1  1  3 0.01595 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m3        lB  uB     P
[1,] 4  3  2  1  1  3 0.0023566 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m3         lB  uB     P
[1,] 4  3  2  1  1  3 0.00068392 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m3      lB  uB   P
[1,] 5  3  2  1  1  3 0.14674 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m3       lB  uB    P
[1,] 5  3  2  1  1  3 0.015291 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m3        lB  uB     P
[1,] 5  3  2  1  1  3 0.0022564 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m3         lB  uB     P
[1,] 5  3  2  1  1  3 0.00065264 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 42
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m1 m3      lB  uB   P
[1,] 2  2  1  1  3 0.16149 Inf 0.1
[1] " "
     D d2 d1 m1 m3       lB  uB    P
[1,] 2  2  1  1  3 0.018556 Inf 0.01
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 2  2  1  1  3 0.0027505 Inf 0.001
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 2  2  1  1  3 0.0008055 Inf 1e-04
[1] " "
     D d2 d1 m1 m3      lB  uB   P
[1,] 3  2  1  1  3 0.15327 Inf 0.1
[1] " "
     D d2 d1 m1 m3       lB  uB    P
[1,] 3  2  1  1  3 0.016779 Inf 0.01
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 3  2  1  1  3 0.0024799 Inf 0.001
[1] " "
     D d2 d1 m1 m3         lB  uB     P
[1,] 3  2  1  1  3 0.00072232 Inf 1e-04
[1] " "
     D d2 d1 m1 m3      lB  uB   P
[1,] 4  2  1  1  3 0.14866 Inf 0.1
[1] " "
     D d2 d1 m1 m3       lB  uB    P
[1,] 4  2  1  1  3 0.015772 Inf 0.01
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 4  2  1  1  3 0.0023269 Inf 0.001
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 4  2  1  1  3 0.0006747 Inf 1e-04
[1] " "
     D d2 d1 m1 m3      lB  uB   P
[1,] 5  2  1  1  3 0.14568 Inf 0.1
[1] " "
     D d2 d1 m1 m3       lB  uB    P
[1,] 5  2  1  1  3 0.015121 Inf 0.01
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 5  2  1  1  3 0.0022271 Inf 0.001
[1] " "
     D d2 d1 m1 m3        lB  uB     P
[1,] 5  2  1  1  3 0.0006438 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 43
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m1 m3      lB  uB   P
[1,] 3  3  1  1  3 0.15327 Inf 0.1
[1] " "
     D d3 d1 m1 m3       lB  uB    P
[1,] 3  3  1  1  3 0.016779 Inf 0.01
[1] " "
     D d3 d1 m1 m3      lB  uB     P
[1,] 3  3  1  1  3 0.00248 Inf 0.001
[1] " "
     D d3 d1 m1 m3         lB  uB     P
[1,] 3  3  1  1  3 0.00072228 Inf 1e-04
[1] " "
     D d3 d1 m1 m3      lB  uB   P
[1,] 4  3  1  1  3 0.14866 Inf 0.1
[1] " "
     D d3 d1 m1 m3       lB  uB    P
[1,] 4  3  1  1  3 0.015772 Inf 0.01
[1] " "
     D d3 d1 m1 m3        lB  uB     P
[1,] 4  3  1  1  3 0.0023268 Inf 0.001
[1] " "
     D d3 d1 m1 m3         lB  uB     P
[1,] 4  3  1  1  3 0.00067474 Inf 1e-04
[1] " "
     D d3 d1 m1 m3      lB  uB   P
[1,] 5  3  1  1  3 0.14568 Inf 0.1
[1] " "
     D d3 d1 m1 m3      lB  uB    P
[1,] 5  3  1  1  3 0.01512 Inf 0.01
[1] " "
     D d3 d1 m1 m3        lB  uB     P
[1,] 5  3  1  1  3 0.0022276 Inf 0.001
[1] " "
     D d3 d1 m1 m3         lB  uB     P
[1,] 5  3  1  1  3 0.00064371 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 44
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m1 m3      lB  uB   P
[1,] 1  1  1  3 0.17823 Inf 0.1
[1] " "
     D d1 m1 m3       lB  uB    P
[1,] 1  1  1  3 0.021076 Inf 0.01
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 1  1  1  3 0.0031301 Inf 0.001
[1] " "
     D d1 m1 m3         lB  uB     P
[1,] 1  1  1  3 0.00092244 Inf 1e-04
[1] " "
     D d1 m1 m3      lB  uB   P
[1,] 2  1  1  3 0.15842 Inf 0.1
[1] " "
     D d1 m1 m3       lB  uB    P
[1,] 2  1  1  3 0.017265 Inf 0.01
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 2  1  1  3 0.0025475 Inf 0.001
[1] " "
     D d1 m1 m3         lB  uB     P
[1,] 2  1  1  3 0.00074498 Inf 1e-04
[1] " "
     D d1 m1 m3      lB  uB   P
[1,] 3  1  1  3 0.15038 Inf 0.1
[1] " "
     D d1 m1 m3       lB  uB    P
[1,] 3  1  1  3 0.015612 Inf 0.01
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 3  1  1  3 0.0022936 Inf 0.001
[1] " "
     D d1 m1 m3         lB  uB     P
[1,] 3  1  1  3 0.00066659 Inf 1e-04
[1] " "
     D d1 m1 m3      lB  uB   P
[1,] 4  1  1  3 0.14588 Inf 0.1
[1] " "
     D d1 m1 m3       lB  uB    P
[1,] 4  1  1  3 0.014675 Inf 0.01
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 4  1  1  3 0.0021496 Inf 0.001
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 4  1  1  3 0.0006217 Inf 1e-04
[1] " "
     D d1 m1 m3      lB  uB   P
[1,] 5  1  1  3 0.14297 Inf 0.1
[1] " "
     D d1 m1 m3      lB  uB    P
[1,] 5  1  1  3 0.01407 Inf 0.01
[1] " "
     D d1 m1 m3        lB  uB     P
[1,] 5  1  1  3 0.0020564 Inf 0.001
[1] " "
     D d1 m1 m3         lB  uB     P
[1,] 5  1  1  3 0.00059171 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 45
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m1 m3      lB  uB   P
[1,] 3  3  2  1  3 0.15329 Inf 0.1
[1] " "
     D d3 d2 m1 m3       lB  uB    P
[1,] 3  3  2  1  3 0.016779 Inf 0.01
[1] " "
     D d3 d2 m1 m3        lB  uB     P
[1,] 3  3  2  1  3 0.0024925 Inf 0.001
[1] " "
     D d3 d2 m1 m3         lB  uB     P
[1,] 3  3  2  1  3 0.00073323 Inf 1e-04
[1] " "
     D d3 d2 m1 m3      lB  uB   P
[1,] 4  3  2  1  3 0.14883 Inf 0.1
[1] " "
     D d3 d2 m1 m3       lB  uB    P
[1,] 4  3  2  1  3 0.015773 Inf 0.01
[1] " "
     D d3 d2 m1 m3        lB  uB     P
[1,] 4  3  2  1  3 0.0023371 Inf 0.001
[1] " "
     D d3 d2 m1 m3         lB  uB     P
[1,] 4  3  2  1  3 0.00068486 Inf 1e-04
[1] " "
     D d3 d2 m1 m3      lB  uB   P
[1,] 5  3  2  1  3 0.14602 Inf 0.1
[1] " "
     D d3 d2 m1 m3       lB  uB    P
[1,] 5  3  2  1  3 0.015122 Inf 0.01
[1] " "
     D d3 d2 m1 m3        lB  uB     P
[1,] 5  3  2  1  3 0.0022367 Inf 0.001
[1] " "
     D d3 d2 m1 m3         lB  uB     P
[1,] 5  3  2  1  3 0.00065359 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 46
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m1 m3      lB  uB   P
[1,] 2  2  1  3 0.15842 Inf 0.1
[1] " "
     D d2 m1 m3       lB  uB    P
[1,] 2  2  1  3 0.017265 Inf 0.01
[1] " "
     D d2 m1 m3        lB  uB     P
[1,] 2  2  1  3 0.0025687 Inf 0.001
[1] " "
     D d2 m1 m3         lB  uB     P
[1,] 2  2  1  3 0.00075862 Inf 1e-04
[1] " "
     D d2 m1 m3      lB  uB   P
[1,] 3  2  1  3 0.15038 Inf 0.1
[1] " "
     D d2 m1 m3       lB  uB    P
[1,] 3  2  1  3 0.015612 Inf 0.01
[1] " "
     D d2 m1 m3        lB  uB     P
[1,] 3  2  1  3 0.0023112 Inf 0.001
[1] " "
     D d2 m1 m3         lB  uB     P
[1,] 3  2  1  3 0.00067933 Inf 1e-04
[1] " "
     D d2 m1 m3    lB  uB   P
[1,] 4  2  1  3 0.146 Inf 0.1
[1] " "
     D d2 m1 m3       lB  uB    P
[1,] 4  2  1  3 0.014675 Inf 0.01
[1] " "
     D d2 m1 m3       lB  uB     P
[1,] 4  2  1  3 0.002165 Inf 0.001
[1] " "
     D d2 m1 m3         lB  uB     P
[1,] 4  2  1  3 0.00063385 Inf 1e-04
[1] " "
     D d2 m1 m3      lB  uB   P
[1,] 5  2  1  3 0.14325 Inf 0.1
[1] " "
     D d2 m1 m3      lB  uB    P
[1,] 5  2  1  3 0.01407 Inf 0.01
[1] " "
     D d2 m1 m3        lB  uB     P
[1,] 5  2  1  3 0.0020697 Inf 0.001
[1] " "
     D d2 m1 m3        lB  uB     P
[1,] 5  2  1  3 0.0006042 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 47
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m1 m3      lB  uB   P
[1,] 3  3  1  3 0.15038 Inf 0.1
[1] " "
     D d3 m1 m3       lB  uB    P
[1,] 3  3  1  3 0.015612 Inf 0.01
[1] " "
     D d3 m1 m3        lB  uB     P
[1,] 3  3  1  3 0.0023253 Inf 0.001
[1] " "
     D d3 m1 m3         lB  uB     P
[1,] 3  3  1  3 0.00068727 Inf 1e-04
[1] " "
     D d3 m1 m3    lB  uB   P
[1,] 4  3  1  3 0.146 Inf 0.1
[1] " "
     D d3 m1 m3       lB  uB    P
[1,] 4  3  1  3 0.014675 Inf 0.01
[1] " "
     D d3 m1 m3        lB  uB     P
[1,] 4  3  1  3 0.0021775 Inf 0.001
[1] " "
     D d3 m1 m3         lB  uB     P
[1,] 4  3  1  3 0.00064124 Inf 1e-04
[1] " "
     D d3 m1 m3      lB  uB   P
[1,] 5  3  1  3 0.14325 Inf 0.1
[1] " "
     D d3 m1 m3      lB  uB    P
[1,] 5  3  1  3 0.01407 Inf 0.01
[1] " "
     D d3 m1 m3        lB  uB     P
[1,] 5  3  1  3 0.0020816 Inf 0.001
[1] " "
     D d3 m1 m3         lB  uB     P
[1,] 5  3  1  3 0.00061171 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 48
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m1 m3      lB  uB   P
[1,] 0  1  3 0.34711 Inf 0.1
[1] " "
     D m1 m3       lB  uB    P
[1,] 0  1  3 0.049106 Inf 0.01
[1] " "
     D m1 m3        lB  uB     P
[1,] 0  1  3 0.0073621 Inf 0.001
[1] " "
     D m1 m3        lB  uB     P
[1,] 0  1  3 0.0021872 Inf 1e-04
[1] " "
     D m1 m3      lB  uB   P
[1,] 1  1  3 0.17355 Inf 0.1
[1] " "
     D m1 m3       lB  uB    P
[1,] 1  1  3 0.020717 Inf 0.01
[1] " "
     D m1 m3       lB  uB     P
[1,] 1  1  3 0.003105 Inf 0.001
[1] " "
     D m1 m3         lB  uB     P
[1,] 1  1  3 0.00092197 Inf 1e-04
[1] " "
     D m1 m3      lB  uB   P
[1,] 2  1  3 0.15427 Inf 0.1
[1] " "
     D m1 m3       lB  uB    P
[1,] 2  1  3 0.016971 Inf 0.01
[1] " "
     D m1 m3       lB  uB     P
[1,] 2  1  3 0.002543 Inf 0.001
[1] " "
     D m1 m3         lB  uB     P
[1,] 2  1  3 0.00075486 Inf 1e-04
[1] " "
     D m1 m3      lB  uB   P
[1,] 3  1  3 0.14644 Inf 0.1
[1] " "
     D m1 m3       lB  uB    P
[1,] 3  1  3 0.015346 Inf 0.01
[1] " "
     D m1 m3        lB  uB     P
[1,] 3  1  3 0.0022992 Inf 0.001
[1] " "
     D m1 m3         lB  uB     P
[1,] 3  1  3 0.00068195 Inf 1e-04
[1] " "
     D m1 m3      lB  uB   P
[1,] 4  1  3 0.14217 Inf 0.1
[1] " "
     D m1 m3       lB  uB    P
[1,] 4  1  3 0.014425 Inf 0.01
[1] " "
     D m1 m3        lB  uB     P
[1,] 4  1  3 0.0021611 Inf 0.001
[1] " "
     D m1 m3         lB  uB     P
[1,] 4  1  3 0.00064071 Inf 1e-04
[1] " "
     D m1 m3      lB  uB   P
[1,] 5  1  3 0.13949 Inf 0.1
[1] " "
     D m1 m3      lB  uB    P
[1,] 5  1  3 0.01383 Inf 0.01
[1] " "
     D m1 m3        lB  uB     P
[1,] 5  1  3 0.0020657 Inf 0.001
[1] " "
     D m1 m3         lB  uB     P
[1,] 5  1  3 0.00061142 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 49
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m3      lB  uB   P
[1,] 3  3  2  1  0  3 0.15658 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m3       lB  uB    P
[1,] 3  3  2  1  0  3 0.016968 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m3        lB  uB     P
[1,] 3  3  2  1  0  3 0.0025324 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m3         lB  uB     P
[1,] 3  3  2  1  0  3 0.00075099 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m3      lB  uB   P
[1,] 4  3  2  1  0  3 0.15078 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m3      lB  uB    P
[1,] 4  3  2  1  0  3 0.01595 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m3        lB  uB     P
[1,] 4  3  2  1  0  3 0.0023769 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m3         lB  uB     P
[1,] 4  3  2  1  0  3 0.00070423 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m3      lB  uB   P
[1,] 5  3  2  1  0  3 0.14681 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m3       lB  uB    P
[1,] 5  3  2  1  0  3 0.015291 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m3        lB  uB     P
[1,] 5  3  2  1  0  3 0.0022758 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m3         lB  uB     P
[1,] 5  3  2  1  0  3 0.00067361 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 50
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m3      lB  uB   P
[1,] 2  2  1  0  3 0.16572 Inf 0.1
[1] " "
     D d2 d1 m0 m3       lB  uB    P
[1,] 2  2  1  0  3 0.018555 Inf 0.01
[1] " "
     D d2 d1 m0 m3        lB  uB     P
[1,] 2  2  1  0  3 0.0027738 Inf 0.001
[1] " "
     D d2 d1 m0 m3         lB  uB     P
[1,] 2  2  1  0  3 0.00082345 Inf 1e-04
[1] " "
     D d2 d1 m0 m3     lB  uB   P
[1,] 3  2  1  0  3 0.1561 Inf 0.1
[1] " "
     D d2 d1 m0 m3       lB  uB    P
[1,] 3  2  1  0  3 0.016778 Inf 0.01
[1] " "
     D d2 d1 m0 m3        lB  uB     P
[1,] 3  2  1  0  3 0.0025032 Inf 0.001
[1] " "
     D d2 d1 m0 m3         lB  uB     P
[1,] 3  2  1  0  3 0.00074231 Inf 1e-04
[1] " "
     D d2 d1 m0 m3      lB  uB   P
[1,] 4  2  1  0  3 0.15015 Inf 0.1
[1] " "
     D d2 d1 m0 m3       lB  uB    P
[1,] 4  2  1  0  3 0.015772 Inf 0.01
[1] " "
     D d2 d1 m0 m3        lB  uB     P
[1,] 4  2  1  0  3 0.0023495 Inf 0.001
[1] " "
     D d2 d1 m0 m3         lB  uB     P
[1,] 4  2  1  0  3 0.00069595 Inf 1e-04
[1] " "
     D d2 d1 m0 m3      lB  uB   P
[1,] 5  2  1  0  3 0.14603 Inf 0.1
[1] " "
     D d2 d1 m0 m3       lB  uB    P
[1,] 5  2  1  0  3 0.015121 Inf 0.01
[1] " "
     D d2 d1 m0 m3       lB  uB     P
[1,] 5  2  1  0  3 0.002249 Inf 0.001
[1] " "
     D d2 d1 m0 m3         lB  uB     P
[1,] 5  2  1  0  3 0.00066494 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 51
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m3      lB  uB   P
[1,] 3  3  1  0  3 0.15566 Inf 0.1
[1] " "
     D d3 d1 m0 m3       lB  uB    P
[1,] 3  3  1  0  3 0.016778 Inf 0.01
[1] " "
     D d3 d1 m0 m3        lB  uB     P
[1,] 3  3  1  0  3 0.0025033 Inf 0.001
[1] " "
     D d3 d1 m0 m3         lB  uB     P
[1,] 3  3  1  0  3 0.00074231 Inf 1e-04
[1] " "
     D d3 d1 m0 m3      lB  uB   P
[1,] 4  3  1  0  3 0.14989 Inf 0.1
[1] " "
     D d3 d1 m0 m3       lB  uB    P
[1,] 4  3  1  0  3 0.015772 Inf 0.01
[1] " "
     D d3 d1 m0 m3        lB  uB     P
[1,] 4  3  1  0  3 0.0023495 Inf 0.001
[1] " "
     D d3 d1 m0 m3       lB  uB     P
[1,] 4  3  1  0  3 0.000696 Inf 1e-04
[1] " "
     D d3 d1 m0 m3      lB  uB   P
[1,] 5  3  1  0  3 0.14598 Inf 0.1
[1] " "
     D d3 d1 m0 m3      lB  uB    P
[1,] 5  3  1  0  3 0.01512 Inf 0.01
[1] " "
     D d3 d1 m0 m3        lB  uB     P
[1,] 5  3  1  0  3 0.0022494 Inf 0.001
[1] " "
     D d3 d1 m0 m3         lB  uB     P
[1,] 5  3  1  0  3 0.00066562 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 52
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m3     lB  uB   P
[1,] 1  1  0  3 0.1826 Inf 0.1
[1] " "
     D d1 m0 m3       lB  uB    P
[1,] 1  1  0  3 0.021074 Inf 0.01
[1] " "
     D d1 m0 m3        lB  uB     P
[1,] 1  1  0  3 0.0031567 Inf 0.001
[1] " "
     D d1 m0 m3         lB  uB     P
[1,] 1  1  0  3 0.00093793 Inf 1e-04
[1] " "
     D d1 m0 m3      lB  uB   P
[1,] 2  1  0  3 0.16298 Inf 0.1
[1] " "
     D d1 m0 m3       lB  uB    P
[1,] 2  1  0  3 0.017264 Inf 0.01
[1] " "
     D d1 m0 m3        lB  uB     P
[1,] 2  1  0  3 0.0025789 Inf 0.001
[1] " "
     D d1 m0 m3         lB  uB     P
[1,] 2  1  0  3 0.00076545 Inf 1e-04
[1] " "
     D d1 m0 m3      lB  uB   P
[1,] 3  1  0  3 0.15288 Inf 0.1
[1] " "
     D d1 m0 m3       lB  uB    P
[1,] 3  1  0  3 0.015611 Inf 0.01
[1] " "
     D d1 m0 m3        lB  uB     P
[1,] 3  1  0  3 0.0023261 Inf 0.001
[1] " "
     D d1 m0 m3         lB  uB     P
[1,] 3  1  0  3 0.00068963 Inf 1e-04
[1] " "
     D d1 m0 m3     lB  uB   P
[1,] 4  1  0  3 0.1467 Inf 0.1
[1] " "
     D d1 m0 m3       lB  uB    P
[1,] 4  1  0  3 0.014675 Inf 0.01
[1] " "
     D d1 m0 m3        lB  uB     P
[1,] 4  1  0  3 0.0021822 Inf 0.001
[1] " "
     D d1 m0 m3         lB  uB     P
[1,] 4  1  0  3 0.00064619 Inf 1e-04
[1] " "
     D d1 m0 m3      lB  uB   P
[1,] 5  1  0  3 0.14252 Inf 0.1
[1] " "
     D d1 m0 m3       lB  uB    P
[1,] 5  1  0  3 0.014069 Inf 0.01
[1] " "
     D d1 m0 m3        lB  uB     P
[1,] 5  1  0  3 0.0020886 Inf 0.001
[1] " "
     D d1 m0 m3         lB  uB     P
[1,] 5  1  0  3 0.00061768 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 53
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m3      lB  uB   P
[1,] 3  3  2  0  3 0.15646 Inf 0.1
[1] " "
     D d3 d2 m0 m3       lB  uB    P
[1,] 3  3  2  0  3 0.016778 Inf 0.01
[1] " "
     D d3 d2 m0 m3        lB  uB     P
[1,] 3  3  2  0  3 0.0025089 Inf 0.001
[1] " "
     D d3 d2 m0 m3         lB  uB     P
[1,] 3  3  2  0  3 0.00074506 Inf 1e-04
[1] " "
     D d3 d2 m0 m3      lB  uB   P
[1,] 4  3  2  0  3 0.15025 Inf 0.1
[1] " "
     D d3 d2 m0 m3       lB  uB    P
[1,] 4  3  2  0  3 0.015772 Inf 0.01
[1] " "
     D d3 d2 m0 m3        lB  uB     P
[1,] 4  3  2  0  3 0.0023542 Inf 0.001
[1] " "
     D d3 d2 m0 m3         lB  uB     P
[1,] 4  3  2  0  3 0.00069868 Inf 1e-04
[1] " "
     D d3 d2 m0 m3      lB  uB   P
[1,] 5  3  2  0  3 0.14604 Inf 0.1
[1] " "
     D d3 d2 m0 m3       lB  uB    P
[1,] 5  3  2  0  3 0.015122 Inf 0.01
[1] " "
     D d3 d2 m0 m3        lB  uB     P
[1,] 5  3  2  0  3 0.0022536 Inf 0.001
[1] " "
     D d3 d2 m0 m3       lB  uB     P
[1,] 5  3  2  0  3 0.000668 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 54
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m3      lB  uB   P
[1,] 2  2  0  3 0.16298 Inf 0.1
[1] " "
     D d2 m0 m3       lB  uB    P
[1,] 2  2  0  3 0.017263 Inf 0.01
[1] " "
     D d2 m0 m3        lB  uB     P
[1,] 2  2  0  3 0.0025858 Inf 0.001
[1] " "
     D d2 m0 m3        lB  uB     P
[1,] 2  2  0  3 0.0007683 Inf 1e-04
[1] " "
     D d2 m0 m3      lB  uB   P
[1,] 3  2  0  3 0.15288 Inf 0.1
[1] " "
     D d2 m0 m3      lB  uB    P
[1,] 3  2  0  3 0.01561 Inf 0.01
[1] " "
     D d2 m0 m3        lB  uB     P
[1,] 3  2  0  3 0.0023331 Inf 0.001
[1] " "
     D d2 m0 m3         lB  uB     P
[1,] 3  2  0  3 0.00069281 Inf 1e-04
[1] " "
     D d2 m0 m3     lB  uB   P
[1,] 4  2  0  3 0.1467 Inf 0.1
[1] " "
     D d2 m0 m3       lB  uB    P
[1,] 4  2  0  3 0.014674 Inf 0.01
[1] " "
     D d2 m0 m3        lB  uB     P
[1,] 4  2  0  3 0.0021885 Inf 0.001
[1] " "
     D d2 m0 m3         lB  uB     P
[1,] 4  2  0  3 0.00064924 Inf 1e-04
[1] " "
     D d2 m0 m3      lB  uB   P
[1,] 5  2  0  3 0.14252 Inf 0.1
[1] " "
     D d2 m0 m3       lB  uB    P
[1,] 5  2  0  3 0.014069 Inf 0.01
[1] " "
     D d2 m0 m3        lB  uB     P
[1,] 5  2  0  3 0.0020947 Inf 0.001
[1] " "
     D d2 m0 m3         lB  uB     P
[1,] 5  2  0  3 0.00062098 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 55
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m3      lB  uB   P
[1,] 3  3  0  3 0.15288 Inf 0.1
[1] " "
     D d3 m0 m3      lB  uB    P
[1,] 3  3  0  3 0.01561 Inf 0.01
[1] " "
     D d3 m0 m3        lB  uB     P
[1,] 3  3  0  3 0.0023382 Inf 0.001
[1] " "
     D d3 m0 m3         lB  uB     P
[1,] 3  3  0  3 0.00069442 Inf 1e-04
[1] " "
     D d3 m0 m3     lB  uB   P
[1,] 4  3  0  3 0.1467 Inf 0.1
[1] " "
     D d3 m0 m3       lB  uB    P
[1,] 4  3  0  3 0.014674 Inf 0.01
[1] " "
     D d3 m0 m3        lB  uB     P
[1,] 4  3  0  3 0.0021945 Inf 0.001
[1] " "
     D d3 m0 m3         lB  uB     P
[1,] 4  3  0  3 0.00065163 Inf 1e-04
[1] " "
     D d3 m0 m3      lB  uB   P
[1,] 5  3  0  3 0.14252 Inf 0.1
[1] " "
     D d3 m0 m3       lB  uB    P
[1,] 5  3  0  3 0.014069 Inf 0.01
[1] " "
     D d3 m0 m3        lB  uB     P
[1,] 5  3  0  3 0.0021001 Inf 0.001
[1] " "
     D d3 m0 m3        lB  uB     P
[1,] 5  3  0  3 0.0006232 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 56
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m3      lB  uB   P
[1,] 0  0  3 0.23695 Inf 0.1
[1] " "
     D m0 m3       lB  uB    P
[1,] 0  0  3 0.049106 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 0  0  3 0.0073654 Inf 0.001
[1] " "
     D m0 m3        lB  uB     P
[1,] 0  0  3 0.0021892 Inf 1e-04
[1] " "
     D m0 m3      lB  uB   P
[1,] 1  0  3 0.18049 Inf 0.1
[1] " "
     D m0 m3       lB  uB    P
[1,] 1  0  3 0.020717 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 1  0  3 0.0031073 Inf 0.001
[1] " "
     D m0 m3         lB  uB     P
[1,] 1  0  3 0.00092358 Inf 1e-04
[1] " "
     D m0 m3      lB  uB   P
[1,] 2  0  3 0.16106 Inf 0.1
[1] " "
     D m0 m3       lB  uB    P
[1,] 2  0  3 0.016971 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 2  0  3 0.0025455 Inf 0.001
[1] " "
     D m0 m3        lB  uB     P
[1,] 2  0  3 0.0007566 Inf 1e-04
[1] " "
     D m0 m3      lB  uB   P
[1,] 3  0  3 0.15106 Inf 0.1
[1] " "
     D m0 m3       lB  uB    P
[1,] 3  0  3 0.015346 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 3  0  3 0.0023017 Inf 0.001
[1] " "
     D m0 m3         lB  uB     P
[1,] 3  0  3 0.00068414 Inf 1e-04
[1] " "
     D m0 m3      lB  uB   P
[1,] 4  0  3 0.14494 Inf 0.1
[1] " "
     D m0 m3       lB  uB    P
[1,] 4  0  3 0.014425 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 4  0  3 0.0021636 Inf 0.001
[1] " "
     D m0 m3        lB  uB     P
[1,] 4  0  3 0.0006431 Inf 1e-04
[1] " "
     D m0 m3     lB  uB   P
[1,] 5  0  3 0.1408 Inf 0.1
[1] " "
     D m0 m3      lB  uB    P
[1,] 5  0  3 0.01383 Inf 0.01
[1] " "
     D m0 m3        lB  uB     P
[1,] 5  0  3 0.0020743 Inf 0.001
[1] " "
     D m0 m3         lB  uB     P
[1,] 5  0  3 0.00061656 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 57
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m3      lB  uB   P
[1,] 3  3  2  1  3 0.28638 Inf 0.1
[1] " "
     D d3 d2 d1 m3       lB  uB    P
[1,] 3  3  2  1  3 0.016779 Inf 0.01
[1] " "
     D d3 d2 d1 m3        lB  uB     P
[1,] 3  3  2  1  3 0.0025161 Inf 0.001
[1] " "
     D d3 d2 d1 m3         lB  uB     P
[1,] 3  3  2  1  3 0.00074787 Inf 1e-04
[1] " "
     D d3 d2 d1 m3     lB  uB   P
[1,] 4  3  2  1  3 0.2567 Inf 0.1
[1] " "
     D d3 d2 d1 m3       lB  uB    P
[1,] 4  3  2  1  3 0.015772 Inf 0.01
[1] " "
     D d3 d2 d1 m3       lB  uB     P
[1,] 4  3  2  1  3 0.002365 Inf 0.001
[1] " "
     D d3 d2 d1 m3         lB  uB     P
[1,] 4  3  2  1  3 0.00070253 Inf 1e-04
[1] " "
     D d3 d2 d1 m3      lB  uB   P
[1,] 5  3  2  1  3 0.23864 Inf 0.1
[1] " "
     D d3 d2 d1 m3      lB  uB    P
[1,] 5  3  2  1  3 0.01512 Inf 0.01
[1] " "
     D d3 d2 d1 m3        lB  uB     P
[1,] 5  3  2  1  3 0.0022671 Inf 0.001
[1] " "
     D d3 d2 d1 m3         lB  uB     P
[1,] 5  3  2  1  3 0.00067323 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 58
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m3      lB  uB   P
[1,] 2  2  1  3 0.33305 Inf 0.1
[1] " "
     D d2 d1 m3       lB  uB    P
[1,] 2  2  1  3 0.017265 Inf 0.01
[1] " "
     D d2 d1 m3        lB  uB     P
[1,] 2  2  1  3 0.0025896 Inf 0.001
[1] " "
     D d2 d1 m3         lB  uB     P
[1,] 2  2  1  3 0.00076962 Inf 1e-04
[1] " "
     D d2 d1 m3      lB  uB   P
[1,] 3  2  1  3 0.27683 Inf 0.1
[1] " "
     D d2 d1 m3       lB  uB    P
[1,] 3  2  1  3 0.015612 Inf 0.01
[1] " "
     D d2 d1 m3        lB  uB     P
[1,] 3  2  1  3 0.0023415 Inf 0.001
[1] " "
     D d2 d1 m3         lB  uB     P
[1,] 3  2  1  3 0.00069585 Inf 1e-04
[1] " "
     D d2 d1 m3      lB  uB   P
[1,] 4  2  1  3 0.24805 Inf 0.1
[1] " "
     D d2 d1 m3       lB  uB    P
[1,] 4  2  1  3 0.014675 Inf 0.01
[1] " "
     D d2 d1 m3        lB  uB     P
[1,] 4  2  1  3 0.0022009 Inf 0.001
[1] " "
     D d2 d1 m3         lB  uB     P
[1,] 4  2  1  3 0.00065394 Inf 1e-04
[1] " "
     D d2 d1 m3      lB  uB   P
[1,] 5  2  1  3 0.23053 Inf 0.1
[1] " "
     D d2 d1 m3       lB  uB    P
[1,] 5  2  1  3 0.014069 Inf 0.01
[1] " "
     D d2 d1 m3        lB  uB     P
[1,] 5  2  1  3 0.0021098 Inf 0.001
[1] " "
     D d2 d1 m3        lB  uB     P
[1,] 5  2  1  3 0.0006265 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 59
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m3      lB  uB   P
[1,] 3  3  1  3 0.27683 Inf 0.1
[1] " "
     D d3 d1 m3       lB  uB    P
[1,] 3  3  1  3 0.015611 Inf 0.01
[1] " "
     D d3 d1 m3       lB  uB     P
[1,] 3  3  1  3 0.002341 Inf 0.001
[1] " "
     D d3 d1 m3         lB  uB     P
[1,] 3  3  1  3 0.00069583 Inf 1e-04
[1] " "
     D d3 d1 m3      lB  uB   P
[1,] 4  3  1  3 0.24805 Inf 0.1
[1] " "
     D d3 d1 m3       lB  uB    P
[1,] 4  3  1  3 0.014674 Inf 0.01
[1] " "
     D d3 d1 m3        lB  uB     P
[1,] 4  3  1  3 0.0022004 Inf 0.001
[1] " "
     D d3 d1 m3         lB  uB     P
[1,] 4  3  1  3 0.00065361 Inf 1e-04
[1] " "
     D d3 d1 m3      lB  uB   P
[1,] 5  3  1  3 0.23053 Inf 0.1
[1] " "
     D d3 d1 m3       lB  uB    P
[1,] 5  3  1  3 0.014068 Inf 0.01
[1] " "
     D d3 d1 m3        lB  uB     P
[1,] 5  3  1  3 0.0021093 Inf 0.001
[1] " "
     D d3 d1 m3         lB  uB     P
[1,] 5  3  1  3 0.00062633 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 60
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m3     lB  uB   P
[1,] 1  1  3 0.4871 Inf 0.1
[1] " "
     D d1 m3       lB  uB    P
[1,] 1  1  3 0.020717 Inf 0.01
[1] " "
     D d1 m3        lB  uB     P
[1,] 1  1  3 0.0031073 Inf 0.001
[1] " "
     D d1 m3         lB  uB     P
[1,] 1  1  3 0.00092358 Inf 1e-04
[1] " "
     D d1 m3      lB  uB   P
[1,] 2  1  3 0.32873 Inf 0.1
[1] " "
     D d1 m3       lB  uB    P
[1,] 2  1  3 0.016971 Inf 0.01
[1] " "
     D d1 m3        lB  uB     P
[1,] 2  1  3 0.0025455 Inf 0.001
[1] " "
     D d1 m3        lB  uB     P
[1,] 2  1  3 0.0007566 Inf 1e-04
[1] " "
     D d1 m3      lB  uB   P
[1,] 3  1  3 0.27322 Inf 0.1
[1] " "
     D d1 m3       lB  uB    P
[1,] 3  1  3 0.015346 Inf 0.01
[1] " "
     D d1 m3        lB  uB     P
[1,] 3  1  3 0.0023017 Inf 0.001
[1] " "
     D d1 m3         lB  uB     P
[1,] 3  1  3 0.00068414 Inf 1e-04
[1] " "
     D d1 m3     lB  uB   P
[1,] 4  1  3 0.2448 Inf 0.1
[1] " "
     D d1 m3       lB  uB    P
[1,] 4  1  3 0.014425 Inf 0.01
[1] " "
     D d1 m3        lB  uB     P
[1,] 4  1  3 0.0021636 Inf 0.001
[1] " "
     D d1 m3        lB  uB     P
[1,] 4  1  3 0.0006431 Inf 1e-04
[1] " "
     D d1 m3      lB  uB   P
[1,] 5  1  3 0.22751 Inf 0.1
[1] " "
     D d1 m3      lB  uB    P
[1,] 5  1  3 0.01383 Inf 0.01
[1] " "
     D d1 m3        lB  uB     P
[1,] 5  1  3 0.0020743 Inf 0.001
[1] " "
     D d1 m3         lB  uB     P
[1,] 5  1  3 0.00061656 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 61
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m3      lB  uB   P
[1,] 3  3  2  3 0.46748 Inf 0.1
[1] " "
     D d3 d2 m3       lB  uB    P
[1,] 3  3  2  3 0.015612 Inf 0.01
[1] " "
     D d3 d2 m3        lB  uB     P
[1,] 3  3  2  3 0.0023416 Inf 0.001
[1] " "
     D d3 d2 m3         lB  uB     P
[1,] 3  3  2  3 0.00069599 Inf 1e-04
[1] " "
     D d3 d2 m3      lB  uB   P
[1,] 4  3  2  3 0.43948 Inf 0.1
[1] " "
     D d3 d2 m3       lB  uB    P
[1,] 4  3  2  3 0.014675 Inf 0.01
[1] " "
     D d3 d2 m3        lB  uB     P
[1,] 4  3  2  3 0.0022011 Inf 0.001
[1] " "
     D d3 d2 m3         lB  uB     P
[1,] 4  3  2  3 0.00065423 Inf 1e-04
[1] " "
     D d3 d2 m3      lB  uB   P
[1,] 5  3  2  3 0.41429 Inf 0.1
[1] " "
     D d3 d2 m3      lB  uB    P
[1,] 5  3  2  3 0.01407 Inf 0.01
[1] " "
     D d3 d2 m3        lB  uB     P
[1,] 5  3  2  3 0.0021103 Inf 0.001
[1] " "
     D d3 d2 m3         lB  uB     P
[1,] 5  3  2  3 0.00062719 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 62
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m3      lB  uB   P
[1,] 2  2  3 0.51307 Inf 0.1
[1] " "
     D d2 m3       lB  uB    P
[1,] 2  2  3 0.016971 Inf 0.01
[1] " "
     D d2 m3        lB  uB     P
[1,] 2  2  3 0.0025455 Inf 0.001
[1] " "
     D d2 m3        lB  uB     P
[1,] 2  2  3 0.0007566 Inf 1e-04
[1] " "
     D d2 m3      lB  uB   P
[1,] 3  2  3 0.46516 Inf 0.1
[1] " "
     D d2 m3       lB  uB    P
[1,] 3  2  3 0.015346 Inf 0.01
[1] " "
     D d2 m3        lB  uB     P
[1,] 3  2  3 0.0023017 Inf 0.001
[1] " "
     D d2 m3         lB  uB     P
[1,] 3  2  3 0.00068414 Inf 1e-04
[1] " "
     D d2 m3      lB  uB   P
[1,] 4  2  3 0.43718 Inf 0.1
[1] " "
     D d2 m3       lB  uB    P
[1,] 4  2  3 0.014425 Inf 0.01
[1] " "
     D d2 m3        lB  uB     P
[1,] 4  2  3 0.0021636 Inf 0.001
[1] " "
     D d2 m3        lB  uB     P
[1,] 4  2  3 0.0006431 Inf 1e-04
[1] " "
     D d2 m3      lB  uB   P
[1,] 5  2  3 0.40442 Inf 0.1
[1] " "
     D d2 m3      lB  uB    P
[1,] 5  2  3 0.01383 Inf 0.01
[1] " "
     D d2 m3        lB  uB     P
[1,] 5  2  3 0.0020743 Inf 0.001
[1] " "
     D d2 m3         lB  uB     P
[1,] 5  2  3 0.00061656 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 63
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m3      lB  uB   P
[1,] 3  3  3 0.46516 Inf 0.1
[1] " "
     D d3 m3       lB  uB    P
[1,] 3  3  3 0.015346 Inf 0.01
[1] " "
     D d3 m3        lB  uB     P
[1,] 3  3  3 0.0023017 Inf 0.001
[1] " "
     D d3 m3         lB  uB     P
[1,] 3  3  3 0.00068414 Inf 1e-04
[1] " "
     D d3 m3      lB  uB   P
[1,] 4  3  3 0.43718 Inf 0.1
[1] " "
     D d3 m3       lB  uB    P
[1,] 4  3  3 0.014425 Inf 0.01
[1] " "
     D d3 m3        lB  uB     P
[1,] 4  3  3 0.0021636 Inf 0.001
[1] " "
     D d3 m3        lB  uB     P
[1,] 4  3  3 0.0006431 Inf 1e-04
[1] " "
     D d3 m3     lB  uB   P
[1,] 5  3  3 0.4188 Inf 0.1
[1] " "
     D d3 m3      lB  uB    P
[1,] 5  3  3 0.01383 Inf 0.01
[1] " "
     D d3 m3        lB  uB     P
[1,] 5  3  3 0.0020743 Inf 0.001
[1] " "
     D d3 m3         lB  uB     P
[1,] 5  3  3 0.00061656 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 64
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m3 lB  uB   P
[1,] 0  3  1 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 0  3 0.047086 Inf 0.01
[1] " "
     D m3        lB  uB     P
[1,] 0  3 0.0070625 Inf 0.001
[1] " "
     D m3        lB  uB     P
[1,] 0  3 0.0020992 Inf 1e-04
[1] " "
     D m3      lB  uB   P
[1,] 1  3 0.60952 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 1  3 0.019865 Inf 0.01
[1] " "
     D m3        lB  uB     P
[1,] 1  3 0.0029795 Inf 0.001
[1] " "
     D m3        lB  uB     P
[1,] 1  3 0.0008856 Inf 1e-04
[1] " "
     D m3      lB  uB   P
[1,] 2  3 0.50736 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 2  3 0.016273 Inf 0.01
[1] " "
     D m3        lB  uB     P
[1,] 2  3 0.0024408 Inf 0.001
[1] " "
     D m3         lB  uB     P
[1,] 2  3 0.00072549 Inf 1e-04
[1] " "
     D m3      lB  uB   P
[1,] 3  3 0.45947 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 3  3 0.014715 Inf 0.01
[1] " "
     D m3       lB  uB     P
[1,] 3  3 0.002207 Inf 0.001
[1] " "
     D m3       lB  uB     P
[1,] 3  3 0.000656 Inf 1e-04
[1] " "
     D m3      lB  uB   P
[1,] 4  3 0.43154 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 4  3 0.013832 Inf 0.01
[1] " "
     D m3        lB  uB     P
[1,] 4  3 0.0020746 Inf 0.001
[1] " "
     D m3         lB  uB     P
[1,] 4  3 0.00061665 Inf 1e-04
[1] " "
     D m3      lB  uB   P
[1,] 5  3 0.41322 Inf 0.1
[1] " "
     D m3       lB  uB    P
[1,] 5  3 0.013261 Inf 0.01
[1] " "
     D m3       lB  uB     P
[1,] 5  3 0.001989 Inf 0.001
[1] " "
     D m3        lB  uB     P
[1,] 5  3 0.0005912 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 65
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m1 m2      lB  uB   P
[1,] 3  3  2  1  0  1  2 0.14177 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2      lB  uB    P
[1,] 3  3  2  1  0  1  2 0.02024 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 3  3  2  1  0  1  2 0.0055997 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 3  3  2  1  0  1  2 0.0024268 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m2     lB  uB   P
[1,] 4  3  2  1  0  1  2 0.1382 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2       lB  uB    P
[1,] 4  3  2  1  0  1  2 0.019269 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 4  3  2  1  0  1  2 0.0053136 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 4  3  2  1  0  1  2 0.0023023 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1 m2      lB  uB   P
[1,] 5  3  2  1  0  1  2 0.13593 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1 m2       lB  uB    P
[1,] 5  3  2  1  0  1  2 0.018651 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 5  3  2  1  0  1  2 0.0051301 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1 m2        lB  uB     P
[1,] 5  3  2  1  0  1  2 0.0022223 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 66
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m1 m2      lB  uB   P
[1,] 2  2  1  0  1  2 0.14757 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2       lB  uB    P
[1,] 2  2  1  0  1  2 0.021188 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 2  2  1  0  1  2 0.0058866 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2       lB  uB     P
[1,] 2  2  1  0  1  2 0.002538 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2     lB  uB   P
[1,] 3  2  1  0  1  2 0.1412 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2       lB  uB    P
[1,] 3  2  1  0  1  2 0.019506 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 3  2  1  0  1  2 0.0053923 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 3  2  1  0  1  2 0.0023221 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2      lB  uB   P
[1,] 4  2  1  0  1  2 0.13766 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2       lB  uB    P
[1,] 4  2  1  0  1  2 0.018567 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 4  2  1  0  1  2 0.0051152 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 4  2  1  0  1  2 0.0022014 Inf 1e-04
[1] " "
     D d2 d1 m0 m1 m2     lB  uB   P
[1,] 5  2  1  0  1  2 0.1354 Inf 0.1
[1] " "
     D d2 d1 m0 m1 m2       lB  uB    P
[1,] 5  2  1  0  1  2 0.017968 Inf 0.01
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 5  2  1  0  1  2 0.0049375 Inf 0.001
[1] " "
     D d2 d1 m0 m1 m2        lB  uB     P
[1,] 5  2  1  0  1  2 0.0021237 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 67
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m1 m2     lB  uB   P
[1,] 3  3  1  0  1  2 0.1412 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2       lB  uB    P
[1,] 3  3  1  0  1  2 0.019521 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 3  3  1  0  1  2 0.0053923 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 3  3  1  0  1  2 0.0023221 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m2      lB  uB   P
[1,] 4  3  1  0  1  2 0.13766 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2       lB  uB    P
[1,] 4  3  1  0  1  2 0.018582 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 4  3  1  0  1  2 0.0051152 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 4  3  1  0  1  2 0.0022014 Inf 1e-04
[1] " "
     D d3 d1 m0 m1 m2     lB  uB   P
[1,] 5  3  1  0  1  2 0.1354 Inf 0.1
[1] " "
     D d3 d1 m0 m1 m2       lB  uB    P
[1,] 5  3  1  0  1  2 0.017975 Inf 0.01
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 5  3  1  0  1  2 0.0049377 Inf 0.001
[1] " "
     D d3 d1 m0 m1 m2        lB  uB     P
[1,] 5  3  1  0  1  2 0.0021238 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 68
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m1 m2      lB  uB   P
[1,] 1  1  0  1  2 0.16171 Inf 0.1
[1] " "
     D d1 m0 m1 m2       lB  uB    P
[1,] 1  1  0  1  2 0.024938 Inf 0.01
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 1  1  0  1  2 0.0069681 Inf 0.001
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 1  1  0  1  2 0.0030147 Inf 1e-04
[1] " "
     D d1 m0 m1 m2      lB  uB   P
[1,] 2  1  0  1  2 0.14671 Inf 0.1
[1] " "
     D d1 m0 m1 m2       lB  uB    P
[1,] 2  1  0  1  2 0.021018 Inf 0.01
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 2  1  0  1  2 0.0058358 Inf 0.001
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 2  1  0  1  2 0.0025095 Inf 1e-04
[1] " "
     D d1 m0 m1 m2      lB  uB   P
[1,] 3  1  0  1  2 0.14034 Inf 0.1
[1] " "
     D d1 m0 m1 m2       lB  uB    P
[1,] 3  1  0  1  2 0.019364 Inf 0.01
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 3  1  0  1  2 0.0053441 Inf 0.001
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 3  1  0  1  2 0.0022946 Inf 1e-04
[1] " "
     D d1 m0 m1 m2      lB  uB   P
[1,] 4  1  0  1  2 0.13681 Inf 0.1
[1] " "
     D d1 m0 m1 m2       lB  uB    P
[1,] 4  1  0  1  2 0.018445 Inf 0.01
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 4  1  0  1  2 0.0050684 Inf 0.001
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 4  1  0  1  2 0.0021745 Inf 1e-04
[1] " "
     D d1 m0 m1 m2      lB  uB   P
[1,] 5  1  0  1  2 0.13456 Inf 0.1
[1] " "
     D d1 m0 m1 m2       lB  uB    P
[1,] 5  1  0  1  2 0.017858 Inf 0.01
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 5  1  0  1  2 0.0048916 Inf 0.001
[1] " "
     D d1 m0 m1 m2        lB  uB     P
[1,] 5  1  0  1  2 0.0020974 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 69
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m1 m2     lB  uB   P
[1,] 3  3  2  0  1  2 0.1412 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2       lB  uB    P
[1,] 3  3  2  0  1  2 0.019505 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2        lB  uB     P
[1,] 3  3  2  0  1  2 0.0054328 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2        lB  uB     P
[1,] 3  3  2  0  1  2 0.0023492 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m2      lB  uB   P
[1,] 4  3  2  0  1  2 0.13766 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2       lB  uB    P
[1,] 4  3  2  0  1  2 0.018567 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2        lB  uB     P
[1,] 4  3  2  0  1  2 0.0051459 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2        lB  uB     P
[1,] 4  3  2  0  1  2 0.0022227 Inf 1e-04
[1] " "
     D d3 d2 m0 m1 m2     lB  uB   P
[1,] 5  3  2  0  1  2 0.1354 Inf 0.1
[1] " "
     D d3 d2 m0 m1 m2       lB  uB    P
[1,] 5  3  2  0  1  2 0.017968 Inf 0.01
[1] " "
     D d3 d2 m0 m1 m2        lB  uB     P
[1,] 5  3  2  0  1  2 0.0049613 Inf 0.001
[1] " "
     D d3 d2 m0 m1 m2       lB  uB     P
[1,] 5  3  2  0  1  2 0.002142 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 70
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m1 m2      lB  uB   P
[1,] 2  2  0  1  2 0.14671 Inf 0.1
[1] " "
     D d2 m0 m1 m2       lB  uB    P
[1,] 2  2  0  1  2 0.021027 Inf 0.01
[1] " "
     D d2 m0 m1 m2       lB  uB     P
[1,] 2  2  0  1  2 0.005874 Inf 0.001
[1] " "
     D d2 m0 m1 m2       lB  uB     P
[1,] 2  2  0  1  2 0.002541 Inf 1e-04
[1] " "
     D d2 m0 m1 m2      lB  uB   P
[1,] 3  2  0  1  2 0.14034 Inf 0.1
[1] " "
     D d2 m0 m1 m2       lB  uB    P
[1,] 3  2  0  1  2 0.019347 Inf 0.01
[1] " "
     D d2 m0 m1 m2        lB  uB     P
[1,] 3  2  0  1  2 0.0053852 Inf 0.001
[1] " "
     D d2 m0 m1 m2        lB  uB     P
[1,] 3  2  0  1  2 0.0023231 Inf 1e-04
[1] " "
     D d2 m0 m1 m2      lB  uB   P
[1,] 4  2  0  1  2 0.13681 Inf 0.1
[1] " "
     D d2 m0 m1 m2       lB  uB    P
[1,] 4  2  0  1  2 0.018414 Inf 0.01
[1] " "
     D d2 m0 m1 m2       lB  uB     P
[1,] 4  2  0  1  2 0.005099 Inf 0.001
[1] " "
     D d2 m0 m1 m2        lB  uB     P
[1,] 4  2  0  1  2 0.0021973 Inf 1e-04
[1] " "
     D d2 m0 m1 m2      lB  uB   P
[1,] 5  2  0  1  2 0.13456 Inf 0.1
[1] " "
     D d2 m0 m1 m2       lB  uB    P
[1,] 5  2  0  1  2 0.017819 Inf 0.01
[1] " "
     D d2 m0 m1 m2        lB  uB     P
[1,] 5  2  0  1  2 0.0049145 Inf 0.001
[1] " "
     D d2 m0 m1 m2        lB  uB     P
[1,] 5  2  0  1  2 0.0021168 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 71
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m1 m2      lB  uB   P
[1,] 3  3  0  1  2 0.14034 Inf 0.1
[1] " "
     D d3 m0 m1 m2       lB  uB    P
[1,] 3  3  0  1  2 0.019381 Inf 0.01
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 3  3  0  1  2 0.0054147 Inf 0.001
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 3  3  0  1  2 0.0023347 Inf 1e-04
[1] " "
     D d3 m0 m1 m2      lB  uB   P
[1,] 4  3  0  1  2 0.13681 Inf 0.1
[1] " "
     D d3 m0 m1 m2       lB  uB    P
[1,] 4  3  0  1  2 0.018433 Inf 0.01
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 4  3  0  1  2 0.0051408 Inf 0.001
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 4  3  0  1  2 0.0022193 Inf 1e-04
[1] " "
     D d3 m0 m1 m2      lB  uB   P
[1,] 5  3  0  1  2 0.13456 Inf 0.1
[1] " "
     D d3 m0 m1 m2       lB  uB    P
[1,] 5  3  0  1  2 0.017829 Inf 0.01
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 5  3  0  1  2 0.0049584 Inf 0.001
[1] " "
     D d3 m0 m1 m2        lB  uB     P
[1,] 5  3  0  1  2 0.0021393 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 72
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m1 m2      lB  uB   P
[1,] 0  0  1  2 0.23957 Inf 0.1
[1] " "
     D m0 m1 m2       lB  uB    P
[1,] 0  0  1  2 0.055672 Inf 0.01
[1] " "
     D m0 m1 m2       lB  uB     P
[1,] 0  0  1  2 0.015578 Inf 0.001
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 0  0  1  2 0.0067687 Inf 1e-04
[1] " "
     D m0 m1 m2      lB  uB   P
[1,] 1  0  1  2 0.15906 Inf 0.1
[1] " "
     D m0 m1 m2       lB  uB    P
[1,] 1  0  1  2 0.024743 Inf 0.01
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 1  0  1  2 0.0069026 Inf 0.001
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 1  0  1  2 0.0029715 Inf 1e-04
[1] " "
     D m0 m1 m2      lB  uB   P
[1,] 2  0  1  2 0.14425 Inf 0.1
[1] " "
     D m0 m1 m2       lB  uB    P
[1,] 2  0  1  2 0.020877 Inf 0.01
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 2  0  1  2 0.0058155 Inf 0.001
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 2  0  1  2 0.0024915 Inf 1e-04
[1] " "
     D m0 m1 m2      lB  uB   P
[1,] 3  0  1  2 0.13796 Inf 0.1
[1] " "
     D m0 m1 m2      lB  uB    P
[1,] 3  0  1  2 0.01924 Inf 0.01
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 3  0  1  2 0.0053551 Inf 0.001
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 3  0  1  2 0.0022875 Inf 1e-04
[1] " "
     D m0 m1 m2      lB  uB   P
[1,] 4  0  1  2 0.13448 Inf 0.1
[1] " "
     D m0 m1 m2       lB  uB    P
[1,] 4  0  1  2 0.018328 Inf 0.01
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 4  0  1  2 0.0050981 Inf 0.001
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 4  0  1  2 0.0021736 Inf 1e-04
[1] " "
     D m0 m1 m2      lB  uB   P
[1,] 5  0  1  2 0.13227 Inf 0.1
[1] " "
     D m0 m1 m2       lB  uB    P
[1,] 5  0  1  2 0.017745 Inf 0.01
[1] " "
     D m0 m1 m2        lB  uB     P
[1,] 5  0  1  2 0.0049327 Inf 0.001
[1] " "
     D m0 m1 m2       lB  uB     P
[1,] 5  0  1  2 0.002099 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 73
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m1 m2      lB  uB   P
[1,] 3  3  2  1  1  2 0.15442 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2       lB  uB    P
[1,] 3  3  2  1  1  2 0.019585 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2        lB  uB     P
[1,] 3  3  2  1  1  2 0.0054436 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2       lB  uB     P
[1,] 3  3  2  1  1  2 0.002322 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m2      lB  uB   P
[1,] 4  3  2  1  1  2 0.14975 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2       lB  uB    P
[1,] 4  3  2  1  1  2 0.018652 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2        lB  uB     P
[1,] 4  3  2  1  1  2 0.0051801 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2        lB  uB     P
[1,] 4  3  2  1  1  2 0.0022013 Inf 1e-04
[1] " "
     D d3 d2 d1 m1 m2      lB  uB   P
[1,] 5  3  2  1  1  2 0.14674 Inf 0.1
[1] " "
     D d3 d2 d1 m1 m2       lB  uB    P
[1,] 5  3  2  1  1  2 0.018055 Inf 0.01
[1] " "
     D d3 d2 d1 m1 m2        lB  uB     P
[1,] 5  3  2  1  1  2 0.0050094 Inf 0.001
[1] " "
     D d3 d2 d1 m1 m2        lB  uB     P
[1,] 5  3  2  1  1  2 0.0021239 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 74
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m1 m2      lB  uB   P
[1,] 2  2  1  1  2 0.16149 Inf 0.1
[1] " "
     D d2 d1 m1 m2       lB  uB    P
[1,] 2  2  1  1  2 0.021091 Inf 0.01
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 2  2  1  1  2 0.0058576 Inf 0.001
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 2  2  1  1  2 0.0025094 Inf 1e-04
[1] " "
     D d2 d1 m1 m2      lB  uB   P
[1,] 3  2  1  1  2 0.15327 Inf 0.1
[1] " "
     D d2 d1 m1 m2       lB  uB    P
[1,] 3  2  1  1  2 0.019436 Inf 0.01
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 3  2  1  1  2 0.0053875 Inf 0.001
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 3  2  1  1  2 0.0022946 Inf 1e-04
[1] " "
     D d2 d1 m1 m2      lB  uB   P
[1,] 4  2  1  1  2 0.14866 Inf 0.1
[1] " "
     D d2 d1 m1 m2       lB  uB    P
[1,] 4  2  1  1  2 0.018513 Inf 0.01
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 4  2  1  1  2 0.0051259 Inf 0.001
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 4  2  1  1  2 0.0021743 Inf 1e-04
[1] " "
     D d2 d1 m1 m2      lB  uB   P
[1,] 5  2  1  1  2 0.14568 Inf 0.1
[1] " "
     D d2 d1 m1 m2       lB  uB    P
[1,] 5  2  1  1  2 0.017922 Inf 0.01
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 5  2  1  1  2 0.0049567 Inf 0.001
[1] " "
     D d2 d1 m1 m2        lB  uB     P
[1,] 5  2  1  1  2 0.0020968 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 75
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m1 m2      lB  uB   P
[1,] 3  3  1  1  2 0.15327 Inf 0.1
[1] " "
     D d3 d1 m1 m2       lB  uB    P
[1,] 3  3  1  1  2 0.019434 Inf 0.01
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 3  3  1  1  2 0.0053875 Inf 0.001
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 3  3  1  1  2 0.0022946 Inf 1e-04
[1] " "
     D d3 d1 m1 m2      lB  uB   P
[1,] 4  3  1  1  2 0.14866 Inf 0.1
[1] " "
     D d3 d1 m1 m2       lB  uB    P
[1,] 4  3  1  1  2 0.018508 Inf 0.01
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 4  3  1  1  2 0.0051258 Inf 0.001
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 4  3  1  1  2 0.0021745 Inf 1e-04
[1] " "
     D d3 d1 m1 m2      lB  uB   P
[1,] 5  3  1  1  2 0.14568 Inf 0.1
[1] " "
     D d3 d1 m1 m2       lB  uB    P
[1,] 5  3  1  1  2 0.017915 Inf 0.01
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 5  3  1  1  2 0.0049582 Inf 0.001
[1] " "
     D d3 d1 m1 m2        lB  uB     P
[1,] 5  3  1  1  2 0.0020977 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 76
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m1 m2      lB  uB   P
[1,] 1  1  1  2 0.17823 Inf 0.1
[1] " "
     D d1 m1 m2       lB  uB    P
[1,] 1  1  1  2 0.024743 Inf 0.01
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 1  1  1  2 0.0068674 Inf 0.001
[1] " "
     D d1 m1 m2       lB  uB     P
[1,] 1  1  1  2 0.002965 Inf 1e-04
[1] " "
     D d1 m1 m2      lB  uB   P
[1,] 2  1  1  2 0.15842 Inf 0.1
[1] " "
     D d1 m1 m2       lB  uB    P
[1,] 2  1  1  2 0.020877 Inf 0.01
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 2  1  1  2 0.0057651 Inf 0.001
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 2  1  1  2 0.0024627 Inf 1e-04
[1] " "
     D d1 m1 m2      lB  uB   P
[1,] 3  1  1  2 0.15038 Inf 0.1
[1] " "
     D d1 m1 m2      lB  uB    P
[1,] 3  1  1  2 0.01924 Inf 0.01
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 3  1  1  2 0.0052984 Inf 0.001
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 3  1  1  2 0.0022488 Inf 1e-04
[1] " "
     D d1 m1 m2      lB  uB   P
[1,] 4  1  1  2 0.14588 Inf 0.1
[1] " "
     D d1 m1 m2       lB  uB    P
[1,] 4  1  1  2 0.018328 Inf 0.01
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 4  1  1  2 0.0050385 Inf 0.001
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 4  1  1  2 0.0021292 Inf 1e-04
[1] " "
     D d1 m1 m2      lB  uB   P
[1,] 5  1  1  2 0.14297 Inf 0.1
[1] " "
     D d1 m1 m2       lB  uB    P
[1,] 5  1  1  2 0.017745 Inf 0.01
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 5  1  1  2 0.0048717 Inf 0.001
[1] " "
     D d1 m1 m2        lB  uB     P
[1,] 5  1  1  2 0.0020522 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 77
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m1 m2      lB  uB   P
[1,] 3  3  2  1  2 0.15329 Inf 0.1
[1] " "
     D d3 d2 m1 m2       lB  uB    P
[1,] 3  3  2  1  2 0.019439 Inf 0.01
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 3  3  2  1  2 0.0053938 Inf 0.001
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 3  3  2  1  2 0.0023231 Inf 1e-04
[1] " "
     D d3 d2 m1 m2      lB  uB   P
[1,] 4  3  2  1  2 0.14883 Inf 0.1
[1] " "
     D d3 d2 m1 m2       lB  uB    P
[1,] 4  3  2  1  2 0.018518 Inf 0.01
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 4  3  2  1  2 0.0051267 Inf 0.001
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 4  3  2  1  2 0.0021973 Inf 1e-04
[1] " "
     D d3 d2 m1 m2      lB  uB   P
[1,] 5  3  2  1  2 0.14602 Inf 0.1
[1] " "
     D d3 d2 m1 m2       lB  uB    P
[1,] 5  3  2  1  2 0.017929 Inf 0.01
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 5  3  2  1  2 0.0049564 Inf 0.001
[1] " "
     D d3 d2 m1 m2        lB  uB     P
[1,] 5  3  2  1  2 0.0021164 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 78
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m1 m2      lB  uB   P
[1,] 2  2  1  2 0.15842 Inf 0.1
[1] " "
     D d2 m1 m2       lB  uB    P
[1,] 2  2  1  2 0.020877 Inf 0.01
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 2  2  1  2 0.0057903 Inf 0.001
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 2  2  1  2 0.0025102 Inf 1e-04
[1] " "
     D d2 m1 m2      lB  uB   P
[1,] 3  2  1  2 0.15038 Inf 0.1
[1] " "
     D d2 m1 m2      lB  uB    P
[1,] 3  2  1  2 0.01924 Inf 0.01
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 3  2  1  2 0.0053107 Inf 0.001
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 3  2  1  2 0.0022834 Inf 1e-04
[1] " "
     D d2 m1 m2    lB  uB   P
[1,] 4  2  1  2 0.146 Inf 0.1
[1] " "
     D d2 m1 m2       lB  uB    P
[1,] 4  2  1  2 0.018328 Inf 0.01
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 4  2  1  2 0.0050442 Inf 0.001
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 4  2  1  2 0.0021573 Inf 1e-04
[1] " "
     D d2 m1 m2      lB  uB   P
[1,] 5  2  1  2 0.14325 Inf 0.1
[1] " "
     D d2 m1 m2       lB  uB    P
[1,] 5  2  1  2 0.017745 Inf 0.01
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 5  2  1  2 0.0048742 Inf 0.001
[1] " "
     D d2 m1 m2        lB  uB     P
[1,] 5  2  1  2 0.0020761 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 79
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m1 m2      lB  uB   P
[1,] 3  3  1  2 0.15038 Inf 0.1
[1] " "
     D d3 m1 m2      lB  uB    P
[1,] 3  3  1  2 0.01924 Inf 0.01
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 3  3  1  2 0.0053379 Inf 0.001
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 3  3  1  2 0.0023209 Inf 1e-04
[1] " "
     D d3 m1 m2    lB  uB   P
[1,] 4  3  1  2 0.146 Inf 0.1
[1] " "
     D d3 m1 m2       lB  uB    P
[1,] 4  3  1  2 0.018328 Inf 0.01
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 4  3  1  2 0.0050628 Inf 0.001
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 4  3  1  2 0.0021867 Inf 1e-04
[1] " "
     D d3 m1 m2      lB  uB   P
[1,] 5  3  1  2 0.14325 Inf 0.1
[1] " "
     D d3 m1 m2       lB  uB    P
[1,] 5  3  1  2 0.017745 Inf 0.01
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 5  3  1  2 0.0048878 Inf 0.001
[1] " "
     D d3 m1 m2        lB  uB     P
[1,] 5  3  1  2 0.0021014 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 80
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m1 m2      lB  uB   P
[1,] 0  1  2 0.34711 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 0  1  2 0.052655 Inf 0.01
[1] " "
     D m1 m2      lB  uB     P
[1,] 0  1  2 0.01481 Inf 0.001
[1] " "
     D m1 m2        lB  uB     P
[1,] 0  1  2 0.0065526 Inf 1e-04
[1] " "
     D m1 m2      lB  uB   P
[1,] 1  1  2 0.17355 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 1  1  2 0.023402 Inf 0.01
[1] " "
     D m1 m2        lB  uB     P
[1,] 1  1  2 0.0065742 Inf 0.001
[1] " "
     D m1 m2       lB  uB     P
[1,] 1  1  2 0.002902 Inf 1e-04
[1] " "
     D m1 m2      lB  uB   P
[1,] 2  1  2 0.15427 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 2  1  2 0.019746 Inf 0.01
[1] " "
     D m1 m2        lB  uB     P
[1,] 2  1  2 0.0055436 Inf 0.001
[1] " "
     D m1 m2        lB  uB     P
[1,] 2  1  2 0.0024442 Inf 1e-04
[1] " "
     D m1 m2      lB  uB   P
[1,] 3  1  2 0.14644 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 3  1  2 0.018198 Inf 0.01
[1] " "
     D m1 m2        lB  uB     P
[1,] 3  1  2 0.0051066 Inf 0.001
[1] " "
     D m1 m2        lB  uB     P
[1,] 3  1  2 0.0022502 Inf 1e-04
[1] " "
     D m1 m2      lB  uB   P
[1,] 4  1  2 0.14218 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 4  1  2 0.017335 Inf 0.01
[1] " "
     D m1 m2        lB  uB     P
[1,] 4  1  2 0.0048627 Inf 0.001
[1] " "
     D m1 m2        lB  uB     P
[1,] 4  1  2 0.0021416 Inf 1e-04
[1] " "
     D m1 m2      lB  uB   P
[1,] 5  1  2 0.13949 Inf 0.1
[1] " "
     D m1 m2       lB  uB    P
[1,] 5  1  2 0.016784 Inf 0.01
[1] " "
     D m1 m2        lB  uB     P
[1,] 5  1  2 0.0047077 Inf 0.001
[1] " "
     D m1 m2        lB  uB     P
[1,] 5  1  2 0.0020688 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 81
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m2     lB  uB   P
[1,] 3  3  2  1  0  2 0.1512 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2       lB  uB    P
[1,] 3  3  2  1  0  2 0.019505 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2        lB  uB     P
[1,] 3  3  2  1  0  2 0.0053923 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2        lB  uB     P
[1,] 3  3  2  1  0  2 0.0023809 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m2      lB  uB   P
[1,] 4  3  2  1  0  2 0.14633 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2       lB  uB    P
[1,] 4  3  2  1  0  2 0.018567 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2        lB  uB     P
[1,] 4  3  2  1  0  2 0.0051152 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2       lB  uB     P
[1,] 4  3  2  1  0  2 0.002254 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m2      lB  uB   P
[1,] 5  3  2  1  0  2 0.14298 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m2       lB  uB    P
[1,] 5  3  2  1  0  2 0.017969 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m2        lB  uB     P
[1,] 5  3  2  1  0  2 0.0049377 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m2       lB  uB     P
[1,] 5  3  2  1  0  2 0.002172 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 82
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m2      lB  uB   P
[1,] 2  2  1  0  2 0.15897 Inf 0.1
[1] " "
     D d2 d1 m0 m2       lB  uB    P
[1,] 2  2  1  0  2 0.021018 Inf 0.01
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 2  2  1  0  2 0.0058358 Inf 0.001
[1] " "
     D d2 d1 m0 m2       lB  uB     P
[1,] 2  2  1  0  2 0.002583 Inf 1e-04
[1] " "
     D d2 d1 m0 m2      lB  uB   P
[1,] 3  2  1  0  2 0.15059 Inf 0.1
[1] " "
     D d2 d1 m0 m2       lB  uB    P
[1,] 3  2  1  0  2 0.019347 Inf 0.01
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 3  2  1  0  2 0.0053441 Inf 0.001
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 3  2  1  0  2 0.0023591 Inf 1e-04
[1] " "
     D d2 d1 m0 m2      lB  uB   P
[1,] 4  2  1  0  2 0.14559 Inf 0.1
[1] " "
     D d2 d1 m0 m2       lB  uB    P
[1,] 4  2  1  0  2 0.018414 Inf 0.01
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 4  2  1  0  2 0.0050685 Inf 0.001
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 4  2  1  0  2 0.0022329 Inf 1e-04
[1] " "
     D d2 d1 m0 m2      lB  uB   P
[1,] 5  2  1  0  2 0.14224 Inf 0.1
[1] " "
     D d2 d1 m0 m2       lB  uB    P
[1,] 5  2  1  0  2 0.017819 Inf 0.01
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 5  2  1  0  2 0.0048917 Inf 0.001
[1] " "
     D d2 d1 m0 m2        lB  uB     P
[1,] 5  2  1  0  2 0.0021516 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 83
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m2      lB  uB   P
[1,] 3  3  1  0  2 0.15037 Inf 0.1
[1] " "
     D d3 d1 m0 m2       lB  uB    P
[1,] 3  3  1  0  2 0.019364 Inf 0.01
[1] " "
     D d3 d1 m0 m2       lB  uB     P
[1,] 3  3  1  0  2 0.005344 Inf 0.001
[1] " "
     D d3 d1 m0 m2        lB  uB     P
[1,] 3  3  1  0  2 0.0023591 Inf 1e-04
[1] " "
     D d3 d1 m0 m2      lB  uB   P
[1,] 4  3  1  0  2 0.14554 Inf 0.1
[1] " "
     D d3 d1 m0 m2       lB  uB    P
[1,] 4  3  1  0  2 0.018434 Inf 0.01
[1] " "
     D d3 d1 m0 m2        lB  uB     P
[1,] 4  3  1  0  2 0.0050685 Inf 0.001
[1] " "
     D d3 d1 m0 m2        lB  uB     P
[1,] 4  3  1  0  2 0.0022328 Inf 1e-04
[1] " "
     D d3 d1 m0 m2      lB  uB   P
[1,] 5  3  1  0  2 0.14224 Inf 0.1
[1] " "
     D d3 d1 m0 m2       lB  uB    P
[1,] 5  3  1  0  2 0.017829 Inf 0.01
[1] " "
     D d3 d1 m0 m2        lB  uB     P
[1,] 5  3  1  0  2 0.0048915 Inf 0.001
[1] " "
     D d3 d1 m0 m2       lB  uB     P
[1,] 5  3  1  0  2 0.002151 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 84
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m2      lB  uB   P
[1,] 1  1  0  2 0.17534 Inf 0.1
[1] " "
     D d1 m0 m2       lB  uB    P
[1,] 1  1  0  2 0.024672 Inf 0.01
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 1  1  0  2 0.0069048 Inf 0.001
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 1  1  0  2 0.0030659 Inf 1e-04
[1] " "
     D d1 m0 m2      lB  uB   P
[1,] 2  1  0  2 0.15735 Inf 0.1
[1] " "
     D d1 m0 m2       lB  uB    P
[1,] 2  1  0  2 0.020788 Inf 0.01
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 2  1  0  2 0.0057642 Inf 0.001
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 2  1  0  2 0.0025503 Inf 1e-04
[1] " "
     D d1 m0 m2      lB  uB   P
[1,] 3  1  0  2 0.14878 Inf 0.1
[1] " "
     D d1 m0 m2      lB  uB    P
[1,] 3  1  0  2 0.01915 Inf 0.01
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 3  1  0  2 0.0052748 Inf 0.001
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 3  1  0  2 0.0023273 Inf 1e-04
[1] " "
     D d1 m0 m2      lB  uB   P
[1,] 4  1  0  2 0.14374 Inf 0.1
[1] " "
     D d1 m0 m2      lB  uB    P
[1,] 4  1  0  2 0.01824 Inf 0.01
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 4  1  0  2 0.0050002 Inf 0.001
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 4  1  0  2 0.0022013 Inf 1e-04
[1] " "
     D d1 m0 m2      lB  uB   P
[1,] 5  1  0  2 0.14043 Inf 0.1
[1] " "
     D d1 m0 m2       lB  uB    P
[1,] 5  1  0  2 0.017659 Inf 0.01
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 5  1  0  2 0.0048237 Inf 0.001
[1] " "
     D d1 m0 m2        lB  uB     P
[1,] 5  1  0  2 0.0021199 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 85
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m2      lB  uB   P
[1,] 3  3  2  0  2 0.15071 Inf 0.1
[1] " "
     D d3 d2 m0 m2       lB  uB    P
[1,] 3  3  2  0  2 0.019347 Inf 0.01
[1] " "
     D d3 d2 m0 m2        lB  uB     P
[1,] 3  3  2  0  2 0.0053851 Inf 0.001
[1] " "
     D d3 d2 m0 m2       lB  uB     P
[1,] 3  3  2  0  2 0.002388 Inf 1e-04
[1] " "
     D d3 d2 m0 m2     lB  uB   P
[1,] 4  3  2  0  2 0.1456 Inf 0.1
[1] " "
     D d3 d2 m0 m2       lB  uB    P
[1,] 4  3  2  0  2 0.018414 Inf 0.01
[1] " "
     D d3 d2 m0 m2        lB  uB     P
[1,] 4  3  2  0  2 0.0050992 Inf 0.001
[1] " "
     D d3 d2 m0 m2        lB  uB     P
[1,] 4  3  2  0  2 0.0022577 Inf 1e-04
[1] " "
     D d3 d2 m0 m2      lB  uB   P
[1,] 5  3  2  0  2 0.14224 Inf 0.1
[1] " "
     D d3 d2 m0 m2       lB  uB    P
[1,] 5  3  2  0  2 0.017819 Inf 0.01
[1] " "
     D d3 d2 m0 m2        lB  uB     P
[1,] 5  3  2  0  2 0.0049145 Inf 0.001
[1] " "
     D d3 d2 m0 m2        lB  uB     P
[1,] 5  3  2  0  2 0.0021723 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 86
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m2      lB  uB   P
[1,] 2  2  0  2 0.15735 Inf 0.1
[1] " "
     D d2 m0 m2       lB  uB    P
[1,] 2  2  0  2 0.020803 Inf 0.01
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 2  2  0  2 0.0058263 Inf 0.001
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 2  2  0  2 0.0025889 Inf 1e-04
[1] " "
     D d2 m0 m2      lB  uB   P
[1,] 3  2  0  2 0.14878 Inf 0.1
[1] " "
     D d2 m0 m2       lB  uB    P
[1,] 3  2  0  2 0.019135 Inf 0.01
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 3  2  0  2 0.0053224 Inf 0.001
[1] " "
     D d2 m0 m2      lB  uB     P
[1,] 3  2  0  2 0.00236 Inf 1e-04
[1] " "
     D d2 m0 m2      lB  uB   P
[1,] 4  2  0  2 0.14374 Inf 0.1
[1] " "
     D d2 m0 m2       lB  uB    P
[1,] 4  2  0  2 0.018209 Inf 0.01
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 4  2  0  2 0.0050373 Inf 0.001
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 4  2  0  2 0.0022297 Inf 1e-04
[1] " "
     D d2 m0 m2      lB  uB   P
[1,] 5  2  0  2 0.14043 Inf 0.1
[1] " "
     D d2 m0 m2       lB  uB    P
[1,] 5  2  0  2 0.017619 Inf 0.01
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 5  2  0  2 0.0048533 Inf 0.001
[1] " "
     D d2 m0 m2        lB  uB     P
[1,] 5  2  0  2 0.0021452 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 87
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m2      lB  uB   P
[1,] 3  3  0  2 0.14878 Inf 0.1
[1] " "
     D d3 m0 m2       lB  uB    P
[1,] 3  3  0  2 0.019172 Inf 0.01
[1] " "
     D d3 m0 m2        lB  uB     P
[1,] 3  3  0  2 0.0053748 Inf 0.001
[1] " "
[1] "Cycle"
     D d3 m0 m2        lB  uB     P
[1,] 3  3  0  2 0.0023893 Inf 1e-04
[1] " "
     D d3 m0 m2      lB  uB   P
[1,] 4  3  0  2 0.14374 Inf 0.1
[1] " "
     D d3 m0 m2      lB  uB    P
[1,] 4  3  0  2 0.01823 Inf 0.01
[1] " "
     D d3 m0 m2        lB  uB     P
[1,] 4  3  0  2 0.0050846 Inf 0.001
[1] " "
     D d3 m0 m2        lB  uB     P
[1,] 4  3  0  2 0.0022572 Inf 1e-04
[1] " "
     D d3 m0 m2      lB  uB   P
[1,] 5  3  0  2 0.14043 Inf 0.1
[1] " "
     D d3 m0 m2       lB  uB    P
[1,] 5  3  0  2 0.017629 Inf 0.01
[1] " "
     D d3 m0 m2        lB  uB     P
[1,] 5  3  0  2 0.0048958 Inf 0.001
[1] " "
     D d3 m0 m2        lB  uB     P
[1,] 5  3  0  2 0.0021708 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 88
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m2      lB  uB   P
[1,] 0  0  2 0.23695 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 0  0  2 0.052655 Inf 0.01
[1] " "
     D m0 m2       lB  uB     P
[1,] 0  0  2 0.014864 Inf 0.001
[1] " "
     D m0 m2        lB  uB     P
[1,] 0  0  2 0.0066203 Inf 1e-04
[1] " "
     D m0 m2      lB  uB   P
[1,] 1  0  2 0.17199 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 1  0  2 0.023402 Inf 0.01
[1] " "
     D m0 m2        lB  uB     P
[1,] 1  0  2 0.0066064 Inf 0.001
[1] " "
     D m0 m2        lB  uB     P
[1,] 1  0  2 0.0029424 Inf 1e-04
[1] " "
     D m0 m2      lB  uB   P
[1,] 2  0  2 0.15399 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 2  0  2 0.019746 Inf 0.01
[1] " "
     D m0 m2        lB  uB     P
[1,] 2  0  2 0.0055742 Inf 0.001
[1] " "
     D m0 m2        lB  uB     P
[1,] 2  0  2 0.0024826 Inf 1e-04
[1] " "
     D m0 m2      lB  uB   P
[1,] 3  0  2 0.14544 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 3  0  2 0.018198 Inf 0.01
[1] " "
     D m0 m2        lB  uB     P
[1,] 3  0  2 0.0051371 Inf 0.001
[1] " "
     D m0 m2       lB  uB     P
[1,] 3  0  2 0.002288 Inf 1e-04
[1] " "
     D m0 m2      lB  uB   P
[1,] 4  0  2 0.14043 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 4  0  2 0.017335 Inf 0.01
[1] " "
     D m0 m2        lB  uB     P
[1,] 4  0  2 0.0048936 Inf 0.001
[1] " "
     D m0 m2        lB  uB     P
[1,] 4  0  2 0.0021795 Inf 1e-04
[1] " "
     D m0 m2      lB  uB   P
[1,] 5  0  2 0.13713 Inf 0.1
[1] " "
     D m0 m2       lB  uB    P
[1,] 5  0  2 0.016784 Inf 0.01
[1] " "
     D m0 m2       lB  uB     P
[1,] 5  0  2 0.004738 Inf 0.001
[1] " "
     D m0 m2        lB  uB     P
[1,] 5  0  2 0.0021102 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 89
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m2      lB  uB   P
[1,] 3  3  2  1  2 0.22891 Inf 0.1
[1] " "
     D d3 d2 d1 m2       lB  uB    P
[1,] 3  3  2  1  2 0.019434 Inf 0.01
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 3  3  2  1  2 0.0054853 Inf 0.001
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 3  3  2  1  2 0.0024428 Inf 1e-04
[1] " "
     D d3 d2 d1 m2      lB  uB   P
[1,] 4  3  2  1  2 0.21161 Inf 0.1
[1] " "
     D d3 d2 d1 m2       lB  uB    P
[1,] 4  3  2  1  2 0.018508 Inf 0.01
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 4  3  2  1  2 0.0052226 Inf 0.001
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 4  3  2  1  2 0.0023256 Inf 1e-04
[1] " "
     D d3 d2 d1 m2    lB  uB   P
[1,] 5  3  2  1  2 0.201 Inf 0.1
[1] " "
     D d3 d2 d1 m2       lB  uB    P
[1,] 5  3  2  1  2 0.017915 Inf 0.01
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 5  3  2  1  2 0.0050527 Inf 0.001
[1] " "
     D d3 d2 d1 m2        lB  uB     P
[1,] 5  3  2  1  2 0.0022501 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 90
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m2      lB  uB   P
[1,] 2  2  1  2 0.25991 Inf 0.1
[1] " "
     D d2 d1 m2       lB  uB    P
[1,] 2  2  1  2 0.020875 Inf 0.01
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 2  2  1  2 0.0058926 Inf 0.001
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 2  2  1  2 0.0026244 Inf 1e-04
[1] " "
     D d2 d1 m2      lB  uB   P
[1,] 3  2  1  2 0.22684 Inf 0.1
[1] " "
     D d2 d1 m2       lB  uB    P
[1,] 3  2  1  2 0.019236 Inf 0.01
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 3  2  1  2 0.0054292 Inf 0.001
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 3  2  1  2 0.0024179 Inf 1e-04
[1] " "
     D d2 d1 m2      lB  uB   P
[1,] 4  2  1  2 0.20969 Inf 0.1
[1] " "
     D d2 d1 m2       lB  uB    P
[1,] 4  2  1  2 0.018323 Inf 0.01
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 4  2  1  2 0.0051704 Inf 0.001
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 4  2  1  2 0.0023025 Inf 1e-04
[1] " "
     D d2 d1 m2      lB  uB   P
[1,] 5  2  1  2 0.19918 Inf 0.1
[1] " "
     D d2 d1 m2       lB  uB    P
[1,] 5  2  1  2 0.017738 Inf 0.01
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 5  2  1  2 0.0050039 Inf 0.001
[1] " "
     D d2 d1 m2        lB  uB     P
[1,] 5  2  1  2 0.0022285 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 91
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m2      lB  uB   P
[1,] 3  3  1  2 0.22684 Inf 0.1
[1] " "
     D d3 d1 m2       lB  uB    P
[1,] 3  3  1  2 0.019235 Inf 0.01
[1] " "
     D d3 d1 m2       lB  uB     P
[1,] 3  3  1  2 0.005429 Inf 0.001
[1] " "
     D d3 d1 m2        lB  uB     P
[1,] 3  3  1  2 0.0024178 Inf 1e-04
[1] " "
     D d3 d1 m2     lB  uB   P
[1,] 4  3  1  2 0.2097 Inf 0.1
[1] " "
     D d3 d1 m2       lB  uB    P
[1,] 4  3  1  2 0.018317 Inf 0.01
[1] " "
     D d3 d1 m2        lB  uB     P
[1,] 4  3  1  2 0.0051685 Inf 0.001
[1] " "
     D d3 d1 m2        lB  uB     P
[1,] 4  3  1  2 0.0023014 Inf 1e-04
[1] " "
     D d3 d1 m2      lB  uB   P
[1,] 5  3  1  2 0.19918 Inf 0.1
[1] " "
     D d3 d1 m2       lB  uB    P
[1,] 5  3  1  2 0.017729 Inf 0.01
[1] " "
     D d3 d1 m2        lB  uB     P
[1,] 5  3  1  2 0.0049999 Inf 0.001
[1] " "
     D d3 d1 m2        lB  uB     P
[1,] 5  3  1  2 0.0022266 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 92
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m2      lB  uB   P
[1,] 1  1  2 0.33837 Inf 0.1
[1] " "
     D d1 m2       lB  uB    P
[1,] 1  1  2 0.023402 Inf 0.01
[1] " "
     D d1 m2        lB  uB     P
[1,] 1  1  2 0.0066064 Inf 0.001
[1] " "
     D d1 m2        lB  uB     P
[1,] 1  1  2 0.0029424 Inf 1e-04
[1] " "
     D d1 m2      lB  uB   P
[1,] 2  1  2 0.25052 Inf 0.1
[1] " "
     D d1 m2       lB  uB    P
[1,] 2  1  2 0.019746 Inf 0.01
[1] " "
     D d1 m2        lB  uB     P
[1,] 2  1  2 0.0055742 Inf 0.001
[1] " "
     D d1 m2        lB  uB     P
[1,] 2  1  2 0.0024826 Inf 1e-04
[1] " "
     D d1 m2      lB  uB   P
[1,] 3  1  2 0.21864 Inf 0.1
[1] " "
     D d1 m2       lB  uB    P
[1,] 3  1  2 0.018198 Inf 0.01
[1] " "
     D d1 m2        lB  uB     P
[1,] 3  1  2 0.0051371 Inf 0.001
[1] " "
     D d1 m2       lB  uB     P
[1,] 3  1  2 0.002288 Inf 1e-04
[1] " "
     D d1 m2      lB  uB   P
[1,] 4  1  2 0.20209 Inf 0.1
[1] " "
     D d1 m2       lB  uB    P
[1,] 4  1  2 0.017335 Inf 0.01
[1] " "
     D d1 m2        lB  uB     P
[1,] 4  1  2 0.0048936 Inf 0.001
[1] " "
     D d1 m2        lB  uB     P
[1,] 4  1  2 0.0021795 Inf 1e-04
[1] " "
     D d1 m2      lB  uB   P
[1,] 5  1  2 0.19195 Inf 0.1
[1] " "
     D d1 m2       lB  uB    P
[1,] 5  1  2 0.016784 Inf 0.01
[1] " "
     D d1 m2       lB  uB     P
[1,] 5  1  2 0.004738 Inf 0.001
[1] " "
     D d1 m2        lB  uB     P
[1,] 5  1  2 0.0021102 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 93
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m2      lB  uB   P
[1,] 3  3  2  2 0.33631 Inf 0.1
[1] " "
     D d3 d2 m2      lB  uB    P
[1,] 3  3  2  2 0.01924 Inf 0.01
[1] " "
     D d3 d2 m2        lB  uB     P
[1,] 3  3  2  2 0.0054314 Inf 0.001
[1] " "
     D d3 d2 m2        lB  uB     P
[1,] 3  3  2  2 0.0024191 Inf 1e-04
[1] " "
     D d3 d2 m2      lB  uB   P
[1,] 4  3  2  2 0.30087 Inf 0.1
[1] " "
     D d3 d2 m2       lB  uB    P
[1,] 4  3  2  2 0.018328 Inf 0.01
[1] " "
     D d3 d2 m2        lB  uB     P
[1,] 4  3  2  2 0.0051739 Inf 0.001
[1] " "
     D d3 d2 m2        lB  uB     P
[1,] 4  3  2  2 0.0023044 Inf 1e-04
[1] " "
     D d3 d2 m2      lB  uB   P
[1,] 5  3  2  2 0.27968 Inf 0.1
[1] " "
     D d3 d2 m2       lB  uB    P
[1,] 5  3  2  2 0.017745 Inf 0.01
[1] " "
     D d3 d2 m2        lB  uB     P
[1,] 5  3  2  2 0.0050093 Inf 0.001
[1] " "
     D d3 d2 m2       lB  uB     P
[1,] 5  3  2  2 0.002231 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 94
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m2      lB  uB   P
[1,] 2  2  2 0.36214 Inf 0.1
[1] " "
     D d2 m2       lB  uB    P
[1,] 2  2  2 0.019746 Inf 0.01
[1] " "
     D d2 m2        lB  uB     P
[1,] 2  2  2 0.0055742 Inf 0.001
[1] " "
     D d2 m2        lB  uB     P
[1,] 2  2  2 0.0024826 Inf 1e-04
[1] " "
     D d2 m2     lB  uB   P
[1,] 3  2  2 0.3194 Inf 0.1
[1] " "
     D d2 m2       lB  uB    P
[1,] 3  2  2 0.018198 Inf 0.01
[1] " "
     D d2 m2        lB  uB     P
[1,] 3  2  2 0.0051371 Inf 0.001
[1] " "
     D d2 m2       lB  uB     P
[1,] 3  2  2 0.002288 Inf 1e-04
[1] " "
     D d2 m2     lB  uB   P
[1,] 4  2  2 0.2859 Inf 0.1
[1] " "
     D d2 m2       lB  uB    P
[1,] 4  2  2 0.017335 Inf 0.01
[1] " "
     D d2 m2        lB  uB     P
[1,] 4  2  2 0.0048936 Inf 0.001
[1] " "
     D d2 m2        lB  uB     P
[1,] 4  2  2 0.0021795 Inf 1e-04
[1] " "
     D d2 m2      lB  uB   P
[1,] 5  2  2 0.26583 Inf 0.1
[1] " "
     D d2 m2       lB  uB    P
[1,] 5  2  2 0.016784 Inf 0.01
[1] " "
     D d2 m2       lB  uB     P
[1,] 5  2  2 0.004738 Inf 0.001
[1] " "
     D d2 m2        lB  uB     P
[1,] 5  2  2 0.0021102 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 95
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m2      lB  uB   P
[1,] 3  3  2 0.33072 Inf 0.1
[1] " "
     D d3 m2       lB  uB    P
[1,] 3  3  2 0.018198 Inf 0.01
[1] " "
     D d3 m2        lB  uB     P
[1,] 3  3  2 0.0051371 Inf 0.001
[1] " "
     D d3 m2       lB  uB     P
[1,] 3  3  2 0.002288 Inf 1e-04
[1] " "
     D d3 m2      lB  uB   P
[1,] 4  3  2 0.31329 Inf 0.1
[1] " "
     D d3 m2       lB  uB    P
[1,] 4  3  2 0.017335 Inf 0.01
[1] " "
     D d3 m2        lB  uB     P
[1,] 4  3  2 0.0048936 Inf 0.001
[1] " "
     D d3 m2        lB  uB     P
[1,] 4  3  2 0.0021795 Inf 1e-04
[1] " "
     D d3 m2      lB  uB   P
[1,] 5  3  2 0.30218 Inf 0.1
[1] " "
     D d3 m2       lB  uB    P
[1,] 5  3  2 0.016784 Inf 0.01
[1] " "
     D d3 m2       lB  uB     P
[1,] 5  3  2 0.004738 Inf 0.001
[1] " "
     D d3 m2        lB  uB     P
[1,] 5  3  2 0.0021102 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 96
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m2 lB  uB   P
[1,] 0  2  1 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 0  2 0.050979 Inf 0.01
[1] " "
     D m2       lB  uB     P
[1,] 0  2 0.014391 Inf 0.001
[1] " "
     D m2        lB  uB     P
[1,] 0  2 0.0064096 Inf 1e-04
[1] " "
     D m2      lB  uB   P
[1,] 1  2 0.42765 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 1  2 0.022657 Inf 0.01
[1] " "
     D m2        lB  uB     P
[1,] 1  2 0.0063961 Inf 0.001
[1] " "
     D m2        lB  uB     P
[1,] 1  2 0.0028487 Inf 1e-04
[1] " "
     D m2      lB  uB   P
[1,] 2  2 0.35437 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 2  2 0.019117 Inf 0.01
[1] " "
     D m2        lB  uB     P
[1,] 2  2 0.0053967 Inf 0.001
[1] " "
     D m2        lB  uB     P
[1,] 2  2 0.0024036 Inf 1e-04
[1] " "
     D m2      lB  uB   P
[1,] 3  2 0.32355 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 3  2 0.017618 Inf 0.01
[1] " "
     D m2        lB  uB     P
[1,] 3  2 0.0049736 Inf 0.001
[1] " "
     D m2        lB  uB     P
[1,] 3  2 0.0022152 Inf 1e-04
[1] " "
     D m2      lB  uB   P
[1,] 4  2 0.30646 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 4  2 0.016783 Inf 0.01
[1] " "
     D m2        lB  uB     P
[1,] 4  2 0.0047379 Inf 0.001
[1] " "
     D m2        lB  uB     P
[1,] 4  2 0.0021102 Inf 1e-04
[1] " "
     D m2      lB  uB   P
[1,] 5  2 0.29558 Inf 0.1
[1] " "
     D m2       lB  uB    P
[1,] 5  2 0.016249 Inf 0.01
[1] " "
     D m2        lB  uB     P
[1,] 5  2 0.0045872 Inf 0.001
[1] " "
     D m2       lB  uB     P
[1,] 5  2 0.002043 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 97
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0 m1     lB  uB   P
[1,] 3  3  2  1  0  1 0.1412 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1       lB  uB    P
[1,] 3  3  2  1  0  1 0.032918 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 3  3  2  1  0  1 0.016493 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 3  3  2  1  0  1 0.010686 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1      lB  uB   P
[1,] 4  3  2  1  0  1 0.13766 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1       lB  uB    P
[1,] 4  3  2  1  0  1 0.031751 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 4  3  2  1  0  1 0.015885 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 4  3  2  1  0  1 0.010268 Inf 1e-04
[1] " "
     D d3 d2 d1 m0 m1     lB  uB   P
[1,] 5  3  2  1  0  1 0.1354 Inf 0.1
[1] " "
     D d3 d2 d1 m0 m1       lB  uB    P
[1,] 5  3  2  1  0  1 0.031021 Inf 0.01
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 5  3  2  1  0  1 0.015501 Inf 0.001
[1] " "
     D d3 d2 d1 m0 m1       lB  uB     P
[1,] 5  3  2  1  0  1 0.010002 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 98
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0 m1      lB  uB   P
[1,] 2  2  1  0  1 0.14667 Inf 0.1
[1] " "
     D d2 d1 m0 m1      lB  uB    P
[1,] 2  2  1  0  1 0.03465 Inf 0.01
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 2  2  1  0  1 0.017404 Inf 0.001
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 2  2  1  0  1 0.011314 Inf 1e-04
[1] " "
     D d2 d1 m0 m1      lB  uB   P
[1,] 3  2  1  0  1 0.14034 Inf 0.1
[1] " "
     D d2 d1 m0 m1       lB  uB    P
[1,] 3  2  1  0  1 0.032571 Inf 0.01
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 3  2  1  0  1 0.016295 Inf 0.001
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 3  2  1  0  1 0.010552 Inf 1e-04
[1] " "
     D d2 d1 m0 m1      lB  uB   P
[1,] 4  2  1  0  1 0.13681 Inf 0.1
[1] " "
     D d2 d1 m0 m1       lB  uB    P
[1,] 4  2  1  0  1 0.031402 Inf 0.01
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 4  2  1  0  1 0.015688 Inf 0.001
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 4  2  1  0  1 0.010135 Inf 1e-04
[1] " "
     D d2 d1 m0 m1      lB  uB   P
[1,] 5  2  1  0  1 0.13456 Inf 0.1
[1] " "
     D d2 d1 m0 m1       lB  uB    P
[1,] 5  2  1  0  1 0.030669 Inf 0.01
[1] " "
     D d2 d1 m0 m1       lB  uB     P
[1,] 5  2  1  0  1 0.015306 Inf 0.001
[1] " "
     D d2 d1 m0 m1        lB  uB     P
[1,] 5  2  1  0  1 0.0098696 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 99
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0 m1      lB  uB   P
[1,] 3  3  1  0  1 0.14034 Inf 0.1
[1] " "
[1] "Cycle"
     D d3 d1 m0 m1       lB  uB    P
[1,] 3  3  1  0  1 0.032714 Inf 0.01
[1] " "
     D d3 d1 m0 m1       lB  uB     P
[1,] 3  3  1  0  1 0.016295 Inf 0.001
[1] " "
     D d3 d1 m0 m1       lB  uB     P
[1,] 3  3  1  0  1 0.010552 Inf 1e-04
[1] " "
     D d3 d1 m0 m1      lB  uB   P
[1,] 4  3  1  0  1 0.13681 Inf 0.1
[1] " "
     D d3 d1 m0 m1       lB  uB    P
[1,] 4  3  1  0  1 0.031645 Inf 0.01
[1] " "
     D d3 d1 m0 m1       lB  uB     P
[1,] 4  3  1  0  1 0.015689 Inf 0.001
[1] " "
     D d3 d1 m0 m1       lB  uB     P
[1,] 4  3  1  0  1 0.010135 Inf 1e-04
[1] " "
     D d3 d1 m0 m1      lB  uB   P
[1,] 5  3  1  0  1 0.13456 Inf 0.1
[1] " "
     D d3 d1 m0 m1       lB  uB    P
[1,] 5  3  1  0  1 0.030832 Inf 0.01
[1] " "
     D d3 d1 m0 m1       lB  uB     P
[1,] 5  3  1  0  1 0.015306 Inf 0.001
[1] " "
     D d3 d1 m0 m1        lB  uB     P
[1,] 5  3  1  0  1 0.0098696 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 100
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0 m1      lB  uB   P
[1,] 1  1  0  1 0.15906 Inf 0.1
[1] " "
     D d1 m0 m1       lB  uB    P
[1,] 1  1  0  1 0.038467 Inf 0.01
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 1  1  0  1 0.019581 Inf 0.001
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 1  1  0  1 0.012811 Inf 1e-04
[1] " "
     D d1 m0 m1      lB  uB   P
[1,] 2  1  0  1 0.14425 Inf 0.1
[1] " "
     D d1 m0 m1       lB  uB    P
[1,] 2  1  0  1 0.033757 Inf 0.01
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 2  1  0  1 0.016899 Inf 0.001
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 2  1  0  1 0.010973 Inf 1e-04
[1] " "
     D d1 m0 m1      lB  uB   P
[1,] 3  1  0  1 0.13796 Inf 0.1
[1] " "
     D d1 m0 m1       lB  uB    P
[1,] 3  1  0  1 0.031839 Inf 0.01
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 3  1  0  1 0.015796 Inf 0.001
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 3  1  0  1 0.010215 Inf 1e-04
[1] " "
     D d1 m0 m1      lB  uB   P
[1,] 4  1  0  1 0.13448 Inf 0.1
[1] " "
     D d1 m0 m1       lB  uB    P
[1,] 4  1  0  1 0.030797 Inf 0.01
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 4  1  0  1 0.015193 Inf 0.001
[1] " "
     D d1 m0 m1        lB  uB     P
[1,] 4  1  0  1 0.0098005 Inf 1e-04
[1] " "
     D d1 m0 m1      lB  uB   P
[1,] 5  1  0  1 0.13227 Inf 0.1
[1] " "
     D d1 m0 m1       lB  uB    P
[1,] 5  1  0  1 0.030141 Inf 0.01
[1] " "
     D d1 m0 m1       lB  uB     P
[1,] 5  1  0  1 0.014812 Inf 0.001
[1] " "
     D d1 m0 m1        lB  uB     P
[1,] 5  1  0  1 0.0095374 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 101
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0 m1      lB  uB   P
[1,] 3  3  2  0  1 0.14034 Inf 0.1
[1] " "
     D d3 d2 m0 m1       lB  uB    P
[1,] 3  3  2  0  1 0.032571 Inf 0.01
[1] " "
     D d3 d2 m0 m1       lB  uB     P
[1,] 3  3  2  0  1 0.016496 Inf 0.001
[1] " "
     D d3 d2 m0 m1       lB  uB     P
[1,] 3  3  2  0  1 0.010794 Inf 1e-04
[1] " "
     D d3 d2 m0 m1      lB  uB   P
[1,] 4  3  2  0  1 0.13681 Inf 0.1
[1] " "
     D d3 d2 m0 m1       lB  uB    P
[1,] 4  3  2  0  1 0.031401 Inf 0.01
[1] " "
     D d3 d2 m0 m1       lB  uB     P
[1,] 4  3  2  0  1 0.015784 Inf 0.001
[1] " "
     D d3 d2 m0 m1       lB  uB     P
[1,] 4  3  2  0  1 0.010298 Inf 1e-04
[1] " "
     D d3 d2 m0 m1      lB  uB   P
[1,] 5  3  2  0  1 0.13456 Inf 0.1
[1] " "
     D d3 d2 m0 m1      lB  uB    P
[1,] 5  3  2  0  1 0.03067 Inf 0.01
[1] " "
     D d3 d2 m0 m1       lB  uB     P
[1,] 5  3  2  0  1 0.015338 Inf 0.001
[1] " "
     D d3 d2 m0 m1        lB  uB     P
[1,] 5  3  2  0  1 0.0099805 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 102
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0 m1      lB  uB   P
[1,] 2  2  0  1 0.14425 Inf 0.1
[1] " "
     D d2 m0 m1       lB  uB    P
[1,] 2  2  0  1 0.033907 Inf 0.01
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 2  2  0  1 0.017365 Inf 0.001
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 2  2  0  1 0.011414 Inf 1e-04
[1] " "
     D d2 m0 m1      lB  uB   P
[1,] 3  2  0  1 0.13796 Inf 0.1
[1] " "
     D d2 m0 m1       lB  uB    P
[1,] 3  2  0  1 0.031737 Inf 0.01
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 3  2  0  1 0.016046 Inf 0.001
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 3  2  0  1 0.010495 Inf 1e-04
[1] " "
     D d2 m0 m1      lB  uB   P
[1,] 4  2  0  1 0.13448 Inf 0.1
[1] " "
     D d2 m0 m1       lB  uB    P
[1,] 4  2  0  1 0.030567 Inf 0.01
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 4  2  0  1 0.015334 Inf 0.001
[1] " "
     D d2 m0 m1        lB  uB     P
[1,] 4  2  0  1 0.0099983 Inf 1e-04
[1] " "
     D d2 m0 m1      lB  uB   P
[1,] 5  2  0  1 0.13227 Inf 0.1
[1] " "
     D d2 m0 m1       lB  uB    P
[1,] 5  2  0  1 0.029834 Inf 0.01
[1] " "
     D d2 m0 m1       lB  uB     P
[1,] 5  2  0  1 0.014886 Inf 0.001
[1] " "
     D d2 m0 m1        lB  uB     P
[1,] 5  2  0  1 0.0096805 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 103
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0 m1      lB  uB   P
[1,] 3  3  0  1 0.13796 Inf 0.1
[1] " "
     D d3 m0 m1       lB  uB    P
[1,] 3  3  0  1 0.032161 Inf 0.01
[1] " "
     D d3 m0 m1      lB  uB     P
[1,] 3  3  0  1 0.01655 Inf 0.001
[1] " "
     D d3 m0 m1       lB  uB     P
[1,] 3  3  0  1 0.010906 Inf 1e-04
[1] " "
     D d3 m0 m1      lB  uB   P
[1,] 4  3  0  1 0.13448 Inf 0.1
[1] " "
     D d3 m0 m1       lB  uB    P
[1,] 4  3  0  1 0.030823 Inf 0.01
[1] " "
     D d3 m0 m1       lB  uB     P
[1,] 4  3  0  1 0.015706 Inf 0.001
[1] " "
     D d3 m0 m1       lB  uB     P
[1,] 4  3  0  1 0.010311 Inf 1e-04
[1] " "
     D d3 m0 m1      lB  uB   P
[1,] 5  3  0  1 0.13227 Inf 0.1
[1] " "
     D d3 m0 m1       lB  uB    P
[1,] 5  3  0  1 0.029998 Inf 0.01
[1] " "
     D d3 m0 m1       lB  uB     P
[1,] 5  3  0  1 0.015188 Inf 0.001
[1] " "
     D d3 m0 m1        lB  uB     P
[1,] 5  3  0  1 0.0099365 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 104
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0 m1      lB  uB   P
[1,] 0  0  1 0.23695 Inf 0.1
[1] " "
     D m0 m1       lB  uB    P
[1,] 0  0  1 0.077693 Inf 0.01
[1] " "
     D m0 m1      lB  uB     P
[1,] 0  0  1 0.04128 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 0  0  1 0.027549 Inf 1e-04
[1] " "
     D m0 m1      lB  uB   P
[1,] 1  0  1 0.15607 Inf 0.1
[1] " "
     D m0 m1       lB  uB    P
[1,] 1  0  1 0.038846 Inf 0.01
[1] " "
     D m0 m1      lB  uB     P
[1,] 1  0  1 0.02064 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 1  0  1 0.013774 Inf 1e-04
[1] " "
     D m0 m1      lB  uB   P
[1,] 2  0  1 0.14138 Inf 0.1
[1] " "
     D m0 m1      lB  uB    P
[1,] 2  0  1 0.03453 Inf 0.01
[1] " "
     D m0 m1       lB  uB     P
[1,] 2  0  1 0.018346 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 2  0  1 0.012244 Inf 1e-04
[1] " "
     D m0 m1      lB  uB   P
[1,] 3  0  1 0.13516 Inf 0.1
[1] " "
     D m0 m1       lB  uB    P
[1,] 3  0  1 0.032777 Inf 0.01
[1] " "
     D m0 m1       lB  uB     P
[1,] 3  0  1 0.017415 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 3  0  1 0.011622 Inf 1e-04
[1] " "
     D m0 m1      lB  uB   P
[1,] 4  0  1 0.13172 Inf 0.1
[1] " "
     D m0 m1       lB  uB    P
[1,] 4  0  1 0.031823 Inf 0.01
[1] " "
     D m0 m1       lB  uB     P
[1,] 4  0  1 0.016908 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 4  0  1 0.011284 Inf 1e-04
[1] " "
     D m0 m1      lB  uB   P
[1,] 5  0  1 0.12953 Inf 0.1
[1] " "
     D m0 m1       lB  uB    P
[1,] 5  0  1 0.031223 Inf 0.01
[1] " "
     D m0 m1       lB  uB     P
[1,] 5  0  1 0.016589 Inf 0.001
[1] " "
     D m0 m1       lB  uB     P
[1,] 5  0  1 0.011034 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 105
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m1      lB  uB   P
[1,] 3  3  2  1  1 0.15327 Inf 0.1
[1] " "
[1] "Cycle"
     D d3 d2 d1 m1       lB  uB    P
[1,] 3  3  2  1  1 0.034145 Inf 0.01
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 3  3  2  1  1 0.018119 Inf 0.001
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 3  3  2  1  1 0.012088 Inf 1e-04
[1] " "
     D d3 d2 d1 m1      lB  uB   P
[1,] 4  3  2  1  1 0.14866 Inf 0.1
[1] " "
     D d3 d2 d1 m1       lB  uB    P
[1,] 4  3  2  1  1 0.033028 Inf 0.01
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 4  3  2  1  1 0.017517 Inf 0.001
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 4  3  2  1  1 0.011685 Inf 1e-04
[1] " "
     D d3 d2 d1 m1      lB  uB   P
[1,] 5  3  2  1  1 0.14568 Inf 0.1
[1] " "
     D d3 d2 d1 m1       lB  uB    P
[1,] 5  3  2  1  1 0.032316 Inf 0.01
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 5  3  2  1  1 0.017127 Inf 0.001
[1] " "
     D d3 d2 d1 m1       lB  uB     P
[1,] 5  3  2  1  1 0.011387 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 106
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m1      lB  uB   P
[1,] 2  2  1  1 0.15842 Inf 0.1
[1] " "
     D d2 d1 m1       lB  uB    P
[1,] 2  2  1  1 0.035366 Inf 0.01
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 2  2  1  1 0.018778 Inf 0.001
[1] " "
     D d2 d1 m1      lB  uB     P
[1,] 2  2  1  1 0.01253 Inf 1e-04
[1] " "
     D d2 d1 m1      lB  uB   P
[1,] 3  2  1  1 0.15038 Inf 0.1
[1] " "
     D d2 d1 m1       lB  uB    P
[1,] 3  2  1  1 0.033488 Inf 0.01
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 3  2  1  1 0.017767 Inf 0.001
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 3  2  1  1 0.011853 Inf 1e-04
[1] " "
     D d2 d1 m1      lB  uB   P
[1,] 4  2  1  1 0.14588 Inf 0.1
[1] " "
     D d2 d1 m1       lB  uB    P
[1,] 4  2  1  1 0.032461 Inf 0.01
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 4  2  1  1 0.017211 Inf 0.001
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 4  2  1  1 0.011481 Inf 1e-04
[1] " "
     D d2 d1 m1      lB  uB   P
[1,] 5  2  1  1 0.14297 Inf 0.1
[1] " "
     D d2 d1 m1       lB  uB    P
[1,] 5  2  1  1 0.031813 Inf 0.01
[1] " "
     D d2 d1 m1      lB  uB     P
[1,] 5  2  1  1 0.01686 Inf 0.001
[1] " "
     D d2 d1 m1       lB  uB     P
[1,] 5  2  1  1 0.011208 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 107
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m1      lB  uB   P
[1,] 3  3  1  1 0.15038 Inf 0.1
[1] " "
[1] "Cycle"
     D d3 d1 m1       lB  uB    P
[1,] 3  3  1  1 0.033476 Inf 0.01
[1] " "
     D d3 d1 m1       lB  uB     P
[1,] 3  3  1  1 0.017768 Inf 0.001
[1] " "
     D d3 d1 m1       lB  uB     P
[1,] 3  3  1  1 0.011855 Inf 1e-04
[1] " "
     D d3 d1 m1      lB  uB   P
[1,] 4  3  1  1 0.14588 Inf 0.1
[1] " "
     D d3 d1 m1       lB  uB    P
[1,] 4  3  1  1 0.032365 Inf 0.01
[1] " "
     D d3 d1 m1       lB  uB     P
[1,] 4  3  1  1 0.017163 Inf 0.001
[1] " "
[1] "Cycle"
     D d3 d1 m1       lB  uB     P
[1,] 4  3  1  1 0.011449 Inf 1e-04
[1] " "
     D d3 d1 m1      lB  uB   P
[1,] 5  3  1  1 0.14297 Inf 0.1
[1] " "
     D d3 d1 m1       lB  uB    P
[1,] 5  3  1  1 0.031656 Inf 0.01
[1] " "
     D d3 d1 m1       lB  uB     P
[1,] 5  3  1  1 0.016774 Inf 0.001
[1] " "
     D d3 d1 m1       lB  uB     P
[1,] 5  3  1  1 0.011151 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 108
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m1      lB  uB   P
[1,] 1  1  1 0.17355 Inf 0.1
[1] " "
     D d1 m1       lB  uB    P
[1,] 1  1  1 0.038846 Inf 0.01
[1] " "
     D d1 m1      lB  uB     P
[1,] 1  1  1 0.02064 Inf 0.001
[1] " "
     D d1 m1       lB  uB     P
[1,] 1  1  1 0.013774 Inf 1e-04
[1] " "
     D d1 m1      lB  uB   P
[1,] 2  1  1 0.15427 Inf 0.1
[1] " "
     D d1 m1      lB  uB    P
[1,] 2  1  1 0.03453 Inf 0.01
[1] " "
     D d1 m1       lB  uB     P
[1,] 2  1  1 0.018346 Inf 0.001
[1] " "
     D d1 m1       lB  uB     P
[1,] 2  1  1 0.012244 Inf 1e-04
[1] " "
     D d1 m1      lB  uB   P
[1,] 3  1  1 0.14644 Inf 0.1
[1] " "
     D d1 m1       lB  uB    P
[1,] 3  1  1 0.032777 Inf 0.01
[1] " "
     D d1 m1       lB  uB     P
[1,] 3  1  1 0.017415 Inf 0.001
[1] " "
     D d1 m1       lB  uB     P
[1,] 3  1  1 0.011622 Inf 1e-04
[1] " "
     D d1 m1     lB  uB   P
[1,] 4  1  1 0.1421 Inf 0.1
[1] " "
     D d1 m1       lB  uB    P
[1,] 4  1  1 0.031823 Inf 0.01
[1] " "
     D d1 m1       lB  uB     P
[1,] 4  1  1 0.016908 Inf 0.001
[1] " "
     D d1 m1       lB  uB     P
[1,] 4  1  1 0.011284 Inf 1e-04
[1] " "
     D d1 m1      lB  uB   P
[1,] 5  1  1 0.13929 Inf 0.1
[1] " "
     D d1 m1       lB  uB    P
[1,] 5  1  1 0.031223 Inf 0.01
[1] " "
     D d1 m1       lB  uB     P
[1,] 5  1  1 0.016589 Inf 0.001
[1] " "
     D d1 m1       lB  uB     P
[1,] 5  1  1 0.011034 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 109
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m1      lB  uB   P
[1,] 3  3  2  1 0.15038 Inf 0.1
[1] " "
     D d3 d2 m1       lB  uB    P
[1,] 3  3  2  1 0.033659 Inf 0.01
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 3  3  2  1 0.017884 Inf 0.001
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 3  3  2  1 0.011935 Inf 1e-04
[1] " "
     D d3 d2 m1    lB  uB   P
[1,] 4  3  2  1 0.146 Inf 0.1
[1] " "
     D d3 d2 m1      lB  uB    P
[1,] 4  3  2  1 0.03268 Inf 0.01
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 4  3  2  1 0.017363 Inf 0.001
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 4  3  2  1 0.011588 Inf 1e-04
[1] " "
     D d3 d2 m1      lB  uB   P
[1,] 5  3  2  1 0.14325 Inf 0.1
[1] " "
     D d3 d2 m1       lB  uB    P
[1,] 5  3  2  1 0.032064 Inf 0.01
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 5  3  2  1 0.017036 Inf 0.001
[1] " "
     D d3 d2 m1       lB  uB     P
[1,] 5  3  2  1 0.011331 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 110
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m1      lB  uB   P
[1,] 2  2  1 0.15427 Inf 0.1
[1] " "
     D d2 m1      lB  uB    P
[1,] 2  2  1 0.03453 Inf 0.01
[1] " "
     D d2 m1       lB  uB     P
[1,] 2  2  1 0.018346 Inf 0.001
[1] " "
     D d2 m1       lB  uB     P
[1,] 2  2  1 0.012244 Inf 1e-04
[1] " "
     D d2 m1      lB  uB   P
[1,] 3  2  1 0.14644 Inf 0.1
[1] " "
     D d2 m1       lB  uB    P
[1,] 3  2  1 0.032777 Inf 0.01
[1] " "
     D d2 m1       lB  uB     P
[1,] 3  2  1 0.017415 Inf 0.001
[1] " "
     D d2 m1       lB  uB     P
[1,] 3  2  1 0.011622 Inf 1e-04
[1] " "
     D d2 m1      lB  uB   P
[1,] 4  2  1 0.14218 Inf 0.1
[1] " "
     D d2 m1       lB  uB    P
[1,] 4  2  1 0.031823 Inf 0.01
[1] " "
     D d2 m1       lB  uB     P
[1,] 4  2  1 0.016908 Inf 0.001
[1] " "
     D d2 m1       lB  uB     P
[1,] 4  2  1 0.011284 Inf 1e-04
[1] " "
     D d2 m1      lB  uB   P
[1,] 5  2  1 0.13949 Inf 0.1
[1] " "
     D d2 m1       lB  uB    P
[1,] 5  2  1 0.031223 Inf 0.01
[1] " "
     D d2 m1       lB  uB     P
[1,] 5  2  1 0.016589 Inf 0.001
[1] " "
     D d2 m1       lB  uB     P
[1,] 5  2  1 0.011034 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 111
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m1      lB  uB   P
[1,] 3  3  1 0.14644 Inf 0.1
[1] " "
     D d3 m1       lB  uB    P
[1,] 3  3  1 0.032777 Inf 0.01
[1] " "
     D d3 m1       lB  uB     P
[1,] 3  3  1 0.017415 Inf 0.001
[1] " "
[1] "Cycle"
     D d3 m1       lB  uB     P
[1,] 3  3  1 0.011622 Inf 1e-04
[1] " "
     D d3 m1      lB  uB   P
[1,] 4  3  1 0.14218 Inf 0.1
[1] " "
     D d3 m1       lB  uB    P
[1,] 4  3  1 0.031823 Inf 0.01
[1] " "
     D d3 m1       lB  uB     P
[1,] 4  3  1 0.016908 Inf 0.001
[1] " "
     D d3 m1       lB  uB     P
[1,] 4  3  1 0.011284 Inf 1e-04
[1] " "
     D d3 m1      lB  uB   P
[1,] 5  3  1 0.13949 Inf 0.1
[1] " "
     D d3 m1       lB  uB    P
[1,] 5  3  1 0.031223 Inf 0.01
[1] " "
     D d3 m1       lB  uB     P
[1,] 5  3  1 0.016589 Inf 0.001
[1] " "
     D d3 m1       lB  uB     P
[1,] 5  3  1 0.011034 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 112
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m1      lB  uB   P
[1,] 0  1 0.33376 Inf 0.1
[1] " "
     D m1       lB  uB    P
[1,] 0  1 0.074706 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 0  1 0.039693 Inf 0.001
[1] " "
     D m1      lB  uB     P
[1,] 0  1 0.02649 Inf 1e-04
[1] " "
     D m1      lB  uB   P
[1,] 1  1 0.16688 Inf 0.1
[1] " "
     D m1       lB  uB    P
[1,] 1  1 0.037353 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 1  1 0.019846 Inf 0.001
[1] " "
     D m1       lB  uB     P
[1,] 1  1 0.013245 Inf 1e-04
[1] " "
     D m1      lB  uB   P
[1,] 2  1 0.14834 Inf 0.1
[1] " "
     D m1       lB  uB    P
[1,] 2  1 0.033203 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 2  1 0.017641 Inf 0.001
[1] " "
     D m1       lB  uB     P
[1,] 2  1 0.011773 Inf 1e-04
[1] " "
     D m1      lB  uB   P
[1,] 3  1 0.14081 Inf 0.1
[1] " "
     D m1       lB  uB    P
[1,] 3  1 0.031517 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 3  1 0.016745 Inf 0.001
[1] " "
     D m1       lB  uB     P
[1,] 3  1 0.011175 Inf 1e-04
[1] " "
     D m1      lB  uB   P
[1,] 4  1 0.13671 Inf 0.1
[1] " "
     D m1     lB  uB    P
[1,] 4  1 0.0306 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 4  1 0.016258 Inf 0.001
[1] " "
     D m1      lB  uB     P
[1,] 4  1 0.01085 Inf 1e-04
[1] " "
     D m1      lB  uB   P
[1,] 5  1 0.13413 Inf 0.1
[1] " "
     D m1       lB  uB    P
[1,] 5  1 0.030023 Inf 0.01
[1] " "
     D m1       lB  uB     P
[1,] 5  1 0.015952 Inf 0.001
[1] " "
     D m1      lB  uB     P
[1,] 5  1 0.01061 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 113
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1 m0      lB  uB   P
[1,] 3  3  2  1  0 0.22322 Inf 0.1
[1] " "
     D d3 d2 d1 m0      lB  uB    P
[1,] 3  3  2  1  0 0.22322 Inf 0.01
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 3  3  2  1  0 0.22322 Inf 0.001
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 3  3  2  1  0 0.22322 Inf 1e-04
[1] " "
     D d3 d2 d1 m0      lB  uB   P
[1,] 4  3  2  1  0 0.21836 Inf 0.1
[1] " "
     D d3 d2 d1 m0      lB  uB    P
[1,] 4  3  2  1  0 0.21836 Inf 0.01
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 4  3  2  1  0 0.21836 Inf 0.001
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 4  3  2  1  0 0.21836 Inf 1e-04
[1] " "
     D d3 d2 d1 m0      lB  uB   P
[1,] 5  3  2  1  0 0.21514 Inf 0.1
[1] " "
     D d3 d2 d1 m0      lB  uB    P
[1,] 5  3  2  1  0 0.21514 Inf 0.01
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 5  3  2  1  0 0.21514 Inf 0.001
[1] " "
     D d3 d2 d1 m0      lB  uB     P
[1,] 5  3  2  1  0 0.21514 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 114
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1 m0      lB  uB   P
[1,] 2  2  1  0 0.22432 Inf 0.1
[1] " "
     D d2 d1 m0      lB  uB    P
[1,] 2  2  1  0 0.22432 Inf 0.01
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 2  2  1  0 0.22432 Inf 0.001
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 2  2  1  0 0.22432 Inf 1e-04
[1] " "
     D d2 d1 m0      lB  uB   P
[1,] 3  2  1  0 0.21924 Inf 0.1
[1] " "
     D d2 d1 m0      lB  uB    P
[1,] 3  2  1  0 0.21924 Inf 0.01
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 3  2  1  0 0.21924 Inf 0.001
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 3  2  1  0 0.21924 Inf 1e-04
[1] " "
     D d2 d1 m0     lB  uB   P
[1,] 4  2  1  0 0.2167 Inf 0.1
[1] " "
     D d2 d1 m0     lB  uB    P
[1,] 4  2  1  0 0.2167 Inf 0.01
[1] " "
     D d2 d1 m0     lB  uB     P
[1,] 4  2  1  0 0.2167 Inf 0.001
[1] " "
     D d2 d1 m0     lB  uB     P
[1,] 4  2  1  0 0.2167 Inf 1e-04
[1] " "
     D d2 d1 m0      lB  uB   P
[1,] 5  2  1  0 0.21517 Inf 0.1
[1] " "
     D d2 d1 m0      lB  uB    P
[1,] 5  2  1  0 0.21517 Inf 0.01
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 5  2  1  0 0.21517 Inf 0.001
[1] " "
     D d2 d1 m0      lB  uB     P
[1,] 5  2  1  0 0.21517 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 115
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1 m0      lB  uB   P
[1,] 3  3  1  0 0.21966 Inf 0.1
[1] " "
     D d3 d1 m0      lB  uB    P
[1,] 3  3  1  0 0.21966 Inf 0.01
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 3  3  1  0 0.21966 Inf 0.001
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 3  3  1  0 0.21966 Inf 1e-04
[1] " "
     D d3 d1 m0      lB  uB   P
[1,] 4  3  1  0 0.21371 Inf 0.1
[1] " "
     D d3 d1 m0      lB  uB    P
[1,] 4  3  1  0 0.21371 Inf 0.01
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 4  3  1  0 0.21371 Inf 0.001
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 4  3  1  0 0.21371 Inf 1e-04
[1] " "
     D d3 d1 m0      lB  uB   P
[1,] 5  3  1  0 0.21032 Inf 0.1
[1] " "
     D d3 d1 m0      lB  uB    P
[1,] 5  3  1  0 0.21032 Inf 0.01
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 5  3  1  0 0.21032 Inf 0.001
[1] " "
     D d3 d1 m0      lB  uB     P
[1,] 5  3  1  0 0.21032 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 116
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 m0      lB  uB   P
[1,] 1  1  0 0.23695 Inf 0.1
[1] " "
     D d1 m0      lB  uB    P
[1,] 1  1  0 0.23695 Inf 0.01
[1] " "
     D d1 m0      lB  uB     P
[1,] 1  1  0 0.23695 Inf 0.001
[1] " "
     D d1 m0      lB  uB     P
[1,] 1  1  0 0.23695 Inf 1e-04
[1] " "
     D d1 m0      lB  uB   P
[1,] 2  1  0 0.23695 Inf 0.1
[1] " "
     D d1 m0      lB  uB    P
[1,] 2  1  0 0.23695 Inf 0.01
[1] " "
     D d1 m0      lB  uB     P
[1,] 2  1  0 0.23695 Inf 0.001
[1] " "
     D d1 m0      lB  uB     P
[1,] 2  1  0 0.23695 Inf 1e-04
[1] " "
     D d1 m0      lB  uB   P
[1,] 3  1  0 0.23695 Inf 0.1
[1] " "
     D d1 m0      lB  uB    P
[1,] 3  1  0 0.23695 Inf 0.01
[1] " "
     D d1 m0      lB  uB     P
[1,] 3  1  0 0.23695 Inf 0.001
[1] " "
     D d1 m0      lB  uB     P
[1,] 3  1  0 0.23695 Inf 1e-04
[1] " "
     D d1 m0      lB  uB   P
[1,] 4  1  0 0.23695 Inf 0.1
[1] " "
     D d1 m0      lB  uB    P
[1,] 4  1  0 0.23695 Inf 0.01
[1] " "
     D d1 m0      lB  uB     P
[1,] 4  1  0 0.23695 Inf 0.001
[1] " "
     D d1 m0      lB  uB     P
[1,] 4  1  0 0.23695 Inf 1e-04
[1] " "
     D d1 m0      lB  uB   P
[1,] 5  1  0 0.23695 Inf 0.1
[1] " "
     D d1 m0      lB  uB    P
[1,] 5  1  0 0.23695 Inf 0.01
[1] " "
     D d1 m0      lB  uB     P
[1,] 5  1  0 0.23695 Inf 0.001
[1] " "
     D d1 m0      lB  uB     P
[1,] 5  1  0 0.23695 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 117
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 m0      lB  uB   P
[1,] 3  3  2  0 0.23956 Inf 0.1
[1] " "
     D d3 d2 m0      lB  uB    P
[1,] 3  3  2  0 0.23956 Inf 0.01
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 3  3  2  0 0.23956 Inf 0.001
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 3  3  2  0 0.23956 Inf 1e-04
[1] " "
     D d3 d2 m0      lB  uB   P
[1,] 4  3  2  0 0.23956 Inf 0.1
[1] " "
     D d3 d2 m0      lB  uB    P
[1,] 4  3  2  0 0.23956 Inf 0.01
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 4  3  2  0 0.23956 Inf 0.001
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 4  3  2  0 0.23956 Inf 1e-04
[1] " "
     D d3 d2 m0      lB  uB   P
[1,] 5  3  2  0 0.23956 Inf 0.1
[1] " "
     D d3 d2 m0      lB  uB    P
[1,] 5  3  2  0 0.23956 Inf 0.01
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 5  3  2  0 0.23956 Inf 0.001
[1] " "
     D d3 d2 m0      lB  uB     P
[1,] 5  3  2  0 0.23956 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 118
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 m0      lB  uB   P
[1,] 2  2  0 0.23695 Inf 0.1
[1] " "
     D d2 m0      lB  uB    P
[1,] 2  2  0 0.23695 Inf 0.01
[1] " "
     D d2 m0      lB  uB     P
[1,] 2  2  0 0.23695 Inf 0.001
[1] " "
     D d2 m0      lB  uB     P
[1,] 2  2  0 0.23695 Inf 1e-04
[1] " "
     D d2 m0      lB  uB   P
[1,] 3  2  0 0.23695 Inf 0.1
[1] " "
     D d2 m0      lB  uB    P
[1,] 3  2  0 0.23695 Inf 0.01
[1] " "
     D d2 m0      lB  uB     P
[1,] 3  2  0 0.23695 Inf 0.001
[1] " "
     D d2 m0      lB  uB     P
[1,] 3  2  0 0.23695 Inf 1e-04
[1] " "
     D d2 m0      lB  uB   P
[1,] 4  2  0 0.23695 Inf 0.1
[1] " "
     D d2 m0      lB  uB    P
[1,] 4  2  0 0.23695 Inf 0.01
[1] " "
     D d2 m0      lB  uB     P
[1,] 4  2  0 0.23695 Inf 0.001
[1] " "
     D d2 m0      lB  uB     P
[1,] 4  2  0 0.23695 Inf 1e-04
[1] " "
     D d2 m0      lB  uB   P
[1,] 5  2  0 0.23695 Inf 0.1
[1] " "
     D d2 m0      lB  uB    P
[1,] 5  2  0 0.23695 Inf 0.01
[1] " "
     D d2 m0      lB  uB     P
[1,] 5  2  0 0.23695 Inf 0.001
[1] " "
     D d2 m0      lB  uB     P
[1,] 5  2  0 0.23695 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 119
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 m0      lB  uB   P
[1,] 3  3  0 0.23695 Inf 0.1
[1] " "
     D d3 m0      lB  uB    P
[1,] 3  3  0 0.23695 Inf 0.01
[1] " "
     D d3 m0      lB  uB     P
[1,] 3  3  0 0.23695 Inf 0.001
[1] " "
     D d3 m0      lB  uB     P
[1,] 3  3  0 0.23695 Inf 1e-04
[1] " "
     D d3 m0      lB  uB   P
[1,] 4  3  0 0.23695 Inf 0.1
[1] " "
     D d3 m0      lB  uB    P
[1,] 4  3  0 0.23695 Inf 0.01
[1] " "
     D d3 m0      lB  uB     P
[1,] 4  3  0 0.23695 Inf 0.001
[1] " "
     D d3 m0      lB  uB     P
[1,] 4  3  0 0.23695 Inf 1e-04
[1] " "
     D d3 m0      lB  uB   P
[1,] 5  3  0 0.23695 Inf 0.1
[1] " "
     D d3 m0      lB  uB    P
[1,] 5  3  0 0.23695 Inf 0.01
[1] " "
     D d3 m0      lB  uB     P
[1,] 5  3  0 0.23695 Inf 0.001
[1] " "
     D d3 m0      lB  uB     P
[1,] 5  3  0 0.23695 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 120
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D m0      lB  uB   P
[1,] 0  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 0  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 0  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 0  0 0.23345 Inf 1e-04
[1] " "
     D m0      lB  uB   P
[1,] 1  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 1  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 1  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 1  0 0.23345 Inf 1e-04
[1] " "
     D m0      lB  uB   P
[1,] 2  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 2  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 2  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 2  0 0.23345 Inf 1e-04
[1] " "
     D m0      lB  uB   P
[1,] 3  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 3  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 3  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 3  0 0.23345 Inf 1e-04
[1] " "
     D m0      lB  uB   P
[1,] 4  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 4  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 4  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 4  0 0.23345 Inf 1e-04
[1] " "
     D m0      lB  uB   P
[1,] 5  0 0.23345 Inf 0.1
[1] " "
     D m0      lB  uB    P
[1,] 5  0 0.23345 Inf 0.01
[1] " "
     D m0      lB  uB     P
[1,] 5  0 0.23345 Inf 0.001
[1] " "
     D m0      lB  uB     P
[1,] 5  0 0.23345 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 121
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2 d1      lB  uB   P
[1,] 3  3  2  1 0.97967 Inf 0.1
[1] " "
     D d3 d2 d1      lB  uB    P
[1,] 3  3  2  1 0.97967 Inf 0.01
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 3  3  2  1 0.97967 Inf 0.001
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 3  3  2  1 0.97967 Inf 1e-04
[1] " "
     D d3 d2 d1      lB  uB   P
[1,] 4  3  2  1 0.97415 Inf 0.1
[1] " "
     D d3 d2 d1      lB  uB    P
[1,] 4  3  2  1 0.97415 Inf 0.01
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 4  3  2  1 0.97415 Inf 0.001
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 4  3  2  1 0.97415 Inf 1e-04
[1] " "
     D d3 d2 d1      lB  uB   P
[1,] 5  3  2  1 0.97075 Inf 0.1
[1] " "
     D d3 d2 d1      lB  uB    P
[1,] 5  3  2  1 0.97075 Inf 0.01
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 5  3  2  1 0.97075 Inf 0.001
[1] " "
     D d3 d2 d1      lB  uB     P
[1,] 5  3  2  1 0.97075 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 122
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 d1      lB  uB   P
[1,] 2  2  1 0.98362 Inf 0.1
[1] " "
     D d2 d1      lB  uB    P
[1,] 2  2  1 0.98362 Inf 0.01
[1] " "
     D d2 d1      lB  uB     P
[1,] 2  2  1 0.98362 Inf 0.001
[1] " "
     D d2 d1      lB  uB     P
[1,] 2  2  1 0.98362 Inf 1e-04
[1] " "
     D d2 d1      lB  uB   P
[1,] 3  2  1 0.97817 Inf 0.1
[1] " "
     D d2 d1      lB  uB    P
[1,] 3  2  1 0.97817 Inf 0.01
[1] " "
     D d2 d1      lB  uB     P
[1,] 3  2  1 0.97817 Inf 0.001
[1] " "
     D d2 d1      lB  uB     P
[1,] 3  2  1 0.97817 Inf 1e-04
[1] " "
     D d2 d1      lB  uB   P
[1,] 4  2  1 0.97544 Inf 0.1
[1] " "
     D d2 d1      lB  uB    P
[1,] 4  2  1 0.97544 Inf 0.01
[1] " "
     D d2 d1      lB  uB     P
[1,] 4  2  1 0.97544 Inf 0.001
[1] " "
     D d2 d1      lB  uB     P
[1,] 4  2  1 0.97544 Inf 1e-04
[1] " "
     D d2 d1     lB  uB   P
[1,] 5  2  1 0.9738 Inf 0.1
[1] " "
     D d2 d1     lB  uB    P
[1,] 5  2  1 0.9738 Inf 0.01
[1] " "
     D d2 d1     lB  uB     P
[1,] 5  2  1 0.9738 Inf 0.001
[1] " "
     D d2 d1     lB  uB     P
[1,] 5  2  1 0.9738 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 123
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d1      lB  uB   P
[1,] 3  3  1 0.97904 Inf 0.1
[1] " "
     D d3 d1      lB  uB    P
[1,] 3  3  1 0.97904 Inf 0.01
[1] " "
     D d3 d1      lB  uB     P
[1,] 3  3  1 0.97904 Inf 0.001
[1] " "
     D d3 d1      lB  uB     P
[1,] 3  3  1 0.97904 Inf 1e-04
[1] " "
     D d3 d1      lB  uB   P
[1,] 4  3  1 0.97277 Inf 0.1
[1] " "
     D d3 d1      lB  uB    P
[1,] 4  3  1 0.97277 Inf 0.01
[1] " "
     D d3 d1      lB  uB     P
[1,] 4  3  1 0.97277 Inf 0.001
[1] " "
     D d3 d1      lB  uB     P
[1,] 4  3  1 0.97277 Inf 1e-04
[1] " "
     D d3 d1     lB  uB   P
[1,] 5  3  1 0.9692 Inf 0.1
[1] " "
     D d3 d1      lB  uB    P
[1,] 5  3  1 0.96919 Inf 0.01
[1] " "
     D d3 d1      lB  uB     P
[1,] 5  3  1 0.96919 Inf 0.001
[1] " "
     D d3 d1      lB  uB     P
[1,] 5  3  1 0.96919 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 124
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d1 lB  uB   P
[1,] 1  1  1 Inf 0.1
[1] " "
     D d1 lB  uB    P
[1,] 1  1  1 Inf 0.01
[1] " "
     D d1 lB  uB     P
[1,] 1  1  1 Inf 0.001
[1] " "
     D d1 lB  uB     P
[1,] 1  1  1 Inf 1e-04
[1] " "
     D d1 lB  uB   P
[1,] 2  1  1 Inf 0.1
[1] " "
     D d1 lB  uB    P
[1,] 2  1  1 Inf 0.01
[1] " "
     D d1 lB  uB     P
[1,] 2  1  1 Inf 0.001
[1] " "
     D d1 lB  uB     P
[1,] 2  1  1 Inf 1e-04
[1] " "
     D d1 lB  uB   P
[1,] 3  1  1 Inf 0.1
[1] " "
     D d1 lB  uB    P
[1,] 3  1  1 Inf 0.01
[1] " "
     D d1 lB  uB     P
[1,] 3  1  1 Inf 0.001
[1] " "
     D d1 lB  uB     P
[1,] 3  1  1 Inf 1e-04
[1] " "
     D d1 lB  uB   P
[1,] 4  1  1 Inf 0.1
[1] " "
     D d1 lB  uB    P
[1,] 4  1  1 Inf 0.01
[1] " "
     D d1 lB  uB     P
[1,] 4  1  1 Inf 0.001
[1] " "
     D d1 lB  uB     P
[1,] 4  1  1 Inf 1e-04
[1] " "
     D d1 lB  uB   P
[1,] 5  1  1 Inf 0.1
[1] " "
     D d1 lB  uB    P
[1,] 5  1  1 Inf 0.01
[1] " "
     D d1 lB  uB     P
[1,] 5  1  1 Inf 0.001
[1] " "
     D d1 lB  uB     P
[1,] 5  1  1 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 125
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 d2      lB  uB   P
[1,] 3  3  2 0.99999 Inf 0.1
[1] " "
     D d3 d2      lB  uB    P
[1,] 3  3  2 0.99999 Inf 0.01
[1] " "
     D d3 d2      lB  uB     P
[1,] 3  3  2 0.99999 Inf 0.001
[1] " "
     D d3 d2      lB  uB     P
[1,] 3  3  2 0.99999 Inf 1e-04
[1] " "
     D d3 d2      lB  uB   P
[1,] 4  3  2 0.99999 Inf 0.1
[1] " "
     D d3 d2      lB  uB    P
[1,] 4  3  2 0.99999 Inf 0.01
[1] " "
     D d3 d2      lB  uB     P
[1,] 4  3  2 0.99999 Inf 0.001
[1] " "
     D d3 d2      lB  uB     P
[1,] 4  3  2 0.99999 Inf 1e-04
[1] " "
     D d3 d2      lB  uB   P
[1,] 5  3  2 0.99998 Inf 0.1
[1] " "
     D d3 d2      lB  uB    P
[1,] 5  3  2 0.99998 Inf 0.01
[1] " "
     D d3 d2      lB  uB     P
[1,] 5  3  2 0.99998 Inf 0.001
[1] " "
     D d3 d2      lB  uB     P
[1,] 5  3  2 0.99998 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 126
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d2 lB  uB   P
[1,] 2  2  1 Inf 0.1
[1] " "
     D d2 lB  uB    P
[1,] 2  2  1 Inf 0.01
[1] " "
     D d2 lB  uB     P
[1,] 2  2  1 Inf 0.001
[1] " "
     D d2 lB  uB     P
[1,] 2  2  1 Inf 1e-04
[1] " "
     D d2 lB  uB   P
[1,] 3  2  1 Inf 0.1
[1] " "
     D d2 lB  uB    P
[1,] 3  2  1 Inf 0.01
[1] " "
     D d2 lB  uB     P
[1,] 3  2  1 Inf 0.001
[1] " "
     D d2 lB  uB     P
[1,] 3  2  1 Inf 1e-04
[1] " "
     D d2 lB  uB   P
[1,] 4  2  1 Inf 0.1
[1] " "
     D d2 lB  uB    P
[1,] 4  2  1 Inf 0.01
[1] " "
     D d2 lB  uB     P
[1,] 4  2  1 Inf 0.001
[1] " "
     D d2 lB  uB     P
[1,] 4  2  1 Inf 1e-04
[1] " "
     D d2 lB  uB   P
[1,] 5  2  1 Inf 0.1
[1] " "
     D d2 lB  uB    P
[1,] 5  2  1 Inf 0.01
[1] " "
     D d2 lB  uB     P
[1,] 5  2  1 Inf 0.001
[1] " "
     D d2 lB  uB     P
[1,] 5  2  1 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 127
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D d3 lB  uB   P
[1,] 3  3  1 Inf 0.1
[1] " "
     D d3 lB  uB    P
[1,] 3  3  1 Inf 0.01
[1] " "
     D d3 lB  uB     P
[1,] 3  3  1 Inf 0.001
[1] " "
     D d3 lB  uB     P
[1,] 3  3  1 Inf 1e-04
[1] " "
     D d3 lB  uB   P
[1,] 4  3  1 Inf 0.1
[1] " "
     D d3 lB  uB    P
[1,] 4  3  1 Inf 0.01
[1] " "
     D d3 lB  uB     P
[1,] 4  3  1 Inf 0.001
[1] " "
     D d3 lB  uB     P
[1,] 4  3  1 Inf 1e-04
[1] " "
     D d3 lB  uB   P
[1,] 5  3  1 Inf 0.1
[1] " "
     D d3 lB  uB    P
[1,] 5  3  1 Inf 0.01
[1] " "
     D d3 lB  uB     P
[1,] 5  3  1 Inf 0.001
[1] " "
     D d3 lB  uB     P
[1,] 5  3  1 Inf 1e-04
[1] " "
> 
> 
> # !!!!!! Run this script from the command line by typing !!!!!
> # ./shell/RjobRun.sh
> # from the home directory of this repositary
> 
> rm(list=ls())
> library(dplyr)
> 
> myArgs <- commandArgs()
> i <- as.numeric(myArgs[length(myArgs)]) ; print(i) 
[1] 128
> 
> ###
> ### 0. Load files, set seed and define output file
> ###
> 
> load("data/log_Hill_data_optimparam.Rdata") # Obtain by running getOptimParam.R
> load("data/log_Hill_Horror_dist.Rdata") # Obtain by running getDataFigure1.R
> 
> a <- as.numeric(quantile(sample,0.8)) # Threshold a for GLP
> m <- 0:3
> d <- 3:1
> P <- 1- c(10^-1,10^-2,10^-3,10^-4)
> 
> nmax_est_param <- length(m) + length(d)
> 
> #
> # 1. Initialize output
> #
> if (i == 1)
+ {
+   names = c(names(designTab), "D", "P",
+             "ParamCover","boundCover","elapsed.time","CPU.time",
+             "uB","lB","status","eps","C","lastx")
+   
+   optim <- data.frame(matrix(NA,ncol = length(names), nrow = 1)) 
+   names(optim) <- names
+   
+   constFun = objFun = optim_outDist = list()
+   
+ } else  load("data/MaxLogdHorrorDist_TailProb.Rdata")
> 
> # Find all the rows in the DoE that have the parameters associated with i
> param_est <- designTab[i,]
> 
> # Index of estimated derivatives and moments
> ind_d <- unlist(param_est[1:length(d)])
> ind_m <- unlist(param_est[(length(d)+1):nmax_est_param])
> 
> # Obtain the set J1 and J2
> J1 <- union(0, m[ind_m]) 
> J2 <- d[ind_d]
> 
> # Set the value of J
> J <- max(J2)
> J <- if (J == -Inf)  0 else J
> 
> C <- DistributionPty::qlhorror(1-1e-16) # Upper bound of the compact support of the distributions to investigate from
> 
> # Get bounds on constraints inequalities
> point_estimates <- optim_param[i,!is.na(optim_param[i,])] %>% select(-cover) 
> constRHS <- NULL
> 
> for (j in J2){
+   newRHS <- point_estimates[paste0("d",j,c("L","U"))] %>% as.numeric %>% `*`((-1)^(j+1)) %>% sort
+   constRHS <- c(constRHS, newRHS)
+ }  
> 
> for (j in J1){
+   newRHS <- point_estimates[paste0("m",j,c("L","U"))] %>% as.numeric
+   constRHS <- c(constRHS, newRHS)
+ }
> 
> # Get the direction of constraints ineqaulities
> constDir = rep(c(">=", "<="), length(constRHS)/2)
> 
> # Create Lambda const
> constLambda = rep(0,length(constRHS))
> constLambda[length(constRHS) - c(1,0)] = 1
> 
> # Lambda of the objective function
> objLambda <- if (setequal(J1,0))  1 else 0
> 
> # Get the upper bound on the distribution function
> gamma <- constRHS[2] 
> 
> k <- nrow(optim)
> for(D in J:5)
+ {
+   # Create the set of function constraints and objective function (change with D)
+   new_constFun <- rep(GLP::buildMomentDerivativeConstFunc(D,J1,J2), each = 2)
+   
+   # Compute the initial feasible solution
+   initBFS <- GLP:: phase1(new_constFun,
+                           constRHS,
+                           constDir,
+                           constLambda,
+                           C =  C,
+                           IterMax = 200)
+   
+   for (p in P)
+   {
+     # Objective function
+     objFun[[k]]  <- function(x, paramObjFun) 
+     {
+       c <- DistributionPty::qlhorror(p)
+       
+       output <-  if (max(c-a,0) < x) x^(J-D)/factorial(D)*(x - max(c-a,0))^D else 0
+       return(output)
+     } 
+     
+     constFun[[k]] <- new_constFun
+     
+     # Compute optimal upper bound and measure the time needed to do so
+     start <- proc.time()
+     out <- GLP::phase2(initBFS = initBFS,
+                        objFun = objFun[[k]] ,
+                        constFun = constFun[[k]] ,
+                        constRHS,
+                        constDir,
+                        constLambda,
+                        objLambda,
+                        gamma = NULL,
+                        C = C,
+                        IterMax = 200,
+                        err = 1e-7)
+     end <- proc.time()
+     
+     # Record results
+     if (k!=1) optim <- rbind(optim, NA) # Add a row if k is not 1
+     
+     optim[k,1:nmax_est_param] <- designTab[i, ]
+     optim$D[k] <- D
+     optim$P[k] <- p
+     optim$ParamCover[k] <- optim_param$cover[i]
+     optim$elapsed.time[k] <- (end - start)["elapsed"]
+     optim$CPU.time[k]     <- (end - start)["user.self"]
+     optim$uB[k]         <- out$uB
+     optim$lB[k]         <- out$lB
+     optim$status[k]     <- out$status
+     optim$eps[k]        <- out$eps
+     optim$lastx[k]      <- out$lastx
+     optim$C[k]  <- C
+     optim$boundCover[k] <- out$lB >= 1-optim$P[k] 
+     
+     optim_outDist[[k]] <- list(x = out$x, p = out$p,  s = out$s, lpdual = out$lpdual)
+     
+     # Display and save the results 
+     sum_print <- matrix(c(D,d[ind_d],m[ind_m],signif(out$lB,5),signif(out$uB,5),1-p),nrow = 1)
+     colnames(sum_print) <- c("D",names(ind_d[ind_d]),names(ind_m[ind_m]),"lB","uB", "P" )
+     print(sum_print)
+     print(" ")
+     
+     save(optim,optim_param,optim_outDist,
+          P,a,m,d,truth,
+          objFun,constFun,
+          file = "data/MaxLogdHorrorDist_TailProb.Rdata")
+     
+     k <- k+1
+   }
+ }
     D lB  uB   P
[1,] 0  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 0  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 0  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 0  1 Inf 1e-04
[1] " "
     D lB  uB   P
[1,] 1  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 1  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 1  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 1  1 Inf 1e-04
[1] " "
     D lB  uB   P
[1,] 2  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 2  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 2  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 2  1 Inf 1e-04
[1] " "
     D lB  uB   P
[1,] 3  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 3  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 3  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 3  1 Inf 1e-04
[1] " "
     D lB  uB   P
[1,] 4  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 4  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 4  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 4  1 Inf 1e-04
[1] " "
     D lB  uB   P
[1,] 5  1 Inf 0.1
[1] " "
     D lB  uB    P
[1,] 5  1 Inf 0.01
[1] " "
     D lB  uB     P
[1,] 5  1 Inf 0.001
[1] " "
     D lB  uB     P
[1,] 5  1 Inf 1e-04
[1] " "
> 
> 
